# AI 編程速成課程 - 完整大綱 v2.0（情境驅動學習版）

## 📘 課程概述

**課程名稱**：AI 編程速成課程：從情境實戰到企業級整合
**課程版本**：v2.0（情境驅動學習版）
**課程時長**：15 小時（核心課程）+ 彈性實戰練習
**更新日期**：2025 年 1 月
**適用對象**：有程式基礎、想掌握 AI 編程的開發者

---

## 🎯 課程定位與革新

### v2.0 核心革新

**從 v1.0 到 v2.0 的重大改變**：

| 維度 | v1.0（傳統教學） | v2.0（情境驅動） |
|------|-----------------|----------------|
| **教學方式** | 講解指令 → 練習 | 情境問題 → 自然發現指令 |
| **學習路徑** | 線性知識堆疊 | 螺旋式問題解決 |
| **記憶方法** | 背誦指令清單 | Anki 式情境記憶卡 |
| **練習形式** | 孤立指令練習 | 真實場景模擬 |
| **評量方式** | 指令知識測驗 | 實戰問題解決能力 |
| **學習類比** | 傳統教科書 | Linux 高手養成法 |

**為什麼要改變？**

```
問題：
傳統方式：講解 /help, /agents, /mcp, /output-style...
結果：學員聽完就忘，遇到實際問題不知道用什麼

解決：
情境驅動：
- 情境1：團隊新人快速理解舊專案
  → 自然學會 Gemini CLI + /output-style
- 情境2：生產環境緊急救火
  → 自然學會 /bashes + /agents + /memory
- 情境3：開源專案貢獻完整流程
  → 自然學會完整工作流程編排

結果：透過解決實際問題，有機記憶指令組合
```

---

### 目標學員（TA）

本課程專為以下學員設計：

1. **有程式基礎但缺乏大型項目經驗的學生**
   - 已掌握至少一門程式語言
   - 希望學習如何用 AI 提升開發效率
   - 想要建立系統化的工程思維

2. **想往高階工程師邁進的開發者**
   - 具備 1-3 年開發經驗
   - 希望突破「初級程式員」瓶頸
   - 想要掌握架構思維與自動化能力

3. **在 AI 時代透過規劃思考，由 AI 代勞產出的專業人士**
   - 產品經理、技術主管、創業者
   - 需要理解並驗證 AI 生成的程式碼
   - 希望建立 AI 輔助的知識工作流程

4. **想應用 AI 於非程式設計領域的知識工作者**（v2.0 新增）
   - 內容創作者、研究者、文字工作者
   - 需要知識萃取、筆記整理、文案生成
   - 希望自動化重複性知識工作

---

### 核心學習目標

完成本課程後，學員將能夠：

✅ **理解 AI 輔助開發的第一性原理**
- 掌握上下文工程（Context Engineering）的核心概念
- 理解從「程式碼生成」到「程式碼驗證」的範式轉移
- 認識 AI 工具的能力邊界與局限性
- **新增**：理解 Claude Code 作為 AI Agent 交互平台的本質

✅ **精通三大主流 AI 編程工具**
- Claude Code：CLI 代理人協作者 + AI Agent 平台
- GitHub Copilot：IDE 內建助手
- Gemini CLI：巨量上下文分析工具
- **新增**：掌握工具選擇策略與混合使用

✅ **建立有原則的 AI 輔助工作流程**
- 探索→規劃→編碼→驗證（EPCV）流程
- 測試驅動開發（TDD）與 AI 協作
- 行為驅動開發（BDD）自動化
- **新增**：多代理人協同工作流程編排

✅ **掌握企業級 AI 工程實踐**
- CI/CD 自動化整合
- 安全掃描與自動修復
- 多代理人系統編排
- **新增**：MCP 伺服器整合與自訂

✅ **從「感覺式編碼」提升到「AI 增強型架構師」**
- 系統性驗證 AI 產出的能力
- 架構設計與代理人編排思維
- 團隊協作與知識管理
- **新增**：情境驅動的持續學習能力

✅ **應用 AI 於非程式設計領域**（v2.0 新增）
- 知識萃取與筆記系統自動化
- 技術文檔與內容創作
- 會議紀錄智能處理
- 多語言內容生成

---

## 📋 課程結構總覽

### 學習哲學：像學 Linux 一樣學 Claude Code

**Linux 高手的學習路徑**：
```bash
# 不是死背指令：
ls, cd, grep, find, sed, awk...

# 而是解決實際問題：
情境：找出系統中最大的 10 個日誌檔案
思考：列出檔案 → 看大小 → 排序 → 取前10
自然學會：du -sh /var/log/* | sort -rh | head -10

# 透過解決問題，自然記住指令組合
```

**Claude Code 的學習路徑（v2.0）**：
```
不是死背指令：
/help, /agents, /mcp, /output-style, /memory...

而是解決實際情境：
情境1：混亂的專案資料夾需要整理
→ 自然學會描述問題的方式
情境2：快速理解陌生專案
→ 自然學會 --add-dir, /context, /compact
情境3：生產環境緊急救火
→ 自然學會 /bashes + /agents + /output-style
情境4：開源專案完整貢獻
→ 自然學會完整工作流程編排

透過情境，有機記憶指令組合
```

---

### 完整模組地圖

```
┌─────────────────────────────────────────────────────────┐
│ 🎓 模組 0：情境驅動學習法入門（1h）                       │
│ └─ 學習如何學習 Claude Code                              │
│    ✓ Linux 學習法類比                                   │
│    ✓ 情境題解題訓練                                     │
│    ✓ Anki 記憶卡系統建立                                │
│    ✓ 個人情境題庫設計                                   │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 📚 階段一：基礎認知與工具入門（2h）                       │
│                                                          │
│ 模組 1：AI 編程基礎認知與工具選擇                         │
│ ├─ 1.1 AI 輔助開發現狀解析（30min）                      │
│ │  情境：分析一段 AI 生成的「看似正確」程式碼             │
│ │                                                       │
│ ├─ 1.2 三大工具哲學對比（45min）                         │
│ │  情境：為不同場景選擇合適的工具                        │
│ │                                                       │
│ └─ 1.3 上下文工程第一性原理（45min）                     │
│    情境：建立第一個專案記憶檔案（CLAUDE.md）             │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 🛠️ 階段二：CLI 工具精通（4.5h）                          │
│                                                          │
│ 模組 2：Claude Code 基礎操作（2h）                        │
│ ├─ 2.1 安裝與配置（30min）                               │
│ │  情境：完成環境設置並通過第一個任務                     │
│ │                                                       │
│ ├─ 2.2 上下文管理與記憶系統（60min）                     │
│ │  情境1：整理混亂的專案資料夾                           │
│ │  情境2：快速理解陌生的開源專案                         │
│ │  學習：--add-dir, /context, /compact, /memory        │
│ │                                                       │
│ └─ 2.3 程式碼庫分析與重構（30min）                       │
│    情境：API 版本遷移（v1 → v2）                        │
│    學習：EPCV 流程（探索→規劃→編碼→驗證）                │
│                                                          │
│ 模組 2.5：進階指令整合應用★（2h）                         │
│ ├─ 2.5.1 重新認識 Claude Code（30min）                  │
│ │  核心：從程式碼助理到 AI Agent 交互平台                │
│ │  情境：會議錄音轉行動項目（多工具協同）                 │
│ │                                                       │
│ ├─ 2.5.2 /agents 深度應用（30min）                      │
│ │  情境：開源專案完整貢獻流程                            │
│ │  學習：agent 切換、專家協同                           │
│ │                                                       │
│ ├─ 2.5.3 /mcp 整合外部世界（30min）                     │
│ │  情境：自動化週報生成系統                             │
│ │  學習：MCP 伺服器配置與使用                           │
│ │                                                       │
│ └─ 2.5.4 /output-style 控制輸出（30min）                │
│    情境：多語言技術文檔自動生成                          │
│    學習：自訂輸出風格模板                               │
│                                                          │
│ 模組 3：IDE 整合 - 內循環效率提升（30min 精簡版）         │
│ └─ GitHub Copilot 與 Gemini CLI 快速對比               │
│    情境：選擇適合日常開發的工具組合                      │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 🔬 階段三：單元實作與驗證（3.5h）                         │
│                                                          │
│ 模組 4：TDD/BDD 與 AI 協作（2h）                          │
│ ├─ 4.1 AI 驅動的測試驅動開發（60min）                    │
│ │  情境：構建任務管理系統（TDD 方式）                    │
│ │  學習：紅-綠-重構循環、介面先行設計                    │
│ │                                                       │
│ └─ 4.2 行為驅動開發與 Gherkin（60min）                  │
│    情境：電商結帳流程 BDD 測試                          │
│    學習：從使用者故事到可執行規範                        │
│                                                          │
│ 模組 5：CI/CD 自動化整合（1.5h）                          │
│ ├─ 5.1 GitHub Actions 整合（45min）                     │
│ │  情境：建立完整的測試管線                             │
│ │                                                       │
│ └─ 5.2 安全掃描與自動修復（45min）                       │
│    情境：建立安全掃描管線，自動阻止有漏洞的 PR           │
│    學習：CodeQL + Copilot Autofix + Gemini Security    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 🚀 階段四：整合運用與進階場景（3h）                       │
│                                                          │
│ 模組 6：多代理人協作與 MCP（1.5h）                        │
│ ├─ 6.1 MCP 協議深入（30min）                            │
│ │  學習：MCP 架構、安全與治理                           │
│ │                                                       │
│ └─ 6.2 多代理人編排實戰（60min）                        │
│    情境1：自動化週報系統（GitHub + DB + Slack + Notion） │
│    情境2：知識萃取系統（Web + Notion + 記憶卡）          │
│    學習：工作流程編排、自訂 MCP 伺服器                   │
│                                                          │
│ 模組 7：領域驅動設計（DDD）與 AI（1h）                    │
│ └─ LLM 輔助的領域建模                                   │
│    情境：為訂單系統建立 DDD 模型                        │
│    學習：事件風暴自動化、通用語言提取                    │
│                                                          │
│ 模組 8：進階資料工作流程（30min 精簡版）                  │
│ └─ 快速覽覽                                             │
│    情境1：ETL 管線自動生成                              │
│    情境2：RAG 系統快速原型                              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 🎯 階段五：實戰整合與未來展望（3h）                       │
│                                                          │
│ 模組 9：工具差異比較與選擇策略（1h）                      │
│ ├─ 三大工具深度對比矩陣                                 │
│ └─ 混合工作流程設計                                     │
│    情境：為團隊設計 AI 工具鏈                           │
│                                                          │
│ 模組 10：安全與最佳實踐（30min）                         │
│ ├─ AI 編程安全守則                                     │
│ ├─ 團隊協作規範                                        │
│ └─ 權限管理與治理                                       │
│                                                          │
│ 模組 11：綜合實戰項目★（1.5h）                           │
│ 情境：從零構建個人知識管理系統                           │
│ 整合：所有學過的技能                                    │
│ 產出：可實際使用的自動化系統                             │
│                                                          │
│ 模組 12：未來展望與持續學習（30min）                     │
│ ├─ AI 編程趨勢分析                                     │
│ ├─ 架構師角色轉變                                      │
│ └─ 個人成長路徑規劃                                     │
└─────────────────────────────────────────────────────────┘
```

---

## 📚 詳細課程內容

### 模組 0：情境驅動學習法入門（1小時）

**學習目標**：建立正確的學習心態與方法

#### 0.1 為什麼情境驅動學習更有效？（20分鐘）

**核心觀念**：
```
記憶科學證明：
1. 情境記憶 > 機械記憶（保持時間長 3-5 倍）
2. 問題解決 > 知識堆積（實用性高 10 倍）
3. 實戰演練 > 觀看示範（技能轉化率高 8 倍）
```

**Linux 學習法類比**：

| Linux 學習 | Claude Code 學習 | 共同點 |
|-----------|----------------|-------|
| 情境：找出最大檔案 | 情境：整理混亂資料夾 | 真實問題 |
| du + sort + head | 自然語言描述問題 | 自然學會工具組合 |
| 記住解決方案，不是指令 | 記住解決思路，不是指令 | 長期記憶 |

**實作練習**：
```
3 個快速情境（30 分鐘完成）：
1. 混亂的 downloads 資料夾需要整理
2. 陌生的開源專案需要快速理解
3. 生產環境突然大量錯誤

不告訴你用什麼指令，自己探索和發現
```

**學習成果**：
- ✅ 理解為什麼要用情境學習
- ✅ 體驗從問題到解決方案的過程
- ✅ 建立「探索-發現-記憶」的學習習慣

---

#### 0.2 建立個人情境題庫（20分鐘）

**概念**：就像 LeetCode 刷題，但刷的是「真實工作場景」

**情境題結構**：
```markdown
## 情境題模板

### 背景
[描述實際場景，讓人有代入感]

### 問題
[明確的任務目標，可衡量]

### 約束條件
- 時間限制：XX 分鐘
- 資源限制：只能用 Claude Code
- 品質要求：必須符合 XX 標準

### 檢查點
□ 是否達成目標 1
□ 是否達成目標 2
□ 是否達成目標 3

### 學習記錄
- 用了哪些指令/技巧
- 遇到什麼問題，如何解決
- 下次可以怎麼做得更好
```

**建立個人題庫結構**：
```
my_scenarios/
├── level-1-basic/          # 單一情境
│   ├── file-organization.md
│   ├── code-understanding.md
│   └── doc-generation.md
├── level-2-combination/    # 組合情境
│   ├── opensource-contribution.md
│   ├── emergency-debugging.md
│   └── multilang-docs.md
└── level-3-complex/        # 複雜工作流
    ├── knowledge-management.md
    ├── blog-automation.md
    └── weekly-report.md
```

---

#### 0.3 Anki 記憶卡系統建立（20分鐘）

**不是這樣做記憶卡（❌）**：
```
Q: /agents 指令的作用是什麼？
A: 管理 AI 代理人
```

**而是這樣做（✅）**：
```
Q: 【情境】你需要進行深度的安全審計，
   涉及 SQL 注入、XSS、權限控制等多個面向。

   你會怎麼做？需要用到什麼功能？

A: 【解決方案】
   1. 切換到安全專家模式
      /agents:security-auditor

   2. 執行全面掃描
      claude /security-review ./src

   3. 生成專業報告
      /output-style:security-report

   4. 記錄發現與教訓
      /memory

   【記憶點】
   需要專業分析 → 切換對應 agent
   需要特定格式 → 使用 output-style
   需要長期保存 → 用 memory
```

**記憶卡分類體系**：
```
flashcards/
├── file-operations/     # 檔案整理、批量處理
├── code-analysis/       # 程式碼理解、重構
├── emergency-response/  # 救火、快速修復
├── automation/          # 工作流程自動化
├── knowledge-work/      # 筆記、文案、研究
└── collaboration/       # 團隊協作、知識分享
```

**間隔重複計劃**：
```
Day 1:  學習新情境 → 創建記憶卡
Day 2:  複習 Day 1
Day 4:  複習 Day 1
Day 7:  複習 Day 1
Day 14: 複習 Day 1
Day 30: 複習 Day 1

間隔逐漸拉長 → 長期記憶形成
```

---

### 模組 1：AI 編程基礎認知與工具入門（2小時）

#### 1.1 AI 輔助開發現狀解析（30分鐘）

**情境題 1.1**：分析「看似正確」的程式碼

```python
# AI 生成的程式碼
def get_user_by_username(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    return db.execute(query)

# 問題：
# 1. 這段程式碼有什麼問題？
# 2. 為什麼說是「看似正確」？
# 3. 如何修復？
# 4. 如何讓 AI 避免產生這類程式碼？
```

**學習內容**：
1. **開發者信任度悖論**
   - 採用率 80%，但信任度僅 29%
   - 為什麼會有這種矛盾？

2. **AI 生成程式碼的常見病理**
   - 「看似正確」的問題（45% 開發者困擾）
   - 程式碼品質下降（Code Churn 翻倍）
   - 安全漏洞隱患（40% 含有問題）
   - 上下文理解盲點

3. **範式轉移：從生成到驗證**
   ```
   舊範式：AI 生成程式碼 → 開發者使用
   新範式：AI 生成程式碼 → 開發者驗證 → 安全使用

   關鍵：驗證能力比生成能力更重要
   ```

**實作練習**：
```
任務：審查 5 段 AI 生成的程式碼
目標：找出至少 3 個「看似正確」的問題
學習：建立批判性思維，不盲目信任 AI
```

---

#### 1.2 三大主流工具哲學對比（45分鐘）

**情境題 1.2**：工具選擇決策

```
場景 A：日常開發，需要快速補全和即時建議
場景 B：複雜重構，涉及 50+ 檔案的 API 遷移
場景 C：首次接觸大型專案，需要快速理解架構
場景 D：知識萃取，從 PDF 論文生成結構化筆記

請為每個場景選擇最適合的工具，並說明理由。
```

**工具對比矩陣**：

| 特性 | GitHub Copilot | Claude Code | Gemini CLI |
|------|---------------|-------------|------------|
| **核心哲學** | IDE 內建助手 | CLI 代理人協作 + Agent 平台 | 巨量上下文分析 |
| **上下文管理** | 隱式、即時 | 顯式、有狀態 | 一次性巨量載入 |
| **上下文大小** | ~128K tokens | ~200K tokens | 1M+ tokens |
| **長期記憶** | 儲存庫索引 | CLAUDE.md + memory 工具 | GEMINI.md + /chat save |
| **理想場景** | 日常編碼、快速補全 | 複雜重構、工作流程編排 | 全局分析、快速 onboarding |
| **學習曲線** | 低 | 中 | 中 |
| **非程式應用** | 有限 | 強（知識工作、內容創作） | 中 |

**決策樹**：
```
需要即時補全？
  ├─ 是 → Copilot
  └─ 否 → 繼續

需要理解整個程式碼庫？
  ├─ 是（一次性） → Gemini CLI
  └─ 否 → 繼續

需要複雜工作流程編排？
  ├─ 是 → Claude Code
  └─ 否 → 根據具體需求選擇
```

**實作練習**：
```
任務：為你的團隊設計混合工具鏈
考慮：
- 團隊規模
- 專案類型
- 預算限制
- 學習成本

產出：工具選擇方案 + 理由說明
```

---

#### 1.3 上下文工程第一性原理（45分鐘）

**情境題 1.3**：建立第一個專案記憶

```
情境：
你接手一個電商專案，需要建立 CLAUDE.md

已知資訊：
- 技術棧：FastAPI + PostgreSQL + Redis + Docker
- 架構：Clean Architecture
- 團隊規範：使用 Black、mypy、pytest
- 常見問題：Redis 連線池設定錯誤會導致超時

任務：設計完整的 CLAUDE.md
```

**上下文 = AI 的「心智模型」**

```
上下文的構成：
┌─────────────────────────────────────┐
│ 系統提示（固定）                     │
├─────────────────────────────────────┤
│ 對話歷史（動態，可壓縮）              │
├─────────────────────────────────────┤
│ 程式碼檔案（顯式載入）                │
├─────────────────────────────────────┤
│ 專案記憶（CLAUDE.md，持久化）        │
├─────────────────────────────────────┤
│ 工具輸出（bash、MCP 等）             │
└─────────────────────────────────────┘

總容量：~200K tokens（Claude Code）
```

**三大工具的上下文策略對比**：

**Copilot**：隱式與即時
- 自動索引當前工作區
- 開啟的分頁優先
- 開發者控制力較弱

**Claude Code**：顯式與有狀態
- 手動指定目錄（--add-dir）
- CLAUDE.md 提供長期記憶
- memory 工具跨會話持久化
- 完全掌控上下文內容

**Gemini CLI**：巨量與一次性
- 可載入整個中大型專案
- 100 萬+ tokens 視窗
- 適合初次全局理解

**CLAUDE.md 模板範例**：

```markdown
# 電商專案 - 專案記憶

## 概述
B2C 電商平台，支援商品瀏覽、購物車、結帳、支付

## 技術棧
- 語言：Python 3.10+
- 框架：FastAPI
- 資料庫：PostgreSQL 14
- 快取：Redis 7
- 容器：Docker + Docker Compose

## 架構原則
1. Clean Architecture（領域驅動設計）
2. 所有 API 必須包含 OpenAPI 文檔
3. 資料庫查詢必須使用參數化查詢（防 SQL 注入）
4. 所有錯誤記錄到集中式日誌系統

## 編碼規範
- 格式化：Black（line-length=88）
- 類型檢查：mypy（strict mode）
- 測試：pytest（coverage ≥ 80%）
- 命名：snake_case（Python）

## 專案結構
```
ecommerce/
├── src/
│   ├── domain/      # 領域層（業務邏輯）
│   ├── application/ # 應用層（用例）
│   ├── infrastructure/ # 基礎設施層
│   └── api/         # API 層（FastAPI 路由）
├── tests/
└── docker/
```

## API 契約
### 使用者認證
- 端點：POST /api/v1/auth/login
- 請求：{"username": string, "password": string}
- 回應：{"token": string, "expires_in": int}

### 商品查詢
- 端點：GET /api/v1/products
- 參數：?category=string&page=int&limit=int
- 回應：{"items": [...], "total": int, "page": int}

## 常見問題
### 問題 1：Redis 連線超時
**現象**：PaymentProcessingError: Transaction timeout
**原因**：連線池設定不當
**解決**：
```python
REDIS_POOL_SIZE = 50
REDIS_TIMEOUT = 5
```

### 問題 2：資料庫查詢慢
**現象**：API 回應時間 > 2 秒
**原因**：缺少索引
**解決**：為常用查詢欄位添加索引

## 部署資訊
- 測試環境：https://test.example.com
- 生產環境：https://api.example.com
- CI/CD：GitHub Actions
```

**實作練習**：
```
任務：為你的專案建立 CLAUDE.md
時間：30 分鐘
檢查點：
□ 包含技術棧資訊
□ 包含架構原則
□ 包含編碼規範
□ 包含至少 2 個常見問題
□ 包含 API 契約
```

---

### 模組 2：Claude Code 基礎操作（2小時）

#### 2.1 安裝與配置（30分鐘）

**情境題 2.1**：完整環境設置

```
任務：30 分鐘內完成以下設置
□ 安裝 Claude Code
□ 配置 API 金鑰
□ 驗證安裝成功
□ 完成第一個任務：整理 downloads 資料夾
□ 記錄遇到的問題和解決方案
```

**安裝步驟**：
```bash
# 方式 1：使用 npm
npm install -g @anthropic-ai/claude-code

# 方式 2：使用 pip
pip install claude-code

# 驗證安裝
claude --version

# 登入
claude /login

# 診斷（如果有問題）
claude /doctor
```

**第一個任務**：
```bash
# 啟動 Claude Code
claude

# 用自然語言描述問題
提示詞：
請整理我的 downloads 資料夾（~/Downloads）：
1. 按檔案類型分類（pdf、圖片、文檔、程式碼等）
2. 找出重複的檔案
3. 給我整理建議，等我確認後執行
```

---

#### 2.2 上下文管理與記憶系統（60分鐘）

**情境題 2.2.1**：混亂專案資料夾整理

```
背景：
project/
├── main.py
├── main_backup.py
├── main_final.py
├── test.py
├── test_old.py
├── data.csv
├── data_cleaned.csv
├── notes.txt
└── [30 個類似的混亂檔案...]

任務（20 分鐘）：
□ 分析檔案結構
□ 提出整理方案
□ 執行整理
□ 驗證結果

不需要知道任何指令，用自然語言即可
```

**解決過程**：
```bash
claude

提示詞：
請分析 ./project 資料夾並整理：

1. 先告訴我現狀分析
2. 提出整理建議（按類型、用途分類）
3. 識別重複和過時的檔案
4. 等我確認後執行

# Claude 會自動：
# - 掃描目錄
# - 分析檔案類型和命名模式
# - 提供整理方案
# - 等待確認
# - 執行整理
```

**自然學到的概念**：
- ✅ Claude 能直接操作檔案系統
- ✅ 描述問題比記指令重要
- ✅ AI 會主動規劃並等待確認

---

**情境題 2.2.2**：快速理解陌生專案

```
背景：
你剛接手一個 React 專案：
- 50 個元件
- 20 個自訂 hooks
- 15 個頁面
- 完全不熟悉

任務（30 分鐘）：
□ 理解專案架構
□ 識別核心元件
□ 了解資料流向
□ 生成 onboarding 文檔

如何用 Claude Code 實現？
```

**解決過程**：
```bash
# 步驟 1：載入專案
claude --add-dir ./react-app/src

# 步驟 2：檢查上下文使用
claude /context

# 輸出：
上下文使用情況：
├─ 程式碼檔案：85,000 tokens (42.5%)
├─ 專案記憶：0 tokens (0%)
└─ 總計：85,000 / 200,000 tokens

# 步驟 3：快速理解
提示詞：
請分析這個 React 專案：
1. 主要功能是什麼？
2. 核心元件有哪些？職責是什麼？
3. 資料流向如何？（Props/Context/Redux?）
4. 有哪些外部 API 整合？
5. 如果我要添加新頁面，應該修改哪些檔案？

生成一份 onboarding 文檔。

# 步驟 4（可選）：上下文接近上限時
claude /compact  # 壓縮上下文

# 步驟 5：保存理解
claude /memory
# 將關鍵架構資訊寫入 CLAUDE.md
```

**自然學到的指令**：
```
--add-dir  → 載入專案（就像 source 載入配置）
/context   → 檢查容量（就像 df -h 檢查硬碟）
/compact   → 壓縮上下文（就像清理快取）
/memory    → 保存知識（就像寫入 .bashrc）
```

---

#### 2.3 程式碼庫分析與重構工作流程（30分鐘）

**情境題 2.3**：API 版本遷移（v1 → v2）

```
背景：
電商 API 需要從 v1 升級到 v2
主要變更：
- 認證從 Basic Auth 改為 JWT
- 所有端點添加速率限制
- 回應格式統一為 JSON:API 規範

專案結構：
src/api/v1/
├── auth.py
├── products.py
├── orders.py
└── users.py

任務（30 分鐘）：
按 EPCV 流程完成遷移
```

**EPCV 流程（探索→規劃→編碼→驗證）**：

```bash
claude --add-dir ./src/api/v1

# ===== E - Explore（探索階段）=====
提示詞：
請分析 src/api/v1/ 目錄，找出：
1. 所有 API 端點的定義
2. 當前的認證方式
3. 回應格式模式
4. 依賴關係

不要做任何修改，只提供分析報告。

# Claude 分析完成...

# ===== P - Plan（規劃階段）=====
提示詞：
基於分析結果，制定 v1 → v2 遷移計劃：
1. 需要修改的檔案列表
2. 每個檔案的具體修改內容
3. 潛在的破壞性變更
4. 向後兼容策略
5. 測試計劃
6. 回退方案

以 Markdown 表格呈現。

# Claude 生成計劃...

# 【人工審核計劃，確認無誤】

# ===== C - Code（編碼階段）=====
提示詞：
請按照計劃執行遷移：
1. 分 3 個批次進行
2. 每個批次完成後暫停，等我確認
3. 保留 v1 端點，標記為 deprecated
4. 添加註解說明變更原因

# Claude 分批次執行...

# ===== V - Verify（驗證階段）=====
提示詞：
生成完整的測試腳本驗證遷移：
1. v2 端點功能測試
2. v1 端點向後兼容測試
3. 整合測試
4. 效能比較測試
```

**自然學到的核心概念**：
```
EPCV 流程（就像 Git workflow）：
E - Explore  → git status（了解現狀）
P - Plan     → 設計架構（規劃變更）
C - Code     → git commit（執行變更）
V - Verify   → CI/CD（驗證正確性）

關鍵：分步驟、有檢查點、可回退
```

---

### 模組 2.5：Claude Code 進階指令整合應用（2小時）

**核心理念**：Claude Code 不只是程式碼助理，更是 AI Agent 交互平台

#### 2.5.1 重新認識 Claude Code（30分鐘）

**從程式碼助理到 AI Agent 平台**

| 能力維度 | 傳統認知 | 實際能力（AI Agent 平台） |
|---------|---------|------------------------|
| 檔案操作 | 讀寫程式碼 | 批量整理、智能重命名、自動備份 |
| 終端操作 | 執行命令 | 系統管理、平行任務、自動化腳本 |
| 知識工作 | 生成文檔 | 知識萃取、筆記系統、研究助手 |
| 內容創作 | 寫註解 | 部落格文章、技術文檔、多語言內容 |
| 工具整合 | 單一 AI | 多代理人協同、MCP 伺服器、外部 API |

**情境題 2.5.1**：會議錄音轉行動項目

```
背景：
2 小時的產品規劃會議，有錄音檔 meeting.mp3

需求：
1. 轉錄為文字
2. 提取關鍵決策
3. 識別行動項目（負責人、截止日期）
4. 為每個行動項目創建 JIRA ticket
5. 發送摘要到 Slack
6. 保存完整紀錄到 Notion

傳統方式：手動處理，需 1-2 小時
AI Agent 方式：自動化，10 分鐘

如何實現？
```

**解決方案（多工具協同）**：

```bash
claude

提示詞：
請處理會議錄音 meeting.mp3：

1. 使用 speech-to-text MCP 轉錄音訊
2. 使用 meeting-analyzer agent 分析內容
3. 提取：
   - 討論議題
   - 決策事項
   - 行動項目（負責人、截止日期）
4. 使用 jira MCP 為每個行動項目創建 ticket
5. 使用 slack MCP 發送摘要到 #team-updates
6. 使用 notion MCP 保存完整紀錄

請自動編排執行所有步驟。
```

**Claude 自動執行流程**：
```
[步驟 1] 調用 speech-to-text MCP
  ✓ 轉錄完成（2 小時錄音 → 15,000 字文本）

[步驟 2] 切換到 meeting-analyzer agent
  ✓ 分析討論議題（5 個）
  ✓ 提取決策事項（8 個）
  ✓ 識別行動項目（12 個）

[步驟 3] 為每個行動項目創建 JIRA ticket
  ✓ [PROJ-234] 行動端 UI 設計（@Alice, 2025-01-22）
  ✓ [PROJ-235] API 效能優化（@Bob, 2025-01-20）
  ✓ [PROJ-236] 技術債評估（@Carol, 2025-01-18）
  ...

[步驟 4] 發送 Slack 摘要
  ✓ 已發送到 #team-updates

[步驟 5] 保存到 Notion
  ✓ 已創建頁面：https://notion.so/...

[完成] 總耗時：8 分鐘
```

**學到的核心概念**：
- MCP 讓 Claude 能連接任何外部服務
- Agents 讓 Claude 能扮演不同專家
- 一次提示可以串聯整個工作流程
- 這不是程式碼助理，是工作自動化平台

---

#### 2.5.2 `/agents` - 代理人深度應用（30分鐘）

**情境題 2.5.2**：開源專案完整貢獻流程

```
背景：
要為 FastAPI 專案貢獻新功能

傳統流程（7-8 小時）：
1. 閱讀文檔理解架構（2h）
2. 找 good first issue（30min）
3. 寫測試（1h）
4. 實作功能（2h）
5. 程式碼審查（30min）
6. 寫文檔（1h）
7. 提交 PR（30min）

AI Agent 輔助流程（2-3 小時）：
用對的 agent 做對的事，時間縮短 50-70%

如何實現？
```

**多 Agent 協同流程**：

```bash
# ===== 階段 1：理解專案（code-analyzer agent）=====
claude /agents:code-analyzer

提示詞：
請分析 FastAPI 專案架構：
- 模組結構
- 編碼規範
- 測試模式

# ===== 階段 2：找 Issue（GitHub MCP）=====
提示詞：
使用 GitHub MCP 列出 FastAPI 的 "good first issues"

# 假設選擇 Issue #456：添加請求驗證功能

# ===== 階段 3：寫測試（test-generator agent）=====
claude /agents:test-generator

提示詞：
為新功能生成測試，遵循專案現有測試風格

# ===== 階段 4：實作功能（一般模式）=====
claude /agents:off

提示詞：
實作請求驗證功能，讓測試通過

# ===== 階段 5：程式碼審查（code-reviewer agent）=====
claude /agents:code-reviewer
claude /review src/validation.py

# ===== 階段 6：安全審查（security-auditor agent）=====
claude /agents:security-auditor
claude /security-review src/validation.py

# ===== 階段 7：寫文檔（documentation-writer agent）=====
claude /agents:documentation-writer

提示詞：
為新功能生成 API 文檔，格式符合專案標準
```

**Agent 選擇記憶法（Linux 類比）**：

| 需求 | Agent | Linux 類比 |
|------|-------|-----------|
| 分析程式碼 | code-analyzer | `grep`, `find` |
| 生成測試 | test-generator | 測試框架 |
| 審查品質 | code-reviewer | `lint`, `pylint` |
| 安全掃描 | security-auditor | `nmap`, 安全工具 |
| 寫文檔 | documentation-writer | `man`, 文檔生成器 |

**關鍵記憶點**：
```
/agents:xxx 就像 sudo -u xxx
切換到不同的專家身份執行任務
```

---

#### 2.5.3 `/mcp` - 整合外部世界（30分鐘）

**情境題 2.5.3**：自動化週報系統

```
背景：
每週一需要生成開發週報

內容來源：
- GitHub（Issues、PRs、Commits）
- 資料庫（用戶數、API 調用量）
- 錯誤日誌（錯誤統計）

輸出目標：
- Slack #dev-updates 頻道
- Notion 週報資料庫

傳統方式：手動收集資料，整理，發布（1-2 小時）
AI + MCP 方式：一鍵執行（5 分鐘）
```

**MCP 配置（.claude/mcp-config.json）**：

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@github/mcp-server"],
      "env": {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}
    },
    "database": {
      "command": "npx",
      "args": ["-y", "@database/mcp-server"],
      "env": {"DB_URL": "${DATABASE_URL}"}
    },
    "slack": {
      "command": "npx",
      "args": ["-y", "@slack/mcp-server"],
      "env": {"SLACK_TOKEN": "${SLACK_TOKEN}"}
    },
    "notion": {
      "command": "npx",
      "args": ["-y", "@notionhq/mcp-server"],
      "env": {"NOTION_API_KEY": "${NOTION_API_KEY}"}
    }
  }
}
```

**執行週報生成**：

```bash
claude

提示詞：
生成本週開發週報（2025-01-13 ~ 2025-01-19）：

【資料收集】
1. GitHub 數據（github MCP）
   - 本週關閉的 Issues
   - 本週合併的 PRs
   - Commit 統計（總數、主要貢獻者）

2. 資料庫數據（database MCP）
   - 新增用戶數
   - API 調用量（總計、平均 QPS）
   - 錯誤率統計

【格式化】
3. 使用 weekly-report 輸出風格生成週報

【發布】
4. 發送到 Slack #dev-updates（slack MCP）
5. 創建 Notion 頁面（notion MCP）

請自動編排執行。
```

**Claude 自動執行**：

```
[資料收集階段]
✓ GitHub MCP：獲取 Issues、PRs、Commits
✓ Database MCP：查詢用戶、API、錯誤數據

[格式化階段]
✓ 生成週報（Markdown 格式）

[發布階段]
✓ Slack 訊息已發送
✓ Notion 頁面已創建：https://notion.so/...

[週報摘要]
- 關閉 Issues：15 個
- 合併 PRs：8 個
- 新增用戶：1,234 人
- API 調用：2.3M 次
- 錯誤率：0.05%
```

**MCP 記憶法（Linux 類比）**：

```
MCP 就像 Linux 的 mount：
將外部系統「掛載」到 Claude

github MCP    → mount GitHub API
database MCP  → mount Database
slack MCP     → mount Slack API
notion MCP    → mount Notion API

掛載後，Claude 可以直接讀寫外部系統
```

---

#### 2.5.4 `/output-style` - 控制輸出格式（30分鐘）

**情境題 2.5.4**：多語言技術文檔生成

```
背景：
開發了一個 Payment API

需要生成：
- 英文版文檔（國際用戶）
- 繁體中文版（台灣用戶）
- 日文版（日本用戶）

每個版本要求：
- 本地化範例（符合當地慣例）
- 文化適配的格式
- 統一的技術準確性

傳統方式：手寫 3 遍或找翻譯（時間長、品質不穩定）
AI + output-style：一次生成，格式統一
```

**創建自訂輸出風格**：

```yaml
# .claude/output-styles/api-doc-zh-tw.yaml
name: api-doc-zh-tw
description: 繁體中文 API 文檔標準格式

language: zh-TW
tone: professional_friendly

structure:
  - 概述
  - 快速開始
  - API 參考
  - 範例程式碼
  - 常見問題
  - 故障排除

code_style:
  comment_language: zh-TW
  variable_naming: english  # 變數仍用英文
  example_data: localized   # 範例資料本地化

template: |
  # {api_name} API 文檔

  ## 概述
  {overview}

  ## 快速開始
  ```bash
  # 安裝
  {installation}

  # 第一個請求
  {first_request}
  ```

  ## API 參考
  {api_reference}

  ## 範例程式碼
  {examples}

  ## 常見問題
  {faq}

  ## 故障排除
  {troubleshooting}

  ---
  文檔版本：{version}
  最後更新：{date}
```

**使用多種風格生成文檔**：

```bash
# 生成英文版
claude /output-style:api-doc-en

提示詞：
為 Payment API 生成英文文檔

# 生成繁中版
claude /output-style:api-doc-zh-tw

提示詞：
為 Payment API 生成繁體中文文檔

# 生成日文版
claude /output-style:api-doc-ja

提示詞：
為 Payment API 生成日文文檔
```

**output-style 記憶法（Linux 類比）**：

```
output-style 就像 LaTeX 的 template：
定義輸出的結構和格式，確保一致性

api-doc-en     → English technical style
api-doc-zh-tw  → 繁中技術風格
blog-article   → 部落格文章風格
incident-report → 事件報告風格
meeting-notes  → 會議紀錄風格
```

---

### 模組 3-12：後續模組概覽

**（詳細內容請參考原大綱文件）**

由於篇幅限制，模組 3-12 的詳細內容已在以下文件中：

- **模組 3**：IDE 整合 → 參考「模組3_IDE整合」章節
- **模組 4**：TDD/BDD → 參考完整大綱
- **模組 5**：CI/CD → 參考「模組5_CI_CD自動化_詳細教材.md」
- **模組 6-12**：參考各模組詳細教材

---

## 🎯 情境題庫總覽

### Level 1：單一情境（基礎）

| 情境編號 | 情境名稱 | 時長 | 核心學習 |
|---------|---------|------|---------|
| 1.1 | 混亂資料夾整理 | 30min | 基本交互 |
| 1.2 | 快速理解新專案 | 45min | 上下文管理 |
| 1.3 | 生成專案文檔 | 30min | output-style |
| 1.4 | 批量檔案操作 | 30min | bash 整合 |
| 1.5 | 程式碼註解增強 | 30min | 程式碼理解 |

### Level 2：組合情境（進階）

| 情境編號 | 情境名稱 | 時長 | 核心學習 |
|---------|---------|------|---------|
| 2.1 | 開源貢獻完整流程 | 2.5h | agent 協同 |
| 2.2 | 生產環境緊急救火 | 1h | 壓力測試 |
| 2.3 | 多語言文檔生成 | 1h | 進階 output-style |
| 2.4 | 自動化週報系統 | 1.5h | MCP 整合 |
| 2.5 | 會議紀錄處理 | 1h | 多模態工作流 |

### Level 3：複雜情境（專家）

| 情境編號 | 情境名稱 | 時長 | 核心學習 |
|---------|---------|------|---------|
| 3.1 | 個人知識管理系統 | 1週 | 完整工作流編排 |
| 3.2 | 技術部落格自動化 | 3天 | 內容創作流程 |
| 3.3 | 團隊 AI 工具鏈設計 | 1週 | 企業級整合 |

---

## 📊 學習進度計劃

### 三週學習計劃

**第 1 週：基礎情境掌握**

| 天 | 學習內容 | 時長 | 檢查點 |
|----|---------|------|-------|
| Mon | 模組 0 + 模組 1 | 3h | 理解學習方法、完成第一個情境 |
| Tue | 模組 2.1-2.2 | 2h | 掌握基本操作和上下文管理 |
| Wed | 模組 2.3 | 1.5h | 完成 API 重構情境 |
| Thu | 模組 2.5.1-2.5.2 | 2h | 理解 Agent 概念 |
| Fri | 模組 2.5.3-2.5.4 | 2h | 掌握 MCP 和 output-style |
| Sat | 情境練習 | 2h | Level 1 情境題 3 題 |
| Sun | 複習與建立記憶卡 | 1.5h | 建立 Anki 卡片庫 |

**第 2 週：組合情境實戰**

| 天 | 學習內容 | 時長 | 檢查點 |
|----|---------|------|-------|
| Mon | 模組 3 | 1.5h | IDE 工具對比 |
| Tue | 模組 4.1 | 1.5h | TDD 流程 |
| Wed | 模組 4.2 | 1.5h | BDD 實戰 |
| Thu | 模組 5 | 2h | CI/CD 管線 |
| Fri | 情境 2.1 | 2.5h | 開源貢獻完整流程 |
| Sat | 情境 2.2-2.4 | 3h | Level 2 情境題 |
| Sun | 複習與優化 | 2h | 更新記憶卡、總結經驗 |

**第 3 週：複雜情境與專案**

| 天 | 學習內容 | 時長 | 檢查點 |
|----|---------|------|-------|
| Mon | 模組 6 | 2h | 多代理人協作 |
| Tue | 模組 7-8 | 1.5h | DDD 與資料工作流 |
| Wed | 模組 9-10 | 1.5h | 工具比較與最佳實踐 |
| Thu-Sat | 模組 11 | 6h | 綜合實戰項目 |
| Sun | 模組 12 + 總結 | 2h | 未來規劃、課程回顧 |

---

## 📝 評量方式

### 不是這樣考（❌）

```
Q1: /agents 指令的作用是什麼？
Q2: 列出 5 個 Claude Code 指令
Q3: MCP 的全稱是什麼？
```

### 而是這樣考（✅）

**情境評量範例**：

```
【情境】團隊需要建立自動化程式碼審查流程

要求：
1. 所有 PR 必須經過安全掃描
2. 程式碼風格必須符合團隊規範
3. 必須有 80% 測試覆蓋率
4. 生成詳細審查報告
5. 自動發送到 Slack

任務（2 小時）：
□ 設計完整工作流程
□ 配置必要的 agents 和 MCP
□ 實作並測試
□ 撰寫使用文檔

評分標準：
- 流程設計完整性（30%）
- 技術實作正確性（30%）
- 自動化程度（20%）
- 文檔品質（20%）
```

---

## 🎓 結業標準

完成本課程，學員應達到：

**基本能力**（必須）：
- □ 能用自然語言描述問題讓 Claude 理解
- □ 掌握上下文管理（/context, /compact, /memory）
- □ 能完成 Level 1-2 情境題
- □ 理解三大工具的選擇策略
- □ 能設計簡單的自動化工作流程

**進階能力**（推薦）：
- □ 能配置和使用多個 MCP 伺服器
- □ 能創建自訂 agent 和 output-style
- □ 能完成 Level 3 情境題
- □ 能為團隊設計 AI 工具鏈
- □ 有自己的情境題庫和記憶卡系統

**專家能力**（卓越）：
- □ 能設計企業級 AI 工作流程
- □ 能訓練他人使用 Claude Code
- □ 有貢獻開源專案的經驗
- □ 能在非程式設計領域應用 AI
- □ 持續探索新的應用場景

---

## 📚 課程資源

### 必備工具

- **Claude Code**：https://claude.ai/code
- **GitHub Copilot**：https://github.com/features/copilot
- **Gemini CLI**：https://cloud.google.com/gemini

### 推薦學習資源

- **官方文檔**：Claude Code、Copilot、Gemini 官方文檔
- **情境題庫**：課程配套情境題庫（300+ 題）
- **Anki 卡片庫**：課程官方記憶卡（500+ 卡）
- **社群論壇**：學員交流與問題解答
- **範例專案庫**：10+ 完整範例專案

---

## 💡 學習訣竅

### 三大學習原則

1. **情境第一，指令第二**
   - 不要背「/agents 是什麼」
   - 而要記「需要專家時用 /agents」

2. **問題驅動學習**
   - 遇到問題 → 查文檔 → 解決 → 記錄
   - 不要「預習所有指令」

3. **建立個人知識庫**
   - 用 /memory 記錄每次的解決方案
   - 用 Anki 建立間隔重複系統
   - 持續累積個人情境題庫

### Linux 學習法類比總表

| Linux 概念 | Claude Code 概念 | 記憶連結 |
|-----------|----------------|---------|
| `man` 命令 | `/help` | 查手冊 |
| 管道 `\|` | 工作流程編排 | 串聯處理 |
| 別名 `alias` | 自訂 `/command` | 快捷方式 |
| `.bashrc` | `CLAUDE.md` | 持久化設定 |
| 環境變數 | `/memory` | 保存狀態 |
| `cron` | 自動化工作流程 | 定時任務 |
| `sudo` | `/agents` | 切換權限/角色 |
| `mount` | `/mcp` | 掛載外部系統 |
| `df -h` | `/context` | 檢查容量 |
| 清理快取 | `/compact` | 釋放空間 |

---

## 🚀 開始學習

### 第一步：環境設置

```bash
# 1. 安裝 Claude Code
npm install -g @anthropic-ai/claude-code

# 2. 驗證安裝
claude --version

# 3. 登入
claude /login

# 4. 診斷
claude /doctor
```

### 第二步：完成第一個情境

```bash
# 啟動 Claude Code
claude

# 嘗試第一個情境：整理 downloads 資料夾
提示詞：
請幫我整理 ~/Downloads 資料夾：
1. 按檔案類型分類
2. 找出重複檔案
3. 給我建議，等我確認後執行
```

### 第三步：建立學習系統

```
1. 創建情境題庫資料夾
2. 安裝 Anki（記憶卡軟體）
3. 創建學習日誌
4. 加入學習社群
```

---

**準備好開始你的 AI 編程之旅了嗎？**

記住：
> 不要試圖記住所有指令，
> 而要學會在遇到問題時，如何思考和探索解決方案。
> 就像學 Linux 一樣！

---

**課程版本**：v2.0
**最後更新**：2025 年 1 月
**維護者**：AI 編程課程開發團隊
**聯絡方式**：[待補充]

---

*本課程採用情境驅動學習法，基於認知科學與 Linux 高手養成法設計。*
