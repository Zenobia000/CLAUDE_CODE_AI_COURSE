# 2.2 上下文管理與記憶系統

## 學習目標

完成本章後,你將能夠:
- 深刻理解上下文視窗的本質與限制
- 掌握顯式上下文管理技巧(--add-dir, /context, /compact)
- 設計高效的專案記憶結構(CLAUDE.md)
- 使用 /memory 工具實現跨會話知識保存
- 在實戰中自然記憶關鍵指令組合

**預計時間**: 60-90 分鐘
**核心權重**: 本模組最重要章節(佔 40%)

---

## 情境引入:上下文容量的真實挑戰

### 情境 2.2.1:200K Tokens 能裝多少?

**實際測試場景**:
```bash
# 一個中型 React 專案
react-ecommerce/
├── src/
│   ├── components/ (50 個元件, 約 25,000 行)
│   ├── pages/ (15 個頁面, 約 8,000 行)
│   ├── hooks/ (20 個自訂 hooks, 約 3,000 行)
│   ├── utils/ (30 個工具函數, 約 5,000 行)
│   └── api/ (API 客戶端, 約 2,000 行)
├── tests/ (測試檔案, 約 15,000 行)
└── docs/ (文檔, 約 5,000 行)

總計: 約 63,000 行程式碼
```

**Token 容量計算**:
```
1 行程式碼 ≈ 15-30 tokens (平均 20 tokens)
63,000 行 × 20 tokens = 1,260,000 tokens

問題: Claude Code 上下文視窗只有 200K tokens!
```

**現實挑戰**:
- 不可能一次載入整個專案
- 必須策略性選擇載入內容
- 需要動態管理上下文

---

## 第一部分:上下文視窗深度解析

### 上下文視窗的組成

```
┌─────────────────────────────────────────────┐
│ Claude Code 上下文視窗 (~200K tokens)         │
├─────────────────────────────────────────────┤
│ 1. 系統提示 (5-10K tokens, 固定)             │
│    - Claude 的角色定義                       │
│    - 工具使用說明                            │
│    - 安全規則                               │
├─────────────────────────────────────────────┤
│ 2. 專案記憶 (CLAUDE.md) (5-20K tokens)      │
│    - 技術棧                                 │
│    - 架構原則                               │
│    - API 契約                               │
│    - 常見問題                               │
├─────────────────────────────────────────────┤
│ 3. 程式碼檔案 (可變, 50-150K tokens)         │
│    - --add-dir 指定的目錄                   │
│    - 相關檔案自動載入                        │
├─────────────────────────────────────────────┤
│ 4. 對話歷史 (可變, 20-50K tokens)            │
│    - 最近的對話                             │
│    - 已執行的命令                            │
│    - 工具輸出                               │
├─────────────────────────────────────────────┤
│ 5. 當前任務 (5-10K tokens)                   │
│    - 使用者最新的提示詞                      │
│    - 待執行的計劃                            │
└─────────────────────────────────────────────┘

總計: 85K - 240K tokens
接近或超過上限!需要管理!
```

### Token 計算實務

**Python 程式碼範例**:
```python
# 50 行的函數
def process_order(order_id: str, user_id: str) -> OrderResult:
    """
    處理訂單

    Args:
        order_id: 訂單 ID
        user_id: 使用者 ID

    Returns:
        OrderResult: 處理結果

    Raises:
        OrderNotFoundError: 訂單不存在
        InsufficientStockError: 庫存不足
    """
    # 1. 查詢訂單
    order = Order.get_by_id(order_id)
    if not order:
        raise OrderNotFoundError(f"Order {order_id} not found")

    # 2. 驗證權限
    if order.user_id != user_id:
        raise PermissionError("Not authorized")

    # 3. 檢查庫存
    for item in order.items:
        product = Product.get_by_id(item.product_id)
        if product.stock < item.quantity:
            raise InsufficientStockError(
                f"Product {product.name} insufficient stock"
            )

    # 4. 扣除庫存
    for item in order.items:
        product = Product.get_by_id(item.product_id)
        product.stock -= item.quantity
        product.save()

    # 5. 更新訂單狀態
    order.status = OrderStatus.PROCESSING
    order.save()

    # 6. 發送通知
    notify_user(user_id, f"Order {order_id} is processing")

    return OrderResult(
        success=True,
        order_id=order_id,
        message="Order processed successfully"
    )

# Token 估算:
# - 註解(中文): ~50 tokens
# - 程式碼: ~800 tokens
# - 總計: ~850 tokens
#
# 結論: 50 行程式碼 ≈ 850 tokens (平均 17 tokens/行)
```

**文檔範例**:
```markdown
# API 文檔

## 使用者認證

### POST /api/v1/auth/login

登入 API

**請求**:
- URL: `/api/v1/auth/login`
- Method: `POST`
- Headers: `Content-Type: application/json`
- Body:
  ```json
  {
    "username": "string",
    "password": "string"
  }
  ```

**回應**:
- Status: `200 OK`
- Body:
  ```json
  {
    "token": "string",
    "expires_in": 3600,
    "user": {
      "id": "string",
      "username": "string",
      "email": "string"
    }
  }
  ```

**錯誤**:
- `400 Bad Request`: 參數錯誤
- `401 Unauthorized`: 認證失敗
- `500 Internal Server Error`: 伺服器錯誤

# Token 估算:
# - 標題和描述: ~50 tokens
# - JSON 範例: ~200 tokens
# - 錯誤說明: ~100 tokens
# - 總計: ~350 tokens
#
# 結論: 一個 API 端點文檔 ≈ 300-500 tokens
```

**Token 預算規劃**:
```
假設 200K tokens 上下文:

保留給系統: 10K tokens
保留給 CLAUDE.md: 15K tokens
保留給對話歷史: 30K tokens
保留給當前任務: 10K tokens

可用於程式碼檔案: 135K tokens

135K tokens = 多少程式碼?
- Python: 約 6,000-8,000 行
- JavaScript: 約 5,000-7,000 行
- 含註解的程式碼: 約 4,000-6,000 行

結論: 可以載入中小型專案的核心部分
```

---

## 第二部分:顯式上下文管理

### --add-dir: 選擇性載入目錄

**基本用法**:
```bash
# 載入單一目錄
claude --add-dir ./src/api

# 載入多個目錄
claude --add-dir ./src/api --add-dir ./src/models

# 載入整個 src 目錄
claude --add-dir ./src
```

**策略 1: 分層載入**

```bash
# 場景: 需要重構 API 層
#
# 專案結構:
# src/
# ├── api/        ← 主要工作區
# ├── models/     ← 需要理解
# ├── services/   ← 需要理解
# ├── utils/      ← 不需要
# └── tests/      ← 不需要

# 只載入必要的部分
claude --add-dir ./src/api \
       --add-dir ./src/models \
       --add-dir ./src/services

提示詞:
請分析 API 層的結構,規劃從 v1 到 v2 的遷移方案
```

**策略 2: 漸進式載入**

```bash
# 第 1 階段: 理解架構(高層級)
claude --add-dir ./src/api

提示詞:
請分析 API 目錄結構,列出:
1. 有哪些模組?
2. 主要功能是什麼?
3. 依賴關係如何?

# Claude 回應後,你理解了架構

# 第 2 階段: 深入特定模組
claude --add-dir ./src/api/auth \
       --add-dir ./src/models/user.py

提示詞:
請詳細分析認證模組,規劃如何添加 OAuth2 支援

# 聚焦在特定功能,上下文更集中
```

**策略 3: 排除無關檔案**

```bash
# 使用 .claudeignore 檔案(類似 .gitignore)
cat > .claudeignore << 'EOF'
# 不載入測試檔案
tests/
**/*_test.py
**/*.test.js

# 不載入生成的檔案
dist/
build/
*.min.js

# 不載入大型資料檔案
*.csv
*.json
data/

# 不載入文檔
docs/
*.md
EOF

# 然後載入整個 src 目錄,但排除無關檔案
claude --add-dir ./src
```

### /context: 監控上下文使用

**基本用法**:
```bash
claude /context

# 輸出:
Context Usage:
├─ Total: 87,234 / 200,000 tokens (43.6%)
├─ System Prompt: 8,543 tokens (4.3%)
├─ Project Memory (CLAUDE.md): 12,456 tokens (6.2%)
├─ Code Files: 52,678 tokens (26.3%)
│  ├─ src/api/auth.py: 3,245 tokens
│  ├─ src/api/orders.py: 4,567 tokens
│  ├─ src/models/user.py: 2,134 tokens
│  └─ [23 more files...]
├─ Conversation History: 11,234 tokens (5.6%)
└─ Current Task: 2,323 tokens (1.2%)

Recommendations:
✓ Context usage healthy
- Consider using /compact if approaching 80%
```

**實戰場景**:
```bash
# 情境: 逐步載入專案,監控容量

# Step 1: 載入 API 目錄
claude --add-dir ./src/api

claude /context
# Output: 52K / 200K (26%)

提示詞: 分析 API 結構

# Step 2: 再載入 models
claude --add-dir ./src/models

claude /context
# Output: 89K / 200K (44.5%)

# Step 3: 再載入 services
claude --add-dir ./src/services

claude /context
# Output: 156K / 200K (78%)
# ⚠️ Warning: Approaching context limit!

# 決策: 是否需要 /compact?
```

### /compact: 壓縮對話歷史

**工作原理**:
```
/compact 會:
1. 保留關鍵資訊(決策、計劃、重要發現)
2. 刪除冗餘內容(重複的命令輸出、臨時討論)
3. 將長對話總結為摘要
4. 保留程式碼檔案(不壓縮)
5. 保留 CLAUDE.md(不壓縮)

結果: 對話歷史從 50K tokens → 10K tokens
```

**使用時機**:
```bash
# 1. 上下文接近上限(>75%)
claude /context
# Output: 168K / 200K (84%)

claude /compact
# Output: Context compacted: 168K → 128K tokens

# 2. 長時間對話後
# 已進行 2 小時的對話,對話歷史累積很多

claude /compact
# 定期清理,保持上下文乾淨

# 3. 切換任務前
# 完成 API 重構,現在要做資料庫優化

claude /compact
提示詞:
前面的任務已完成,現在開始新任務:資料庫查詢優化
```

**壓縮前後對比**:
```
【壓縮前】(50K tokens)
User: 請分析 auth.py
Claude: [3000 字的詳細分析]
User: 很好,現在分析 orders.py
Claude: [3000 字的詳細分析]
User: 這兩個模組的共同問題是什麼?
Claude: [2000 字的對比分析]
User: 給我重構計劃
Claude: [4000 字的詳細計劃]
User: 執行第一步
Claude: [命令輸出 2000 行]
...

【壓縮後】(10K tokens)
Summary:
- Analyzed auth.py and orders.py
- Identified common issues:
  * Inconsistent error handling
  * Lack of input validation
  * No logging
- Created refactoring plan (5 phases)
- Completed phase 1: Added input validation
- Current status: Ready for phase 2

Key Decisions:
- Use Pydantic for validation
- Implement centralized error handler
- Add structured logging

Next Steps:
- Phase 2: Implement error handling
- Phase 3: Add logging
...
```

---

## 第三部分:專案記憶設計(CLAUDE.md 深度)

### CLAUDE.md 的三層結構

#### 第一層:靜態知識(很少變)

```markdown
# 專案名稱

## 技術棧
- 語言: Python 3.11
- 框架: FastAPI 0.104
- 資料庫: PostgreSQL 14
- 快取: Redis 7

## 架構原則
1. Clean Architecture
2. API-First
3. Security by Default
4. Test Coverage ≥ 80%

## 目錄結構
[目錄樹]

## 編碼規範
[程式碼風格、命名規則]
```

**特點**: 專案初期建立,幾乎不變

#### 第二層:半動態知識(偶爾變)

```markdown
## API 契約
### 使用者認證
**端點**: POST /api/v1/auth/login
[詳細規格]

### 商品查詢
**端點**: GET /api/v1/products
[詳細規格]

## 資料模型
### User
[Schema 定義]

### Product
[Schema 定義]

## 常見問題
### Redis 連線超時
[問題描述、原因、解決方案]

### 資料庫查詢慢
[問題描述、原因、解決方案]
```

**特點**: 隨專案發展逐步擴充

#### 第三層:動態知識(經常變)

```markdown
## 近期變更
### 2025-01-15: 新增 OAuth2 支援
- 已實作 Google、GitHub 登入
- 端點: /api/v1/auth/oauth/{provider}
- 注意: 需要配置環境變數 GOOGLE_CLIENT_ID

### 2025-01-10: 資料庫索引優化
- 為 orders.created_at 添加索引
- 查詢速度提升 10 倍
- 注意: 執行遷移後才生效

## 當前任務
- [ ] 實作支付整合(Stripe)
- [x] 新增 OAuth2 認證
- [ ] 優化商品搜尋(Elasticsearch)

## 已知問題
- Issue #234: Redis 在高負載時偶爾超時
  * 臨時方案: 增加重試機制
  * 長期方案: 升級到 Redis Cluster
```

**特點**: 頻繁更新,記錄最新狀態

### CLAUDE.md 模板集

#### 模板 1: Web 應用專案

```markdown
# [專案名稱] - Web Application

## 概述
[一句話描述]

## 技術棧
### 後端
- 語言: [Python/Node.js/Go]
- 框架: [FastAPI/Express/Gin]
- 資料庫: [PostgreSQL/MySQL/MongoDB]
- 快取: [Redis/Memcached]

### 前端
- 框架: [React/Vue/Angular]
- 語言: [TypeScript]
- 狀態管理: [Redux/Zustand/Pinia]
- UI 庫: [Ant Design/Material-UI/Tailwind]

### 基礎設施
- 容器: Docker + Kubernetes
- CI/CD: GitHub Actions
- 雲端: AWS/GCP/Azure

## 架構
[架構圖或描述]

## API 契約
[OpenAPI/Swagger 連結或重要端點列表]

## 資料模型
[ER 圖或關鍵實體說明]

## 開發流程
1. 分支策略: [Git Flow/GitHub Flow]
2. 提交規範: [Conventional Commits]
3. Code Review: [規則]
4. 部署流程: [步驟]

## 編碼規範
[語言特定規範]

## 測試策略
- 單元測試: [工具、覆蓋率要求]
- 整合測試: [範圍]
- E2E 測試: [工具、關鍵路徑]

## 常見問題
[FAQ]

## 部署資訊
- 開發: [URL]
- 測試: [URL]
- 生產: [URL]

## 監控與告警
[監控工具、關鍵指標]

---
最後更新: [日期]
維護者: [團隊]
```

#### 模板 2: 資料科學專案

```markdown
# [專案名稱] - Data Science Project

## 專案目標
[商業目標、成功指標]

## 資料來源
- 來源 1: [描述、更新頻率、資料量]
- 來源 2: [描述、更新頻率、資料量]

## 資料 Schema
[關鍵欄位、資料類型、範圍]

## 技術棧
- 語言: Python 3.11
- 資料處理: Pandas, Polars
- 機器學習: scikit-learn, XGBoost
- 深度學習: PyTorch, TensorFlow
- 實驗追蹤: MLflow, Weights & Biases

## 專案結構
```
project/
├── data/          # 資料(不納入版本控制)
├── notebooks/     # Jupyter notebooks
├── src/           # 原始碼
│   ├── data/      # 資料處理
│   ├── features/  # 特徵工程
│   ├── models/    # 模型定義
│   └── utils/     # 工具函數
├── tests/         # 測試
└── experiments/   # 實驗記錄
```

## 資料處理流程
1. 資料擷取: [來源 → 原始資料]
2. 資料清理: [處理缺失值、異常值]
3. 特徵工程: [衍生特徵、轉換]
4. 訓練/測試分割: [比例、策略]

## 模型清單
| 模型 | 演算法 | 效能 | 狀態 |
|------|--------|------|------|
| baseline | Linear Regression | RMSE: 0.45 | 已部署 |
| v2 | XGBoost | RMSE: 0.32 | 測試中 |

## 評估指標
- 主要指標: [RMSE/AUC/F1/等]
- 次要指標: [...]

## 實驗記錄
[重要實驗、發現、教訓]

## 部署
- 模型格式: [ONNX/TorchScript/SavedModel]
- 推論服務: [FastAPI/TorchServe/TFServing]
- 監控: [模型漂移檢測、效能監控]

---
最後更新: [日期]
資料科學家: [名字]
```

#### 模板 3: 開源函式庫

```markdown
# [函式庫名稱]

## 簡介
[一句話描述功能]

## 安裝
```bash
pip install [package]
```

## 快速開始
```python
[最簡單的使用範例]
```

## API 文檔
[核心 API 說明]

## 架構
[函式庫架構、設計模式]

## 開發指南
### 環境設置
```bash
git clone ...
cd ...
pip install -e .[dev]
```

### 執行測試
```bash
pytest
```

### 程式碼風格
- Black (格式化)
- mypy (類型檢查)
- ruff (linting)

## 貢獻指南
1. Fork 專案
2. 創建分支
3. 提交 PR
4. [詳細規則]

## 版本歷史
[Changelog]

## License
[授權條款]

---
維護者: [GitHub 使用者名稱]
```

---

## 第四部分:/memory 跨會話知識管理

### /memory 的工作原理

```
/memory 指令:
1. 提取當前對話的關鍵資訊
2. 識別值得長期保存的知識
3. 建議更新 CLAUDE.md
4. 可選: 自動寫入 CLAUDE.md

記憶類型:
- 事實知識: API 端點、資料 schema
- 經驗知識: 解決過的問題、陷阱
- 決策知識: 架構決策、取捨原因
```

### 實戰場景

**場景 1: 記錄新發現的問題**

```bash
# 對話過程
User: Redis 連線為什麼一直超時?

Claude: [分析問題,執行診斷]
發現原因: 連線池設定太小(預設 10),高負載時不夠用

User: 如何解決?

Claude:
建議增加連線池大小:
```python
REDIS_POOL_SIZE = 50
REDIS_TIMEOUT = 5
```

User: 已解決!請記住這個問題

Claude /memory

# Claude 建議更新 CLAUDE.md:
---
建議添加到 CLAUDE.md「常見問題」章節:

### Redis 連線超時
**現象**: `ConnectionError: Timeout`
**原因**: 預設連線池(10)在高負載時不足
**解決**:
```python
# config.py
REDIS_POOL_SIZE = 50  # 從 10 增加到 50
REDIS_TIMEOUT = 5     # 設定超時
REDIS_RETRY = 3       # 重試次數
```
**驗證**:
```bash
# 檢查連線池狀態
redis-cli info clients
```
---

是否寫入 CLAUDE.md? (yes/no)
```

**場景 2: 記錄架構決策**

```bash
# 對話過程
User: 我們應該用 Redis 還是 Memcached 做快取?

Claude: [詳細對比分析]

Redis 優勢:
- 支援更多資料結構(List, Set, Hash)
- 支援持久化
- 支援 Pub/Sub

Memcached 優勢:
- 更簡單
- 多執行緒效能略好

建議: 選擇 Redis
原因:
1. 需要複雜資料結構(會話資料、排行榜)
2. 需要持久化避免冷啟動
3. 團隊更熟悉 Redis

User: 決定用 Redis,請記錄這個決策

Claude /memory

# Claude 建議更新:
---
建議添加到 CLAUDE.md「架構決策」章節:

## 快取方案選擇
**決策**: 使用 Redis
**時間**: 2025-01-15
**原因**:
1. 需要複雜資料結構
   - 使用者會話(Hash)
   - 排行榜(Sorted Set)
   - 訊息佇列(List)
2. 需要持久化避免冷啟動
3. 團隊熟悉度高
4. 社群支援完善

**取捨**:
- 放棄了 Memcached 的多執行緒優勢
- 但獲得了更豐富的功能

**備註**:
- 使用 Redis 7+ (支援多執行緒 I/O)
- 使用 Redis Cluster (水平擴展)
---

是否寫入? (yes/no)
```

### /memory 最佳實踐

1. **定期觸發** - 解決重要問題後立即使用
2. **選擇性記憶** - 不是所有對話都需要記錄
3. **結構化保存** - 按 CLAUDE.md 的章節組織
4. **團隊共享** - 提交到 Git,讓團隊受益

---

## 第五部分:實戰情境

### 情境 2.2.A:混亂專案資料夾整理

**背景**:
```bash
project/
├── main.py
├── main_backup.py
├── main_backup_2.py
├── main_final.py
├── main_final_v2.py
├── test.py
├── test_old.py
├── utils.py
├── util.py  # 拼字錯誤
├── data.csv
├── data_cleaned.csv
├── notes.txt
├── TODO.txt
└── [50 個類似的混亂檔案...]
```

**任務** (20 分鐘):
1. 分析現狀
2. 識別重複和過時檔案
3. 提出整理方案
4. 執行整理
5. 驗證結果

**解決過程**:

```bash
# Step 1: 啟動 Claude Code
claude

# Step 2: 描述問題
提示詞:
請分析當前目錄(./project),找出:
1. 檔案總數和類型分布
2. 重複檔案(按內容,不是檔名)
3. 命名問題(backup, old, final 等)
4. 建議的整理方案

不要執行任何操作,只提供分析報告

# Claude 執行分析...

# Step 3: 檢視上下文使用
/context
# Output: 12K / 200K (6%)
# ✓ 容量充足

# Step 4: 確認執行
User: 請執行整理方案

# Step 5: 儲存經驗
User: 整理完成,請記錄這個經驗到 CLAUDE.md

/memory
```

**自然學到的指令**:
- `claude` - 啟動(就像 `cd`)
- `/context` - 檢查容量(就像 `df -h`)
- `/memory` - 保存知識(就像寫 `.bashrc`)

---

### 情境 2.2.B:快速理解陌生專案

**背景**:
接手一個 React 專案:50 元件、20 hooks、15 頁面,完全陌生。

**任務** (30 分鐘):
1. 理解專案架構
2. 識別核心元件
3. 理解資料流
4. 生成 onboarding 文檔

**解決過程**:

```bash
# Step 1: 漸進式載入
claude --add-dir ./src

# Step 2: 檢查容量
/context
# Output: 89K / 200K (44.5%)

# Step 3: 高層級分析
提示詞:
請分析專案結構:
1. 主要功能模組
2. 核心元件(按重要性排序前 10)
3. 資料流(Props/Context/Redux?)
4. 外部 API 整合

# Claude 回應...

# Step 4: 深入關鍵模組
User: 請詳細分析 src/components/Dashboard

# Step 5: 生成文檔
User: 基於分析,生成 ONBOARDING.md

# Step 6: 保存到 CLAUDE.md
/memory
```

**自然學到的指令**:
- `--add-dir` - 載入目錄(就像 `source`)
- `/context` - 監控容量
- `/memory` - 持久化知識

---

## 總結

### 核心要點

**上下文管理三原則**:
1. **選擇性載入** - 只載入需要的(--add-dir)
2. **持續監控** - 定期檢查容量(/context)
3. **主動壓縮** - 接近上限時清理(/compact)

**記憶系統三層次**:
1. **CLAUDE.md** - 持久化專案知識
2. **/memory** - 跨會話經驗保存
3. **對話歷史** - 會話內的短期記憶

**Linux 類比記憶法**:
```bash
--add-dir    = source config      # 載入配置
/context     = df -h              # 檢查容量
/compact     = 清理快取            # 釋放空間
/memory      = 寫入 ~/.bashrc     # 持久化設定
CLAUDE.md    = /etc/config        # 系統配置檔
```

### 下一步

現在你已經掌握上下文管理,接下來學習:
- **2.3 程式碼庫分析與重構** - 大規模程式碼操作
- **2.4 EPCV 工作流程** - 系統化開發流程

---

**下一章**: [2.3 程式碼庫分析與重構](./2.3_程式碼庫分析與重構.md)
