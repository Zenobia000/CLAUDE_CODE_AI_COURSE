# 2.4 EPCV 工作流程深度解析

## 學習目標

完成本章後,你將能夠:
- 理解並應用 EPCV(Explore-Plan-Code-Verify)開發框架
- 在每個階段選擇正確的 Claude Code 指令組合
- 將驗證前置(Validation-First)融入開發流程
- 完成從需求到部署的完整開發週期
- 建立可重複的高品質開發流程

**預計時間**: 60-90 分鐘
**實戰權重**: 極高(50% 實務操作)

---

## 情境引入:混亂開發 vs 系統化開發

### 情境 2.4.1:傳統開發的混亂

**真實場景:新增「忘記密碼」功能**

```
傳統開發流程(無章法):

8:00  - PM: "加個忘記密碼功能"
8:05  - 你: "好" (沒問需求細節)
8:10  - 開始寫程式碼(直接動手)
9:30  - 寫完了,覺得不錯
9:35  - 測試... 發現 bug
10:00 - 修 bug... 發現更多 bug
11:00 - 又修... 發現架構有問題
12:00 - 重寫一半
14:00 - 終於能跑了
14:30 - Code Review: "這跟現有 API 風格不一致"
15:00 - 😭 再重寫
17:00 - 終於改好了
17:30 - QA: "沒有速率限制,可以暴力破解"
18:00 - 又要改...

耗時: 10 小時
品質: 不穩定
壓力: 爆表
```

**EPCV 開發流程(系統化)**

```
EPCV 流程:

【E - Explore 探索】 (30 分鐘)
- 理解需求:忘記密碼要做什麼?
- 分析現有程式碼:認證系統如何運作?
- 識別依賴:需要用到哪些模組?
- 找出參考:其他專案怎麼做?

【P - Plan 規劃】 (30 分鐘)
- 設計 API 契約
- 規劃資料庫變更
- 設計安全機制(速率限制、token 過期)
- 制定測試計劃
- Code Review:規劃階段就審查設計

【C - Code 編碼】 (2 小時)
- 先寫測試(TDD)
- 實作功能
- 邊寫邊驗證
- 持續整合

【V - Verify 驗證】 (30 分鐘)
- 單元測試
- 整合測試
- 安全掃描
- 效能測試
- 最終 Code Review

總耗時: 3.5 小時
品質: 穩定可靠
壓力: 可控
```

**差異對比**:

| 維度 | 傳統方法 | EPCV 方法 |
|------|---------|----------|
| 開發時間 | 10 小時 | 3.5 小時 |
| Bug 數量 | 15+ | 2-3 |
| 重工次數 | 3 次 | 0 次 |
| Code Review 通過 | 第 2 輪 | 第 1 輪 |
| 安全問題 | 發現 5 個 | 發現 0 個 |
| 壓力指數 | 😭😭😭 | 😊 |

---

## 第一部分:EPCV 框架詳解

### E - Explore (探索階段)

**目標**: 完整理解問題與上下文

**核心問題**:
```
1. 要解決什麼問題?
2. 現有系統如何運作?
3. 有哪些約束條件?
4. 相關的程式碼在哪裡?
5. 有沒有類似的實作可以參考?
```

**使用的指令組合**:

```bash
# 1. 理解專案結構
/glob src/**/*.py                # 找出所有程式碼檔案
/read CLAUDE.md                  # 讀取專案記憶

# 2. 找出相關程式碼
/grep "auth" --type py           # 找認證相關程式碼
/grep "login" --type py          # 找登入相關程式碼
/grep "password" --type py       # 找密碼處理程式碼

# 3. 深入理解
/read src/api/auth.py            # 讀取認證 API
/read src/models/user.py         # 讀取使用者模型
/read src/utils/email.py         # 讀取郵件工具

# 4. 檢查測試
/glob tests/**/*auth*.py         # 找認證相關測試
/read tests/test_auth.py         # 理解測試方式

# 5. 查看文檔
/read docs/api.md                # API 文檔
/read docs/security.md           # 安全規範
```

**實戰範例:探索「忘記密碼」功能**

```bash
claude --add-dir ./src/api --add-dir ./src/models

提示詞:
我需要新增「忘記密碼」功能,請幫我探索現有程式碼:

1. 現在的認證系統如何運作?
2. 密碼儲存方式?(bcrypt? hash?)
3. 有郵件發送功能嗎?
4. 有沒有類似的 token 機制?(如 JWT)
5. API 風格是什麼?(REST? 錯誤格式?)
6. 有沒有速率限制機制?

# Claude 執行探索...

/read src/api/auth.py
/read src/models/user.py
/read src/utils/email.py
/read src/utils/jwt.py

# Claude 報告:
【探索報告】

1. 認證系統:
   - 登入: POST /api/v1/auth/login
   - 使用 JWT token
   - Token 有效期:1 小時

2. 密碼儲存:
   - 使用 bcrypt 加密
   - 儲存在 User.password_hash 欄位

3. 郵件系統:
   ✓ 已存在 src/utils/email.py
   - 使用 SMTP
   - 支援 HTML 模板
   - 範例:send_email(to, subject, body)

4. Token 機制:
   ✓ 已存在 JWT 工具
   - generate_token(user_id, expires_in)
   - verify_token(token)
   - 可以重用來生成重設密碼 token

5. API 風格:
   - RESTful API
   - 錯誤格式:{"error": "message", "code": "ERROR_CODE"}
   - 成功格式:{"data": {...}, "message": "success"}

6. 速率限制:
   ❌ 不存在!需要新增
   - 這是安全風險
   - 建議:使用 Flask-Limiter 或 Redis

【建議】:
- 重用 JWT 工具生成重設 token
- 重用郵件系統發送連結
- ⚠️ 必須新增速率限制(防止暴力攻擊)
- API 設計:
  * POST /api/v1/auth/forgot-password (請求重設)
  * POST /api/v1/auth/reset-password (執行重設)
```

**探索階段檢查點**:

- [ ] 已理解現有系統架構
- [ ] 已找出所有相關程式碼
- [ ] 已識別可重用的元件
- [ ] 已發現潛在風險
- [ ] 已確認技術可行性

### P - Plan (規劃階段)

**目標**: 制定詳細的實作計劃

**規劃內容**:
```
1. API 設計
2. 資料庫變更
3. 安全機制
4. 錯誤處理
5. 測試計劃
6. 部署步驟
```

**實戰範例:規劃「忘記密碼」功能**

```bash
提示詞:
基於探索結果,請制定「忘記密碼」功能的實作計劃

# Claude 規劃:
【實作計劃】

## 1. API 設計

### API 1: 請求重設密碼
**端點**: POST /api/v1/auth/forgot-password
**請求**:
```json
{
  "email": "user@example.com"
}
```

**回應**:
```json
{
  "message": "If email exists, reset link will be sent",
  "code": "SUCCESS"
}
```

**注意**: 不論 email 是否存在,都返回相同訊息(避免洩漏使用者資訊)

---

### API 2: 執行密碼重設
**端點**: POST /api/v1/auth/reset-password
**請求**:
```json
{
  "token": "abc123xyz...",
  "new_password": "NewSecure@123"
}
```

**回應**:
```json
{
  "message": "Password reset successfully",
  "code": "SUCCESS"
}
```

**錯誤**:
- 400: Token 無效或過期
- 400: 密碼不符合規則

---

## 2. 資料庫變更

### 新增欄位到 User 表

```sql
ALTER TABLE users ADD COLUMN reset_token VARCHAR(255);
ALTER TABLE users ADD COLUMN reset_token_expires_at TIMESTAMP;
CREATE INDEX idx_users_reset_token ON users(reset_token);
```

或使用 ORM 遷移:
```python
# migrations/add_reset_token.py
def upgrade():
    op.add_column('users', sa.Column('reset_token', sa.String(255)))
    op.add_column('users', sa.Column('reset_token_expires_at', sa.DateTime()))
    op.create_index('idx_users_reset_token', 'users', ['reset_token'])
```

---

## 3. 安全機制

### 3.1 速率限制
```python
from flask_limiter import Limiter

# 限制:每 IP 每 15 分鐘最多 3 次請求
@limiter.limit("3 per 15 minutes")
@app.route('/api/v1/auth/forgot-password', methods=['POST'])
def forgot_password():
    pass
```

### 3.2 Token 設計
```python
# 使用安全的隨機 token
import secrets

reset_token = secrets.token_urlsafe(32)  # 256-bit 隨機 token
expires_at = datetime.now() + timedelta(hours=1)  # 1 小時有效
```

### 3.3 密碼規則
```python
# 最少 8 字元,包含大小寫、數字、特殊字元
PASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$'
```

### 3.4 防止 Timing Attack
```python
# 使用固定時間回應,避免洩漏使用者存在資訊
import time

def forgot_password(email):
    start = time.time()
    user = User.query.filter_by(email=email).first()
    if user:
        send_reset_email(user)

    # 確保無論使用者是否存在,都花費相同時間
    elapsed = time.time() - start
    if elapsed < 0.5:
        time.sleep(0.5 - elapsed)

    return {"message": "If email exists, reset link will be sent"}
```

---

## 4. 實作步驟

### Phase 1: 資料庫遷移 (15 分鐘)
1. 建立遷移檔案
2. 執行遷移
3. 驗證資料庫變更

### Phase 2: 新增速率限制 (15 分鐘)
1. 安裝 Flask-Limiter
2. 配置限制規則
3. 測試限制是否生效

### Phase 3: 實作 forgot-password API (30 分鐘)
1. 建立路由
2. 驗證 email
3. 生成 reset token
4. 儲存到資料庫
5. 發送郵件

### Phase 4: 實作 reset-password API (30 分鐘)
1. 建立路由
2. 驗證 token
3. 驗證新密碼
4. 更新密碼
5. 清除 token

### Phase 5: 測試 (30 分鐘)
1. 單元測試
2. 整合測試
3. 安全測試
4. 手動測試

---

## 5. 測試計劃

### 5.1 單元測試
```python
# tests/test_forgot_password.py

def test_forgot_password_existing_user():
    """測試已存在的使用者"""
    response = client.post('/api/v1/auth/forgot-password',
                          json={'email': 'existing@example.com'})
    assert response.status_code == 200
    assert "reset link will be sent" in response.json['message']

    # 驗證資料庫
    user = User.query.filter_by(email='existing@example.com').first()
    assert user.reset_token is not None
    assert user.reset_token_expires_at > datetime.now()


def test_forgot_password_nonexistent_user():
    """測試不存在的使用者"""
    response = client.post('/api/v1/auth/forgot-password',
                          json={'email': 'nonexistent@example.com'})
    # 應該返回相同訊息(不洩漏使用者資訊)
    assert response.status_code == 200
    assert "reset link will be sent" in response.json['message']


def test_reset_password_valid_token():
    """測試有效的 token"""
    # 建立測試 token
    user = create_test_user()
    token = generate_reset_token(user)

    response = client.post('/api/v1/auth/reset-password',
                          json={'token': token, 'new_password': 'NewPass@123'})
    assert response.status_code == 200

    # 驗證密碼已更新
    assert user.check_password('NewPass@123')


def test_reset_password_expired_token():
    """測試過期的 token"""
    user = create_test_user()
    token = generate_expired_token(user)

    response = client.post('/api/v1/auth/reset-password',
                          json={'token': token, 'new_password': 'NewPass@123'})
    assert response.status_code == 400
    assert "expired" in response.json['error'].lower()


def test_rate_limiting():
    """測試速率限制"""
    for i in range(3):
        response = client.post('/api/v1/auth/forgot-password',
                              json={'email': 'test@example.com'})
        assert response.status_code == 200

    # 第 4 次應該被限制
    response = client.post('/api/v1/auth/forgot-password',
                          json={'email': 'test@example.com'})
    assert response.status_code == 429  # Too Many Requests
```

### 5.2 安全測試
```python
def test_timing_attack_resistance():
    """測試是否防禦 Timing Attack"""
    import time

    # 測試存在的使用者
    start = time.time()
    client.post('/api/v1/auth/forgot-password',
                json={'email': 'existing@example.com'})
    time_existing = time.time() - start

    # 測試不存在的使用者
    start = time.time()
    client.post('/api/v1/auth/forgot-password',
                json={'email': 'nonexistent@example.com'})
    time_nonexistent = time.time() - start

    # 時間差應該小於 100ms
    assert abs(time_existing - time_nonexistent) < 0.1
```

---

## 6. 部署檢查清單

- [ ] 資料庫遷移已執行
- [ ] 環境變數已配置(SMTP 設定)
- [ ] 速率限制已啟用
- [ ] 所有測試通過
- [ ] API 文檔已更新
- [ ] CLAUDE.md 已更新
- [ ] 監控告警已設置

---

【規劃完成】
總預估時間: 2.5-3 小時
風險等級: 中(需注意安全問題)
```

**規劃階段檢查點**:

- [ ] API 契約已定義
- [ ] 資料庫變更已規劃
- [ ] 安全機制已設計
- [ ] 測試計劃已制定
- [ ] 實作步驟已排序
- [ ] 時間預估已完成
- [ ] **規劃已 Review(重要!)**

### C - Code (編碼階段)

**目標**: 按計劃實作,邊寫邊驗證

**TDD 流程**:
```
1. 寫測試(紅燈)
2. 寫程式碼(綠燈)
3. 重構(優化)
```

**實戰範例:實作「忘記密碼」**

```bash
提示詞:
按照規劃,使用 TDD 方式實作「忘記密碼」功能

# Claude 執行:

【Phase 1: 資料庫遷移】

# Step 1: 建立遷移檔案
/write migrations/add_reset_token.py

```python
"""Add reset token fields to users table"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('users',
        sa.Column('reset_token', sa.String(255), nullable=True)
    )
    op.add_column('users',
        sa.Column('reset_token_expires_at', sa.DateTime(), nullable=True)
    )
    op.create_index('idx_users_reset_token', 'users', ['reset_token'])

def downgrade():
    op.drop_index('idx_users_reset_token', 'users')
    op.drop_column('users', 'reset_token_expires_at')
    op.drop_column('users', 'reset_token')
```

# Step 2: 執行遷移
```bash
alembic upgrade head
# ✓ Migration applied successfully
```

---

【Phase 2: 先寫測試(TDD)】

/write tests/test_forgot_password.py

```python
import pytest
from datetime import datetime, timedelta
from src.api import app
from src.models import User, db

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_forgot_password_existing_user(client):
    """測試已存在的使用者"""
    # Arrange
    user = User(email='test@example.com', username='testuser')
    user.set_password('OldPass@123')
    db.session.add(user)
    db.session.commit()

    # Act
    response = client.post('/api/v1/auth/forgot-password',
                          json={'email': 'test@example.com'})

    # Assert
    assert response.status_code == 200
    assert "reset link will be sent" in response.json['message']

    # 驗證資料庫
    user = User.query.filter_by(email='test@example.com').first()
    assert user.reset_token is not None
    assert user.reset_token_expires_at > datetime.now()

# ... 更多測試 ...
```

# Step 3: 執行測試(應該失敗,因為還沒實作)
```bash
pytest tests/test_forgot_password.py
# FAILED - 404 Not Found (路由不存在)
```

---

【Phase 3: 實作功能】

/write src/api/auth.py

```python
from flask import Blueprint, request, jsonify
from flask_limiter import Limiter
from src.models import User, db
from src.utils.email import send_reset_email
import secrets
from datetime import datetime, timedelta
import time

auth_bp = Blueprint('auth', __name__)
limiter = Limiter(app)


@auth_bp.route('/forgot-password', methods=['POST'])
@limiter.limit("3 per 15 minutes")
def forgot_password():
    """
    請求密碼重設

    限制: 每 IP 每 15 分鐘最多 3 次
    """
    start_time = time.time()

    data = request.get_json()
    email = data.get('email')

    if not email:
        return jsonify({
            'error': 'Email is required',
            'code': 'VALIDATION_ERROR'
        }), 400

    # 查詢使用者
    user = User.query.filter_by(email=email).first()

    if user:
        # 生成重設 token
        reset_token = secrets.token_urlsafe(32)
        user.reset_token = reset_token
        user.reset_token_expires_at = datetime.now() + timedelta(hours=1)
        db.session.commit()

        # 發送郵件
        send_reset_email(user.email, reset_token)

    # 防止 Timing Attack:確保固定時間回應
    elapsed = time.time() - start_time
    if elapsed < 0.5:
        time.sleep(0.5 - elapsed)

    # 無論使用者是否存在,都返回相同訊息
    return jsonify({
        'message': 'If email exists, reset link will be sent',
        'code': 'SUCCESS'
    }), 200


@auth_bp.route('/reset-password', methods=['POST'])
def reset_password():
    """執行密碼重設"""
    data = request.get_json()
    token = data.get('token')
    new_password = data.get('new_password')

    if not token or not new_password:
        return jsonify({
            'error': 'Token and new password are required',
            'code': 'VALIDATION_ERROR'
        }), 400

    # 驗證密碼強度
    if not _is_strong_password(new_password):
        return jsonify({
            'error': 'Password must be at least 8 characters with uppercase, lowercase, number and special character',
            'code': 'WEAK_PASSWORD'
        }), 400

    # 查詢 token
    user = User.query.filter_by(reset_token=token).first()

    if not user:
        return jsonify({
            'error': 'Invalid reset token',
            'code': 'INVALID_TOKEN'
        }), 400

    # 檢查過期
    if user.reset_token_expires_at < datetime.now():
        return jsonify({
            'error': 'Reset token has expired',
            'code': 'EXPIRED_TOKEN'
        }), 400

    # 更新密碼
    user.set_password(new_password)
    user.reset_token = None
    user.reset_token_expires_at = None
    db.session.commit()

    return jsonify({
        'message': 'Password reset successfully',
        'code': 'SUCCESS'
    }), 200


def _is_strong_password(password: str) -> bool:
    """檢查密碼強度"""
    import re
    pattern = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$'
    return bool(re.match(pattern, password))
```

---

【Phase 4: 實作郵件發送】

/write src/utils/email.py (補充 send_reset_email)

```python
def send_reset_email(email: str, reset_token: str) -> None:
    """
    發送密碼重設郵件

    Args:
        email: 使用者 email
        reset_token: 重設 token
    """
    reset_link = f"https://yourapp.com/reset-password?token={reset_token}"

    subject = "Password Reset Request"
    body = f"""
    <html>
    <body>
        <h2>Password Reset Request</h2>
        <p>You requested to reset your password.</p>
        <p>Click the link below to reset your password:</p>
        <p><a href="{reset_link}">Reset Password</a></p>
        <p>This link will expire in 1 hour.</p>
        <p>If you didn't request this, please ignore this email.</p>
    </body>
    </html>
    """

    send_email(
        to=email,
        subject=subject,
        body=body,
        html=True
    )
```

---

【Phase 5: 執行測試(應該全部通過)】

```bash
pytest tests/test_forgot_password.py -v

# 輸出:
test_forgot_password_existing_user ✓
test_forgot_password_nonexistent_user ✓
test_reset_password_valid_token ✓
test_reset_password_expired_token ✓
test_reset_password_weak_password ✓
test_rate_limiting ✓
test_timing_attack_resistance ✓

7 tests passed
Coverage: 95%
```

✅ 實作完成!
```

**編碼階段檢查點**:

- [ ] 測試先行(TDD)
- [ ] 所有測試通過
- [ ] 程式碼符合風格規範
- [ ] 錯誤處理完善
- [ ] 日誌記錄充分
- [ ] 效能可接受

### V - Verify (驗證階段)

**目標**: 全面驗證功能正確性與品質

**驗證清單**:
```
1. ✅ 單元測試
2. ✅ 整合測試
3. ✅ 安全掃描
4. ✅ 效能測試
5. ✅ Code Review
6. ✅ 文檔更新
```

**實戰範例:驗證「忘記密碼」**

```bash
【驗證 1: 單元測試】

pytest tests/test_forgot_password.py --cov=src/api/auth -v

# 結果:
7 tests passed
Coverage: 95%
✓ 通過

---

【驗證 2: 整合測試】

pytest tests/integration/test_auth_flow.py -v

# 測試完整流程:
1. 使用者註冊 ✓
2. 使用者登入 ✓
3. 請求密碼重設 ✓
4. 收到郵件 ✓
5. 使用 token 重設密碼 ✓
6. 用新密碼登入 ✓

✓ 通過

---

【驗證 3: 安全掃描】

提示詞:
請對「忘記密碼」功能進行安全審計

# Claude 執行掃描:

/grep "reset_token" --type py -C 5
/grep "reset_password" --type py -C 5

# 安全檢查清單:

✓ SQL 注入防護
  - 使用 ORM,無直接 SQL 拼接

✓ XSS 防護
  - 郵件內容已轉義
  - API 返回 JSON,無 HTML 注入

✓ CSRF 防護
  - API 使用 token 驗證,不依賴 Cookie

✓ 速率限制
  - 已實作 3 次/15 分鐘限制

✓ Token 安全性
  - 使用 secrets.token_urlsafe(256-bit)
  - Token 有過期時間(1 小時)
  - 使用後立即失效

✓ 防止資訊洩漏
  - 不論使用者是否存在,都返回相同訊息
  - 防禦 Timing Attack

✓ 密碼強度
  - 要求 8+ 字元,包含大小寫、數字、特殊字元

⚠️ 發現問題:
1. 建議添加「已使用 token」標記,防止重複使用
2. 建議添加日誌記錄,追蹤可疑活動

---

【驗證 4: 效能測試】

提示詞:
測試「忘記密碼」API 在高並發下的效能

# 使用 locust 進行壓力測試
locust -f tests/performance/test_forgot_password.py --users 100 --spawn-rate 10

# 結果:
- RPS: 45 requests/sec
- 平均回應時間: 22ms
- 99th 百分位: 89ms
- 錯誤率: 0%

✓ 效能可接受

---

【驗證 5: Code Review】

提示詞:
請 review 忘記密碼功能的程式碼

# Claude Review:

✓ 程式碼風格:符合 PEP 8
✓ 命名清晰:函數名稱描述準確
✓ 註解充分:關鍵邏輯都有說明
✓ 錯誤處理:完善
✓ 測試覆蓋:95%

建議:
1. 可以將 _is_strong_password 提取到 utils
2. 考慮添加「重設成功」的郵件通知

---

【驗證 6: 文檔更新】

# 更新 API 文檔
/write docs/api/auth.md (補充新 API)

# 更新 CLAUDE.md
/memory

建議添加到 CLAUDE.md:

## 忘記密碼功能
### 實作時間: 2025-01-20
### 技術細節:
- Token: 256-bit 隨機,1 小時過期
- 速率限制: 3 次/15 分鐘/IP
- 安全機制: 防 Timing Attack

### 已知問題:
- 無

### 監控指標:
- 重設請求數
- Token 使用率
- 速率限制觸發次數

---

✅ 【所有驗證通過】
功能已就緒,可以部署!
```

---

## 第二部分:EPCV 實戰範例

### 範例 1:新增 API 端點(簡單)

**需求**: 新增「取得使用者個人資料」API

**時間**: 45 分鐘

```bash
【E - Explore】 (10 分鐘)

提示詞:
我需要新增「取得使用者個人資料」API,請探索:
1. 現有的使用者 API 風格
2. 認證機制
3. User 模型結構

# Claude 分析現有程式碼...

---

【P - Plan】 (10 分鐘)

API 設計:
GET /api/v1/users/me
Headers: Authorization: Bearer <token>
Response:
{
  "id": "uuid",
  "username": "string",
  "email": "string",
  "created_at": "datetime"
}

實作步驟:
1. 新增路由
2. 實作 JWT 驗證裝飾器
3. 返回使用者資料(排除敏感資訊)
4. 寫測試

---

【C - Code】 (20 分鐘)

# 1. 先寫測試
/write tests/test_user_api.py

# 2. 實作功能
/write src/api/users.py

# 3. 執行測試
pytest tests/test_user_api.py
# ✓ 全部通過

---

【V - Verify】 (5 分鐘)

# 安全檢查
# 效能測試
# Code Review
# 文檔更新

✅ 完成!
```

### 範例 2:修復跨多檔案的 Bug(中等)

**問題**: 訂單取消後庫存沒有回滾

**時間**: 90 分鐘

```bash
【E - Explore】 (30 分鐘)

提示詞:
「訂單取消後庫存沒有回滾」,請探索:
1. 訂單取消流程在哪裡?
2. 庫存扣除邏輯在哪裡?
3. 有沒有交易機制?
4. 有沒有測試覆蓋這個場景?

# Claude 執行:
/grep "cancel_order" --type py
/grep "deduct.*stock" --type py
/read src/api/orders.py
/read src/models/product.py
/glob tests/**/*order*.py

# 發現問題:
1. cancel_order() 只更新訂單狀態
2. 沒有呼叫 restore_inventory()
3. 缺少測試

---

【P - Plan】 (15 分鐘)

修復方案:
1. 在 cancel_order() 中添加庫存回滾
2. 使用資料庫交易確保原子性
3. 添加測試覆蓋此場景
4. 檢查是否有其他地方也需要修復

實作步驟:
Phase 1: 建立測試(重現 bug)
Phase 2: 修復 cancel_order()
Phase 3: 添加交易機制
Phase 4: 驗證修復

---

【C - Code】 (35 分鐘)

# Phase 1: 先寫測試(應該失敗)
/write tests/test_order_cancel.py

def test_cancel_order_restores_inventory():
    """測試取消訂單會回滾庫存"""
    # 初始庫存
    product = create_test_product(stock=100)

    # 建立訂單(扣除 10 個)
    order = create_test_order(product_id=product.id, quantity=10)
    assert product.stock == 90

    # 取消訂單
    cancel_order(order.id)

    # 驗證庫存回滾
    assert product.stock == 100  # 應該恢復

# 執行測試
pytest tests/test_order_cancel.py::test_cancel_order_restores_inventory
# FAILED - AssertionError: assert 90 == 100
# ✓ 成功重現 bug

---

# Phase 2: 修復程式碼
/read src/api/orders.py
/edit src/api/orders.py

# 修改 cancel_order 函數,添加庫存回滾

---

# Phase 3: 再次測試
pytest tests/test_order_cancel.py
# ✓ 全部通過

---

【V - Verify】 (10 分鐘)

# 1. 執行所有訂單相關測試
pytest tests/*order* -v
# ✓ 全部通過

# 2. 檢查是否引入新問題
pytest tests/ -v
# ✓ 全部通過

# 3. Code Review
# 4. 更新文檔

✅ Bug 修復完成!
```

### 範例 3:重構遺留系統(複雜)

**任務**: 重構混亂的支付模組

**時間**: 4 小時

```bash
【E - Explore】 (60 分鐘)

提示詞:
請全面分析 src/api/payment.py,找出:
1. 主要功能
2. 程式碼異味
3. 安全問題
4. 效能問題
5. 測試覆蓋率

# Claude 執行深度分析...
/read src/api/payment.py
/grep "payment" --type py
/glob tests/**/*payment*.py

# 報告:
- 主函數 387 行
- 8 種支付方式混在一起
- 無錯誤處理
- 無交易機制
- 測試覆蓋率 15%

---

【P - Plan】 (60 分鐘)

重構策略:
1. 提取每種支付方式為獨立類別
2. 使用策略模式
3. 添加統一錯誤處理
4. 實作交易機制
5. 建立完整測試

架構設計:
[詳細的類別圖、流程圖]

分階段實施:
Week 1: 建立新架構
Week 2: 遷移現有功能
Week 3: 測試與驗證

---

【C - Code】 (90 分鐘)

# 按計劃逐步實作...
[詳細實作過程]

---

【V - Verify】 (30 分鐘)

# 全面驗證...
[測試、Review、文檔]

✅ 重構完成!
```

---

## 第三部分:驗證前置(Validation-First)

### 為什麼驗證前置?

**傳統方式** (生成後驗證):
```
寫程式碼 → 執行 → 發現 bug → 修改 → 再執行 → 又有 bug → ...
```

**驗證前置** (測試驅動):
```
寫測試 → 寫程式碼(測試導向) → 測試通過 → 完成
```

### TDD 與 AI 結合

```bash
提示詞:
使用 TDD 方式實作「商品搜尋」功能

# Claude 自動執行 TDD:

【紅燈】先寫測試
/write tests/test_product_search.py

def test_search_by_name():
    """測試按名稱搜尋"""
    products = [
        create_product(name="iPhone 15"),
        create_product(name="Samsung Galaxy"),
        create_product(name="iPhone 14")
    ]

    result = search_products(query="iPhone")

    assert len(result) == 2
    assert all("iPhone" in p.name for p in result)

# 執行:pytest → FAILED(函數不存在)

---

【綠燈】寫最簡實作
/write src/api/products.py

def search_products(query: str) -> list[Product]:
    """搜尋商品"""
    return Product.query.filter(
        Product.name.ilike(f"%{query}%")
    ).all()

# 執行:pytest → PASSED

---

【重構】優化程式碼
# 添加更多過濾條件
# 優化查詢效能
# 添加分頁

# 執行:pytest → PASSED(確保重構沒破壞功能)
```

### BDD 場景測試

```python
# tests/test_order_flow.feature
Feature: 訂單流程
  作為一個使用者
  我想要完成購物流程
  以便購買商品

  Scenario: 成功下單
    Given 使用者已登入
    And 購物車有 2 個商品
    And 庫存充足
    When 使用者確認訂單
    Then 訂單建立成功
    And 庫存扣除成功
    And 使用者收到確認郵件

  Scenario: 庫存不足
    Given 使用者已登入
    And 購物車有 10 個商品
    And 庫存只有 5 個
    When 使用者確認訂單
    Then 顯示錯誤訊息「庫存不足」
    And 訂單未建立
    And 庫存未扣除
```

---

## 第四部分:指令組合速查

### E - Explore 階段

```bash
# 理解專案結構
/glob **/*.py
/read CLAUDE.md
/context

# 找相關程式碼
/grep "<關鍵字>" --type <語言>
/read <關鍵檔案>

# 分析依賴
/grep "import" --type py | 分析模組依賴
```

### P - Plan 階段

```bash
# AI 輔助規劃
提示詞: 請制定<功能>的實作計劃,包含:
1. API 設計
2. 資料庫變更
3. 安全考量
4. 測試計劃
5. 分階段實施
```

### C - Code 階段

```bash
# TDD 流程
/write tests/test_<功能>.py   # 先寫測試
# 執行: pytest → 紅燈
/write src/<功能>.py           # 實作功能
# 執行: pytest → 綠燈
/edit src/<功能>.py            # 重構優化
# 執行: pytest → 持續綠燈
```

### V - Verify 階段

```bash
# 全面測試
pytest tests/ -v --cov=src

# 安全掃描
/grep "<安全關鍵字>" --type py

# Code Review
提示詞: 請 review <檔案>,檢查:
1. 風格
2. 邏輯
3. 效能
4. 安全

# 更新文檔
/memory
/write docs/<文檔>.md
```

---

## 總結

### EPCV 核心價值

```
1. 系統化:不再靠運氣,有明確流程
2. 高品質:驗證前置,bug 更少
3. 高效率:減少返工,一次做對
4. 可重複:流程標準化,可複製
```

### 關鍵原則

1. **Explore 要充分** - 理解不足導致返工
2. **Plan 要細緻** - 規劃階段就 Review
3. **Code 要測試** - TDD/BDD 確保品質
4. **Verify 要全面** - 不只功能,還有安全、效能

### Linux 類比

```bash
EPCV = 系統化開發方法論

就像 Linux 的「一切皆檔案」哲學,
EPCV 提供了「一切皆流程」的開發哲學
```

### 下一步

恭喜完成 Module 2!你已經掌握:
- Claude Code 基礎操作
- 上下文管理
- 程式碼分析與重構
- EPCV 系統化開發

接下來:
- **Module 3: IDE 整合** - 在熟悉的環境中使用 AI
- **Module 4: TDD/BDD 實踐** - 深入測試驅動開發

---

**繼續學習**: [Module 3 - IDE 整合開發](../../03_IDE整合開發/README.md)
