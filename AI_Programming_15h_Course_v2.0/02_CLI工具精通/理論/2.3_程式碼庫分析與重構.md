# 2.3 程式碼庫分析與重構

## 學習目標

完成本章後,你將能夠:
- 使用 Claude Code 探索大型程式碼庫的結構與依賴關係
- 掌握 /glob、/grep、/read 三大分析指令
- 執行安全的多檔案重構操作
- 識別重構機會並制定系統化重構計劃
- 在重構後進行完整的驗證與測試

**預計時間**: 60-90 分鐘
**實戰權重**: 高(30% 實務操作)

---

## 情境引入:接手遺留專案的挑戰

### 情境 2.3.1:混亂的遺留系統

**真實場景**:
```
第一天:
你: 新接手的專案在哪?
主管: 在 GitHub,已經 3 年沒人碰了
你: 文檔呢?
主管: ...什麼文檔?
你: 😱

專案現狀:
- 287 個 Python 檔案
- 45,328 行程式碼
- 15 個人寫過(都已離職)
- 0 行註解
- 0 個測試
- 命名混亂(func1, func2, do_stuff...)
- 到處是重複程式碼
- 你的任務:6 個月內重構完成
```

**傳統方法的困境**:
```bash
# 手動方法
1. 用 IDE 開啟專案 → 載入 10 分鐘,然後卡死
2. 用 grep 搜尋 → 結果太多,看不懂
3. 一個個檔案打開 → 3 天後還在看第 50 個檔案
4. 畫架構圖 → 不知道從哪開始
5. 開始改程式碼 → 改了 A,B 就壞了
6. 放棄 → 提離職申請

耗時: 2 週(還沒開始實質工作)
結果: 還是不知道專案在幹嘛
```

**Claude Code 方法**:
```bash
# AI 協助方法
claude --add-dir ./src

提示詞:
請分析這個 Python 專案:
1. 繪製模組依賴關係圖
2. 識別核心功能與邊緣功能
3. 找出程式碼異味(code smells)
4. 提供重構優先順序建議

# 30 分鐘後...
Claude: [完整分析報告]
- 核心模組:3 個(認證、訂單、支付)
- 邊緣模組:12 個
- 重複程式碼:237 個實例
- 建議優先重構:認證模組(影響最大)

耗時: 30 分鐘
結果: 清楚理解專案結構,有明確的重構計劃
```

---

## 第一部分:程式碼庫探索工具

### /glob: 檔案搜尋與模式匹配

**類比**:
```bash
# Linux
find . -name "*.py"          # 找所有 Python 檔案

# Claude Code
/glob **/*.py                # 相同功能,更強大
```

**基本語法**:
```bash
# 1. 找特定副檔名
/glob **/*.py                # 所有 Python 檔案
/glob **/*.{js,ts}           # 所有 JavaScript/TypeScript 檔案
/glob **/*.test.py           # 所有測試檔案

# 2. 找特定目錄
/glob src/**/*.py            # src 目錄下所有 Python 檔案
/glob **/models/*.py         # 所有 models 目錄下的 Python 檔案

# 3. 排除模式
/glob **/*.py !**/test_*.py  # Python 檔案,但排除測試

# 4. 複雜模式
/glob src/**/api_*.py        # src 下所有以 api_ 開頭的檔案
```

**實戰範例 1:找出所有 API 路由**

```bash
claude

提示詞:
請找出專案中所有定義 API 路由的檔案

# Claude 會執行:
/glob **/*route*.py
/glob **/*api*.py
/glob **/views/*.py

# 輸出:
Found 23 files:
- src/api/routes/auth.py
- src/api/routes/orders.py
- src/api/routes/products.py
- src/views/user_views.py
...

# Claude 分析:
基於檔案名稱和路徑,主要的路由檔案在:
1. src/api/routes/ (15 個檔案)
2. src/views/ (8 個檔案)

建議:路由定義分散在兩個位置,應該統一
```

**實戰範例 2:找出所有測試檔案**

```bash
提示詞:
找出所有測試檔案,並統計測試覆蓋率

# Claude 執行:
/glob **/test_*.py
/glob **/*_test.py
/glob **/tests/**/*.py

# 輸出:
Found 87 test files:
- tests/unit/test_auth.py
- tests/unit/test_orders.py
- tests/integration/test_api.py
...

# 統計程式碼檔案
/glob src/**/*.py !**/test_*.py
# Found 200 source files

# Claude 分析:
測試檔案: 87 個
程式碼檔案: 200 個
比例: 43.5%

結論:測試覆蓋率偏低,建議增加單元測試
```

### /grep: 內容搜尋與模式匹配

**類比**:
```bash
# Linux
grep -r "def login" .        # 搜尋函數定義

# Claude Code
/grep "def login"            # 相同功能 + AI 理解
```

**基本語法**:
```bash
# 1. 簡單搜尋
/grep "function_name"        # 找包含特定字串的檔案

# 2. 正則表達式
/grep "def\s+\w+\(.*\)"      # 找所有函數定義
/grep "class\s+\w+"          # 找所有類別定義

# 3. 檔案類型過濾
/grep "import" --type py     # 只在 Python 檔案中搜尋
/grep "useState" --type js   # 只在 JavaScript 檔案中搜尋

# 4. 顯示上下文
/grep "TODO" -C 3            # 顯示匹配行前後 3 行
/grep "FIXME" -A 5           # 顯示匹配行後 5 行

# 5. 大小寫不敏感
/grep -i "error" --type py   # 忽略大小寫
```

**實戰範例 1:找出所有 SQL 查詢**

```bash
提示詞:
找出專案中所有直接寫的 SQL 查詢,檢查是否有 SQL 注入風險

# Claude 執行:
/grep "SELECT.*FROM" --type py
/grep "INSERT\s+INTO" --type py
/grep "UPDATE.*SET" --type py
/grep "DELETE\s+FROM" --type py

# 輸出:
Found in 12 files:

src/models/user.py:45
    query = f"SELECT * FROM users WHERE id = {user_id}"  # 危險!

src/models/order.py:89
    query = "SELECT * FROM orders WHERE user_id = ?"    # 安全(參數化)

src/api/auth.py:123
    sql = f"SELECT * FROM users WHERE username = '{username}'"  # 危險!
...

# Claude 分析:
發現 5 處 SQL 注入風險:
1. src/models/user.py:45 - 使用 f-string 拼接 SQL
2. src/api/auth.py:123 - 直接字串拼接
3. src/api/products.py:67 - 未參數化查詢
...

建議:全部改用參數化查詢或 ORM
```

**實戰範例 2:找出所有 TODO 和 FIXME**

```bash
提示詞:
統計專案中所有未完成的工作(TODO、FIXME、HACK)

# Claude 執行:
/grep -i "TODO" -C 2
/grep -i "FIXME" -C 2
/grep -i "HACK" -C 2

# 輸出:
TODO: 34 instances
FIXME: 12 instances
HACK: 8 instances

重要的 FIXME:
1. src/api/payment.py:234
   # FIXME: 支付失敗時沒有回滾庫存

2. src/models/order.py:567
   # FIXME: 併發訂單會導致超賣

3. src/api/auth.py:89
   # FIXME: JWT token 沒有過期檢查

# Claude 分析:
緊急需要修復的問題(FIXME):
- 支付失敗回滾(高優先)
- 併發訂單超賣(高優先)
- JWT 安全性(中優先)

建議立即處理前兩項
```

**實戰範例 3:找出敏感資訊洩漏**

```bash
提示詞:
檢查程式碼中是否有硬編碼的密碼、API key 或敏感資訊

# Claude 執行:
/grep -i "password\s*=\s*['\"]" --type py
/grep -i "api_key\s*=\s*['\"]" --type py
/grep -i "secret\s*=\s*['\"]" --type py
/grep -i "token\s*=\s*['\"]" --type py

# 輸出:
⚠️ 發現 3 處敏感資訊:

src/config.py:12
    DATABASE_PASSWORD = "super_secret_123"  # 危險!

src/api/oauth.py:45
    GOOGLE_CLIENT_SECRET = "abc123xyz"      # 危險!

src/utils/mail.py:78
    SMTP_PASSWORD = os.getenv("SMTP_PASSWORD", "default_pass")  # 不安全的預設值

# Claude 分析:
安全問題:
1. 硬編碼密碼在版本控制中
2. 第三方服務金鑰明文儲存
3. 不安全的預設值

建議:
1. 移到環境變數
2. 使用密鑰管理服務(AWS Secrets Manager)
3. 移除所有預設值
4. 檢查 Git 歷史,撤銷洩漏的密鑰
```

### /read: 檔案讀取與理解

**類比**:
```bash
# Linux
cat file.py                  # 顯示檔案內容
less file.py                 # 分頁顯示

# Claude Code
/read file.py                # 讀取 + AI 理解
```

**智慧讀取特性**:
```bash
# 1. 單一檔案
/read src/api/auth.py

# Claude 不只顯示內容,還會:
- 識別主要功能
- 分析依賴關係
- 發現潛在問題
- 提供改進建議

# 2. 多個檔案
/read src/api/auth.py src/models/user.py

# Claude 會:
- 分析檔案間的關係
- 識別共享的邏輯
- 發現不一致之處

# 3. 目錄
/read src/api/

# Claude 會:
- 讀取目錄下所有檔案
- 提供整體結構分析
- 識別模式和反模式
```

**實戰範例:理解認證流程**

```bash
提示詞:
請閱讀認證相關的程式碼,解釋整個認證流程

# Claude 執行:
/read src/api/auth.py
/read src/models/user.py
/read src/utils/jwt.py

# Claude 分析:
認證流程分析:

1. 登入端點 (src/api/auth.py:45-89)
   POST /api/auth/login
   - 接收 username、password
   - 呼叫 User.authenticate()
   - 生成 JWT token
   - 返回 token

2. 使用者驗證 (src/models/user.py:123-145)
   User.authenticate(username, password)
   - 查詢資料庫取得使用者
   - 使用 bcrypt 驗證密碼
   - 返回使用者物件

3. JWT 生成 (src/utils/jwt.py:34-56)
   generate_token(user_id)
   - 建立 payload {user_id, exp}
   - 使用 HS256 簽名
   - 返回 token 字串

4. JWT 驗證 (src/utils/jwt.py:67-89)
   verify_token(token)
   - 解碼 token
   - 檢查過期時間
   - 返回 user_id

問題發現:
❌ 密碼驗證失敗時沒有速率限制(暴力破解風險)
❌ JWT 沒有黑名單機制(無法登出)
❌ 錯誤訊息洩漏資訊("使用者不存在" vs "密碼錯誤")

建議:
1. 添加登入嘗試限制
2. 實作 JWT 黑名單(用 Redis)
3. 統一錯誤訊息為"帳號或密碼錯誤"
```

### 組合使用:深度分析

**範例 1:找出所有未處理的異常**

```bash
提示詞:
找出所有可能拋出異常但沒有處理的地方

# Claude 執行分析:

# Step 1: 找出所有 raise 語句
/grep "raise\s+\w+" --type py

# Step 2: 找出所有 try-except 區塊
/grep "try:" --type py -A 10

# Step 3: 對比分析
/read src/api/payment.py
/read src/api/orders.py

# Claude 報告:
發現 15 處未處理的異常:

1. src/api/payment.py:123
   stripe.charge.create(...)  # 可能拋出 StripeError
   沒有 try-except 包裹

2. src/api/orders.py:89
   order.save()  # 可能拋出 DatabaseError
   沒有錯誤處理

3. src/utils/email.py:45
   smtp.send(...)  # 可能拋出 SMTPException
   沒有重試機制

風險等級:
- 高風險: 支付相關(3 處)
- 中風險: 資料庫操作(8 處)
- 低風險: 日誌記錄(4 處)

建議修復順序:
1. 先修復支付相關(會導致資金損失)
2. 再修復資料庫操作
3. 最後處理日誌記錄
```

**範例 2:分析 API 一致性**

```bash
提示詞:
檢查所有 API 端點的錯誤處理是否一致

# Claude 執行:

# Step 1: 找出所有 API 路由檔案
/glob src/api/routes/*.py

# Step 2: 搜尋錯誤處理模式
/grep "except" src/api/routes/ -C 3

# Step 3: 讀取關鍵檔案
/read src/api/routes/auth.py
/read src/api/routes/orders.py
/read src/api/routes/products.py

# Claude 分析:
API 錯誤處理不一致問題:

1. 錯誤格式不統一:
   - auth.py 返回: {"error": "message"}
   - orders.py 返回: {"message": "error"}
   - products.py 返回: {"detail": "error"}

2. HTTP 狀態碼不統一:
   - 資源未找到:
     * auth.py 返回 404
     * orders.py 返回 400
     * products.py 返回 200 + error 欄位

3. 異常處理方式不同:
   - auth.py: 使用裝飾器 @handle_errors
   - orders.py: 每個函數內 try-except
   - products.py: 沒有錯誤處理

建議:制定統一的錯誤處理標準
```

---

## 第二部分:重構工作流程

### 識別重構機會

**程式碼異味(Code Smells)清單**:

```bash
提示詞:
請分析專案,找出以下程式碼異味:
1. 重複程式碼(DRY 違反)
2. 過長函數(>50 行)
3. 過大類別(>500 行)
4. 過多參數(>5 個)
5. 神秘命名(x, data, do_stuff)
6. 註解缺失
7. 複雜的條件判斷(巢狀 if)

# Claude 執行完整掃描:

# 1. 找重複程式碼
/grep -i "def.*validate" --type py  # 找所有驗證函數

# 2. 找長函數
/glob **/*.py | /read | 分析行數

# 3. 找命名問題
/grep "def\s+[a-z]\(" --type py     # 單字母函數名
/grep "def\s+data\(" --type py      # 模糊命名

# Claude 報告:
程式碼異味統計:

❌ 重複程式碼:
- 使用者驗證邏輯重複 12 次
- 錯誤處理重複 34 次
- 資料庫查詢模式重複 45 次

❌ 過長函數: 23 個
- src/api/orders.py:process_order() - 237 行
- src/utils/report.py:generate_report() - 189 行
- src/api/payment.py:handle_payment() - 156 行

❌ 神秘命名: 67 處
- func1, func2, func3
- data, data2, temp_data
- do_stuff, handle_data, process

❌ 缺少註解: 85% 的函數沒有 docstring

❌ 複雜條件: 15 處 4 層以上巢狀 if

重構優先順序:
1. 【緊急】process_order() - 核心功能,太複雜
2. 【重要】統一錯誤處理 - 影響範圍廣
3. 【重要】提取重複驗證邏輯 - DRY 原則
4. 【一般】改善命名 - 可讀性
5. 【一般】添加註解 - 維護性
```

### 安全重構策略

**重構四步法**:

```
1. 理解(Understand)
   ↓
2. 測試(Test)
   ↓
3. 重構(Refactor)
   ↓
4. 驗證(Verify)
```

**實戰:重構長函數**

```bash
# 情境:process_order() 函數 237 行,需要重構

# Step 1: 理解
提示詞:
請閱讀 src/api/orders.py 的 process_order() 函數,
分析它的職責,並繪製流程圖

# Claude 執行:
/read src/api/orders.py

# Claude 分析:
process_order() 職責分析:

主要流程:
1. 驗證訂單資料 (行 45-78)
2. 檢查庫存 (行 79-123)
3. 計算價格 (行 124-156)
4. 處理優惠券 (行 157-189)
5. 扣除庫存 (行 190-212)
6. 建立訂單記錄 (行 213-234)
7. 發送通知 (行 235-250)

問題:一個函數做了 7 件事!

---

# Step 2: 測試
提示詞:
請先為 process_order() 建立測試,確保重構後行為不變

# Claude 生成測試:
/write tests/test_orders.py

```python
import pytest
from src.api.orders import process_order

def test_process_order_success():
    """測試正常訂單處理流程"""
    order_data = {
        "user_id": "user123",
        "items": [
            {"product_id": "p1", "quantity": 2},
            {"product_id": "p2", "quantity": 1}
        ]
    }
    result = process_order(order_data)
    assert result.status == "success"
    assert result.order_id is not None

def test_process_order_insufficient_stock():
    """測試庫存不足情況"""
    order_data = {
        "user_id": "user123",
        "items": [{"product_id": "p1", "quantity": 9999}]
    }
    with pytest.raises(InsufficientStockError):
        process_order(order_data)

def test_process_order_invalid_coupon():
    """測試無效優惠券"""
    order_data = {
        "user_id": "user123",
        "items": [{"product_id": "p1", "quantity": 1}],
        "coupon": "INVALID"
    }
    with pytest.raises(InvalidCouponError):
        process_order(order_data)

# ... 更多測試 ...
```

執行測試確保目前行為:
```bash
pytest tests/test_orders.py -v
# 全部通過 ✓
```

---

# Step 3: 重構
提示詞:
現在請重構 process_order(),將它分解為多個小函數

# Claude 重構:

```python
# 原始版本(237 行)
def process_order(order_data: dict) -> OrderResult:
    # 驗證
    if not order_data.get("user_id"):
        raise ValidationError("Missing user_id")
    if not order_data.get("items"):
        raise ValidationError("Missing items")
    # ... 200 多行邏輯 ...

# 重構後版本
def process_order(order_data: dict) -> OrderResult:
    """
    處理訂單

    Args:
        order_data: 訂單資料

    Returns:
        OrderResult: 處理結果
    """
    # 1. 驗證
    _validate_order_data(order_data)

    # 2. 檢查庫存
    _check_inventory(order_data["items"])

    # 3. 計算價格
    total_price = _calculate_total_price(order_data["items"])

    # 4. 處理優惠券
    discount = _apply_coupon(order_data.get("coupon"), total_price)
    final_price = total_price - discount

    # 5. 建立訂單
    order = _create_order_record(
        user_id=order_data["user_id"],
        items=order_data["items"],
        price=final_price
    )

    # 6. 扣除庫存
    _deduct_inventory(order_data["items"])

    # 7. 發送通知
    _send_order_notification(order)

    return OrderResult(success=True, order_id=order.id)


def _validate_order_data(order_data: dict) -> None:
    """驗證訂單資料"""
    if not order_data.get("user_id"):
        raise ValidationError("Missing user_id")
    if not order_data.get("items"):
        raise ValidationError("Missing items")
    for item in order_data["items"]:
        if not item.get("product_id"):
            raise ValidationError("Missing product_id")
        if not item.get("quantity") or item["quantity"] <= 0:
            raise ValidationError("Invalid quantity")


def _check_inventory(items: list[dict]) -> None:
    """檢查庫存是否充足"""
    for item in items:
        product = Product.get_by_id(item["product_id"])
        if not product:
            raise ProductNotFoundError(f"Product {item['product_id']} not found")
        if product.stock < item["quantity"]:
            raise InsufficientStockError(
                f"Product {product.name} has only {product.stock} in stock"
            )


def _calculate_total_price(items: list[dict]) -> int:
    """計算訂單總價"""
    total = 0
    for item in items:
        product = Product.get_by_id(item["product_id"])
        total += product.price * item["quantity"]
    return total


def _apply_coupon(coupon_code: str | None, total_price: int) -> int:
    """應用優惠券,返回折扣金額"""
    if not coupon_code:
        return 0

    coupon = Coupon.get_by_code(coupon_code)
    if not coupon or not coupon.is_valid():
        raise InvalidCouponError(f"Invalid coupon: {coupon_code}")

    if coupon.type == "percentage":
        return int(total_price * coupon.value / 100)
    elif coupon.type == "fixed":
        return min(coupon.value, total_price)
    return 0


def _create_order_record(user_id: str, items: list[dict], price: int) -> Order:
    """建立訂單記錄"""
    order = Order(
        user_id=user_id,
        items=items,
        total_price=price,
        status="pending"
    )
    order.save()
    return order


def _deduct_inventory(items: list[dict]) -> None:
    """扣除庫存"""
    for item in items:
        product = Product.get_by_id(item["product_id"])
        product.stock -= item["quantity"]
        product.save()


def _send_order_notification(order: Order) -> None:
    """發送訂單通知"""
    user = User.get_by_id(order.user_id)
    send_email(
        to=user.email,
        subject="訂單確認",
        body=f"您的訂單 {order.id} 已確認"
    )
```

重構效果:
- 主函數:237 行 → 37 行
- 每個子函數:15-30 行
- 職責清晰:每個函數只做一件事
- 可讀性:大幅提升
- 可測試性:每個函數可單獨測試

---

# Step 4: 驗證
提示詞:
重構完成,請執行所有測試確保行為不變

# Claude 執行:
```bash
pytest tests/test_orders.py -v

# 輸出:
test_process_order_success ✓
test_process_order_insufficient_stock ✓
test_process_order_invalid_coupon ✓
test_process_order_with_coupon ✓
test_process_order_multiple_items ✓
... (20 個測試全部通過)

Coverage: 95%
```

結果: ✅ 所有測試通過,重構成功!
```

### 多檔案重構策略

**場景:統一錯誤處理**

```bash
# 問題:錯誤處理散落在 50 個檔案中,格式不一致

# Step 1: 分析現狀
提示詞:
找出所有錯誤處理程式碼,分析有哪些模式

# Claude 執行:
/grep "except" --type py -C 3
/read src/api/*.py

# Claude 報告:
發現 3 種錯誤處理模式:

模式 A (使用裝飾器):
```python
@handle_errors
def some_function():
    pass
```
使用檔案: 12 個

模式 B (try-except 包裹):
```python
def some_function():
    try:
        # logic
    except Exception as e:
        return {"error": str(e)}
```
使用檔案: 28 個

模式 C (沒有錯誤處理):
```python
def some_function():
    # 直接執行,可能拋出異常
    pass
```
使用檔案: 10 個

---

# Step 2: 設計統一方案
提示詞:
設計一個統一的錯誤處理機制

# Claude 提議:

```python
# src/utils/error_handler.py
from functools import wraps
from typing import Callable, Any
import logging

logger = logging.getLogger(__name__)


class APIError(Exception):
    """API 錯誤基類"""
    def __init__(self, message: str, status_code: int = 500):
        self.message = message
        self.status_code = status_code
        super().__init__(message)


class ValidationError(APIError):
    """驗證錯誤"""
    def __init__(self, message: str):
        super().__init__(message, status_code=400)


class NotFoundError(APIError):
    """資源未找到"""
    def __init__(self, message: str):
        super().__init__(message, status_code=404)


class UnauthorizedError(APIError):
    """未授權"""
    def __init__(self, message: str):
        super().__init__(message, status_code=401)


def handle_errors(func: Callable) -> Callable:
    """統一錯誤處理裝飾器"""
    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return func(*args, **kwargs)
        except APIError as e:
            logger.error(f"API Error: {e.message}", exc_info=True)
            return {
                "error": e.message,
                "status_code": e.status_code
            }, e.status_code
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            return {
                "error": "Internal server error",
                "status_code": 500
            }, 500
    return wrapper
```

---

# Step 3: 逐步遷移
提示詞:
按以下順序遷移所有檔案到新的錯誤處理機制:
1. 核心 API (auth, orders, payment)
2. 次要 API (products, users)
3. 工具函數

# Claude 執行(範例:遷移 auth.py):

```python
# 遷移前
def login(username: str, password: str):
    try:
        user = User.query.filter_by(username=username).first()
        if not user:
            return {"message": "User not found"}, 404
        if not user.check_password(password):
            return {"message": "Invalid password"}, 401
        token = generate_token(user.id)
        return {"token": token}, 200
    except Exception as e:
        return {"error": str(e)}, 500


# 遷移後
from src.utils.error_handler import handle_errors, NotFoundError, UnauthorizedError

@handle_errors
def login(username: str, password: str):
    user = User.query.filter_by(username=username).first()
    if not user:
        raise NotFoundError("User not found")
    if not user.check_password(password):
        raise UnauthorizedError("Invalid password")
    token = generate_token(user.id)
    return {"token": token}
```

逐一遷移 50 個檔案...

---

# Step 4: 測試驗證
提示詞:
執行所有測試,確保遷移後功能正常

# Claude 執行:
```bash
pytest tests/ -v --cov=src

# 結果:
237 tests passed
Coverage: 87%
```

✅ 重構成功!所有錯誤處理已統一
```

---

## 第三部分:Linux 類比記憶法

### 指令對照表

```bash
# 檔案搜尋
find . -name "*.py"              →  /glob **/*.py
find . -type f -name "test_*"    →  /glob **/test_*.py

# 內容搜尋
grep -r "function" .             →  /grep "function"
grep -r "def.*(" --include="*.py" →  /grep "def.*(" --type py

# 檔案讀取
cat file.py                      →  /read file.py
less file.py                     →  /read file.py  # AI 還會分析

# 組合使用
find . -name "*.py" | xargs grep "TODO"
  →  /glob **/*.py | /grep "TODO"
```

### 工作流程類比

```bash
# Linux: 找出所有大檔案
find . -type f -size +1M -exec ls -lh {} \;

# Claude Code: 找出所有長函數
/glob **/*.py | 分析函數長度
```

### 記憶錨點

```
/glob = find  (全局搜尋檔案)
/grep = grep  (全局搜尋內容)
/read = cat   (讀取檔案)
```

---

## 第四部分:實戰練習

### 練習 1:安全性審計 (30 分鐘)

**任務**:
對你的專案進行全面安全性掃描

**檢查清單**:
```bash
1. SQL 注入風險
   /grep "SELECT.*\+\|f\".*SELECT" --type py

2. 硬編碼密碼
   /grep -i "password\s*=\s*['\"]" --type py

3. 不安全的隨機數
   /grep "random\." --type py

4. 未驗證的使用者輸入
   /grep "request\.(args|form|json)" --type py -A 5

5. 未處理的異常
   /grep "raise" --type py
```

**檢查點**:
- [ ] 找出至少 5 個安全問題
- [ ] 提供修復建議
- [ ] 記錄到 CLAUDE.md

### 練習 2:重構長函數 (45 分鐘)

**任務**:
找出專案中最長的函數並重構

**步驟**:
```bash
1. 找出所有長函數(>50 行)
   /glob **/*.py | 分析函數長度

2. 選擇一個重構
3. 建立測試
4. 執行重構
5. 驗證測試
```

**檢查點**:
- [ ] 主函數縮短至 30 行以內
- [ ] 每個子函數職責單一
- [ ] 所有測試通過
- [ ] 程式碼可讀性提升

### 練習 3:統一命名規範 (30 分鐘)

**任務**:
識別並修正所有命名問題

**步驟**:
```bash
1. 找出模糊命名
   /grep "def\s+(data|temp|func|do|handle)\(" --type py

2. 找出單字母命名
   /grep "def\s+[a-z]\(" --type py

3. 提出改名方案
4. 批次重命名
5. 驗證引用
```

**檢查點**:
- [ ] 無模糊命名
- [ ] 無單字母函數名
- [ ] 所有測試通過

---

## 總結

### 核心指令

```bash
/glob     # 檔案搜尋(find)
/grep     # 內容搜尋(grep)
/read     # 檔案讀取(cat) + AI 分析
```

### 重構流程

```
1. 理解(Understand) → /read, /grep, /glob
2. 測試(Test)       → 建立測試套件
3. 重構(Refactor)   → 安全修改
4. 驗證(Verify)     → 執行測試
```

### 最佳實踐

1. **小步前進** - 每次只重構一個小部分
2. **持續測試** - 每步都執行測試
3. **版本控制** - 頻繁提交,容易回退
4. **文檔更新** - 重構後更新 CLAUDE.md

### 下一步

現在你已經掌握程式碼分析與重構,接下來學習:
- **2.4 EPCV 工作流程深度解析** - 系統化開發流程

---

**下一章**: [2.4 EPCV工作流程深度解析](./2.4_EPCV工作流程深度解析.md)
