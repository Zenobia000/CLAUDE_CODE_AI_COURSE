# C05：安全漏洞修復（組合級）

## 情境資訊

**編號**：C05
**難度**：⭐⭐⭐⭐☆（組合級）
**預計時間**：1.5 小時
**學習目標**：
- 掌握系統化搜尋安全漏洞的方法
- 熟練使用 /grep 搜尋危險代碼模式
- 學會使用 /read 分析安全上下文
- 理解如何使用 /memory 建立安全檢查清單
- 建立完整的安全修復流程

**適用對象**：
- 完成模組 2 基礎理論
- 有基本安全意識
- 需要處理安全問題的開發者

---

## 情境描述

### 背景

你的公司剛收到一份來自白帽駭客的安全審計報告，發現了多個嚴重安全漏洞。公司要求 48 小時內修復所有 Critical 和 High 級別的漏洞。

```
🔴 SECURITY AUDIT REPORT 🔴

Company: TechCorp
Application: Customer Portal (Node.js)
Audit Date: 2025-01-15
Auditor: WhiteHat Security Inc.

CRITICAL FINDINGS: 3
HIGH FINDINGS: 5
MEDIUM FINDINGS: 12

Top Issues:
1. SQL Injection in user search (CRITICAL)
2. Stored XSS in comment system (CRITICAL)
3. Authentication bypass in admin panel (CRITICAL)
4. Missing input validation (HIGH)
5. Sensitive data exposure in logs (HIGH)
6. Missing rate limiting (HIGH)
7. Insecure direct object references (HIGH)
8. Weak password policy (HIGH)

Deadline: 48 hours
Compliance: Required for SOC 2 certification
```

你被指派為安全修復小組的技術負責人，必須系統化地找出並修復所有漏洞。

### 專案資訊

```bash
customer-portal/
├── src/
│   ├── routes/
│   │   ├── users.js          # 用戶路由（有 SQL Injection）
│   │   ├── comments.js       # 評論路由（有 XSS）
│   │   ├── admin.js          # 管理路由（有權限問題）
│   │   ├── auth.js           # 認證路由（有繞過漏洞）
│   │   └── files.js          # 檔案路由（有 IDOR）
│   ├── middleware/
│   │   ├── auth.js           # 認證中間件（有漏洞）
│   │   └── validation.js     # 驗證（不完整）
│   ├── models/
│   │   ├── User.js
│   │   └── Comment.js
│   ├── utils/
│   │   ├── database.js       # 資料庫工具（有 SQL Injection）
│   │   ├── logger.js         # 日誌（洩漏敏感資料）
│   │   └── sanitizer.js      # 清理工具（未使用）
│   └── config/
│       └── security.js       # 安全設定（配置不當）
└── tests/

Total: 45 files, 12,000 lines
Security debt: High
```

### 你的任務

1. **搜尋階段**：找出所有安全漏洞（30 分鐘）
2. **分類階段**：依嚴重程度分類（15 分鐘）
3. **修復階段**：系統化修復所有漏洞（30 分鐘）
4. **驗證階段**：確保修復有效（10 分鐘）
5. **記錄階段**：建立安全檢查清單（5 分鐘）

### 限制條件

- 時間緊迫：1.5 小時內完成所有 Critical 和 High 級別修復
- 不能破壞現有功能
- 必須通過安全掃描工具驗證
- 需要建立未來的預防機制

---

## 學習重點

1. **系統化安全掃描**
   - 如何搜尋常見漏洞模式？
   - 如何避免遺漏？

2. **漏洞優先級評估**
   - 如何判斷嚴重程度？
   - 如何規劃修復順序？

3. **安全修復模式**
   - 每種漏洞的標準修復方法
   - 如何確保修復完整？

4. **預防機制建立**
   - 如何防止未來再犯？
   - 如何建立安全檢查清單？

---

## 建議解決流程

### 階段一：系統化漏洞搜尋（30 分鐘）

**目標**：找出所有安全漏洞實例

**步驟**：

1. **搜尋 SQL Injection 漏洞**
```bash
# 搜尋字串拼接的 SQL 查詢
/grep "SELECT.*\+\|INSERT.*\+\|UPDATE.*\+\|DELETE.*\+" src/ --type js -i

# 搜尋字串模板的 SQL
/grep "SELECT.*\$\{.*\}\|INSERT.*\$\{.*\}" src/ --type js -i

# 搜尋 f-string 風格的 SQL（如果是 Python）
/grep "f\"SELECT.*\{.*\}\"" src/ --type py -i
```

**預期發現**：
```javascript
// src/routes/users.js
router.get('/search', async (req, res) => {
  const { name } = req.query;

  // ❌ SQL Injection 漏洞
  const query = `SELECT * FROM users WHERE name = '${name}'`;
  const users = await db.query(query);

  res.json(users);
});

// src/utils/database.js
async function findByEmail(email) {
  // ❌ SQL Injection
  return await db.query(`SELECT * FROM users WHERE email = '${email}'`);
}
```

2. **搜尋 XSS 漏洞**
```bash
# 搜尋直接插入 HTML 的模式
/grep "innerHTML.*=\|outerHTML.*=" src/ --type js

# 搜尋未轉義的用戶輸入
/grep "res\.send.*req\.\|res\.write.*req\." src/ --type js

# 搜尋 React 中的 dangerouslySetInnerHTML
/grep "dangerouslySetInnerHTML" src/ --type jsx
```

**預期發現**：
```javascript
// src/routes/comments.js
router.post('/comments', async (req, res) => {
  const { content } = req.body;

  // ❌ 沒有清理用戶輸入，直接儲存
  await Comment.create({ content });

  res.send('Comment added');
});

// 前端顯示時
// ❌ Stored XSS
document.getElementById('comments').innerHTML = comment.content;
```

3. **搜尋認證繞過漏洞**
```bash
# 搜尋權限檢查
/grep "isAdmin\|role.*===\|checkPermission" src/ --type js -i

# 搜尋認證中間件使用
/grep "auth\|authenticate\|requireAuth" src/routes/ --type js -i
```

**預期發現**：
```javascript
// src/routes/admin.js
// ❌ 沒有認證中間件
router.get('/admin/users', async (req, res) => {
  const users = await User.findAll();
  res.json(users);
});

// src/middleware/auth.js
function isAdmin(req, res, next) {
  // ❌ 可以輕易繞過（只檢查 header）
  if (req.headers['x-admin-token'] === 'admin123') {
    return next();
  }
  res.status(403).send('Forbidden');
}
```

4. **搜尋 IDOR（Insecure Direct Object References）**
```bash
# 搜尋直接使用 ID 參數的查詢
/grep "findById.*req\.params\|findOne.*req\.params" src/ --type js
```

**預期發現**：
```javascript
// src/routes/files.js
router.get('/files/:id', async (req, res) => {
  const { id } = req.params;

  // ❌ 沒有檢查檔案是否屬於當前用戶
  const file = await File.findById(id);
  res.download(file.path);
});
```

5. **搜尋敏感資料洩漏**
```bash
# 搜尋日誌中可能包含敏感資料
/grep "logger.*password\|logger.*token\|logger.*secret\|console\.log.*password" src/ --type js -i

# 搜尋錯誤訊息中的敏感資訊
/grep "error\.stack\|error\.message" src/ --type js
```

**預期發現**：
```javascript
// src/utils/logger.js
logger.info(`User login attempt: ${username}, password: ${password}`);
// ❌ 記錄明文密碼

// src/routes/auth.js
catch (error) {
  // ❌ 洩漏詳細錯誤資訊
  res.status(500).json({ error: error.stack });
}
```

6. **搜尋缺少 Rate Limiting**
```bash
# 搜尋敏感端點（登入、註冊等）
/grep "router\.post.*login\|router\.post.*register\|router\.post.*password" src/routes/ --type js -i
```

**預期發現**：
```javascript
// src/routes/auth.js
// ❌ 沒有 rate limiting，可以暴力破解
router.post('/login', async (req, res) => {
  const { username, password } = req.body;
  // ...
});
```

7. **建立完整漏洞清單**
```bash
請將所有發現的漏洞整理成結構化清單，包含：
- 漏洞類型
- 所在檔案和行號
- 嚴重程度（Critical/High/Medium）
- 影響範圍
- 修復建議
```

**Claude 產生的清單**：
```markdown
# Security Vulnerabilities Inventory

## 🔴 CRITICAL (Must Fix Immediately)

### C1: SQL Injection in User Search
**Location**: src/routes/users.js:15
**Code**:
```javascript
const query = `SELECT * FROM users WHERE name = '${name}'`;
```
**Impact**: 攻擊者可以：
- 讀取所有資料庫資料
- 修改或刪除資料
- 取得管理員權限

**Fix**: 使用參數化查詢
```javascript
const query = 'SELECT * FROM users WHERE name = ?';
const users = await db.query(query, [name]);
```

### C2: Stored XSS in Comments
**Location**: src/routes/comments.js:23, frontend/comments.jsx:45
**Impact**: 攻擊者可以：
- 竊取用戶 session cookies
- 執行任意 JavaScript
- 發起釣魚攻擊

**Fix**:
1. Server: 清理輸入
2. Client: 使用 textContent 而非 innerHTML

### C3: Authentication Bypass in Admin Panel
**Location**: src/routes/admin.js (entire file)
**Impact**: 任何人都可以存取管理功能
**Fix**: 添加認證和授權中間件

## 🟠 HIGH (Fix within 24 hours)

### H1: SQL Injection in Database Utility
**Location**: src/utils/database.js:34, 56, 78
**Count**: 3 instances
**Fix**: 全部改為參數化查詢

### H2: Sensitive Data in Logs
**Location**: src/utils/logger.js:12, 45
**Impact**: 密碼和 token 被記錄
**Fix**: 移除敏感欄位或遮蔽

### H3: Missing Rate Limiting
**Location**: src/routes/auth.js:15, 45, 67
**Endpoints**: /login, /register, /reset-password
**Impact**: 可暴力破解密碼
**Fix**: 添加 express-rate-limit

### H4: IDOR in File Download
**Location**: src/routes/files.js:23
**Impact**: 可下載其他用戶的檔案
**Fix**: 檢查檔案擁有者

### H5: Weak Password Policy
**Location**: src/routes/auth.js:34
**Current**: 無密碼強度檢查
**Fix**: 添加密碼強度驗證

## 📊 統計

- Total Vulnerabilities: 11
- Critical: 3
- High: 5
- Medium: 12 (未列出)

- Files Affected: 8
- Lines to Fix: ~45
```

**記憶沉澱**：
```bash
/memory save

主題：常見安全漏洞的搜尋模式

SQL Injection 搜尋：
- /grep "SELECT.*\+\|INSERT.*\+" (字串拼接)
- /grep "SELECT.*\$\{.*\}" (模板字串)
- /grep "query.*req\." (直接使用請求參數)

XSS 搜尋：
- /grep "innerHTML\|outerHTML" (直接 HTML 插入)
- /grep "dangerouslySetInnerHTML" (React)
- /grep "res\.send.*req\." (未轉義輸出)

認證問題搜尋：
- /grep "isAdmin\|checkPermission" (權限檢查)
- /grep "router\.\(get\|post\).*admin" (管理路由)
- 檢查是否有 middleware

IDOR 搜尋：
- /grep "findById.*req\.params" (直接使用 ID)
- /grep "File\.find.*req\.params" (資源存取)

敏感資料洩漏：
- /grep "logger.*password\|console\.log.*password"
- /grep "error\.stack\|error\.message"

Rate Limiting：
- /grep "router\.post.*login\|register" (敏感端點)
- 檢查是否有 rate-limit middleware

工具組合：
1. /grep 找漏洞模式
2. /read 理解上下文
3. 建立清單（Claude 幫忙）
4. /memory 記錄模式
```

**檢查點**：
- [ ] 找出所有 SQL Injection
- [ ] 找出所有 XSS
- [ ] 找出認證問題
- [ ] 找出 IDOR
- [ ] 找出敏感資料洩漏
- [ ] 找出缺少 Rate Limiting
- [ ] 建立完整漏洞清單
- [ ] 使用 /memory 記錄搜尋模式

---

### 階段二：漏洞分類與優先級（15 分鐘）

**目標**：評估嚴重程度並規劃修復順序

**步驟**：

1. **評估每個漏洞的嚴重程度**
```bash
請基於以下標準評估每個漏洞：

嚴重程度評估標準：
- CRITICAL: 可直接取得系統控制權、資料外洩、遠端代碼執行
- HIGH: 可繞過認證、存取他人資料、持久化攻擊
- MEDIUM: 資訊洩漏、DoS、需要特定條件的攻擊
- LOW: 影響有限、需要多步驟才能利用

請為每個漏洞評分並排序。
```

2. **規劃修復順序**
```markdown
# Remediation Plan

## Phase 1: Critical Fixes (30 minutes)
**Deadline**: Immediate

1. C3: Authentication Bypass → 影響最大，最容易修
2. C1: SQL Injection in Search → 可能已被利用
3. C2: Stored XSS → 影響所有用戶

## Phase 2: High Fixes (30 minutes)
**Deadline**: Within 24 hours

4. H1: SQL Injection in Utilities → 影響多個功能
5. H3: Missing Rate Limiting → 防止暴力破解
6. H2: Sensitive Data in Logs → 合規要求
7. H4: IDOR → 資料洩漏風險
8. H5: Weak Password Policy → 長期安全

## Phase 3: Medium Fixes (Follow-up)
**Deadline**: Within 1 week
(略)
```

**檢查點**：
- [ ] 所有漏洞已評分
- [ ] 修復順序已規劃
- [ ] 預估每個修復的時間

---

### 階段三：系統化修復（40 分鐘）

**目標**：逐一修復所有漏洞

**步驟**：

**修復 C3：Authentication Bypass（5 分鐘）**

```bash
/read src/routes/admin.js

# 請求修復
請在所有 admin 路由前添加認證和授權中間件。
```

**修復前**：
```javascript
// src/routes/admin.js
router.get('/admin/users', async (req, res) => {
  const users = await User.findAll();
  res.json(users);
});
```

**修復後**：
```javascript
// src/routes/admin.js
const { requireAuth, requireAdmin } = require('../middleware/auth');

// ✅ 添加中間件
router.use(requireAuth);
router.use(requireAdmin);

router.get('/admin/users', async (req, res) => {
  const users = await User.findAll();
  res.json(users);
});
```

---

**修復 C1：SQL Injection（10 分鐘）**

```bash
# 找出所有 SQL Injection
/grep "SELECT.*\$\{.*\}\|query.*\+" src/ --type js

# 逐一修復
/read src/routes/users.js
```

**修復前**：
```javascript
// ❌ SQL Injection
router.get('/search', async (req, res) => {
  const { name } = req.query;
  const query = `SELECT * FROM users WHERE name = '${name}'`;
  const users = await db.query(query);
  res.json(users);
});
```

**修復後**：
```javascript
// ✅ 參數化查詢
router.get('/search', async (req, res) => {
  const { name } = req.query;

  // 參數化查詢防止 SQL Injection
  const query = 'SELECT * FROM users WHERE name = ?';
  const users = await db.query(query, [name]);

  res.json(users);
});
```

**同時修復 H1（工具函數中的 SQL Injection）**：
```bash
/read src/utils/database.js
```

**修復前**：
```javascript
async function findByEmail(email) {
  return await db.query(`SELECT * FROM users WHERE email = '${email}'`);
}
```

**修復後**：
```javascript
async function findByEmail(email) {
  return await db.query('SELECT * FROM users WHERE email = ?', [email]);
}
```

---

**修復 C2：Stored XSS（10 分鐘）**

```bash
/read src/routes/comments.js
```

**修復後端（儲存時清理）**：
```javascript
// src/routes/comments.js
const sanitizeHtml = require('sanitize-html');

router.post('/comments', async (req, res) => {
  const { content } = req.body;

  // ✅ 清理 HTML，移除惡意腳本
  const sanitizedContent = sanitizeHtml(content, {
    allowedTags: ['b', 'i', 'em', 'strong', 'a'],
    allowedAttributes: {
      'a': ['href']
    }
  });

  await Comment.create({ content: sanitizedContent });
  res.send('Comment added');
});
```

**修復前端（顯示時轉義）**：
```javascript
// ❌ 危險
document.getElementById('comments').innerHTML = comment.content;

// ✅ 安全
document.getElementById('comments').textContent = comment.content;

// 或使用 React
// ✅ 預設會轉義
<div>{comment.content}</div>
```

---

**修復 H3：Missing Rate Limiting（5 分鐘）**

```bash
npm install express-rate-limit

# 請求修改
請在 auth 路由添加 rate limiting，限制：
- /login: 5 次/15分鐘
- /register: 3 次/小時
- /reset-password: 3 次/小時
```

**修復**：
```javascript
// src/routes/auth.js
const rateLimit = require('express-rate-limit');

// Login rate limiter
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests
  message: 'Too many login attempts, please try again later'
});

// Register rate limiter
const registerLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3,
  message: 'Too many registration attempts'
});

router.post('/login', loginLimiter, async (req, res) => {
  // ...
});

router.post('/register', registerLimiter, async (req, res) => {
  // ...
});
```

---

**修復 H2：Sensitive Data in Logs（5 分鐘）**

```bash
/read src/utils/logger.js
```

**修復前**：
```javascript
logger.info(`User login: ${username}, password: ${password}`);
// ❌ 記錄明文密碼
```

**修復後**：
```javascript
// ✅ 移除敏感欄位
logger.info(`User login attempt: ${username}`);

// 或建立安全的日誌函數
function sanitizeLogData(data) {
  const sensitive = ['password', 'token', 'secret', 'apiKey'];
  const sanitized = { ...data };

  sensitive.forEach(key => {
    if (sanitized[key]) {
      sanitized[key] = '***REDACTED***';
    }
  });

  return sanitized;
}

logger.info('User login', sanitizeLogData(req.body));
```

---

**修復 H4：IDOR（5 分鐘）**

```bash
/read src/routes/files.js
```

**修復前**：
```javascript
router.get('/files/:id', async (req, res) => {
  const { id } = req.params;
  const file = await File.findById(id);
  // ❌ 沒有檢查擁有者
  res.download(file.path);
});
```

**修復後**：
```javascript
router.get('/files/:id', requireAuth, async (req, res) => {
  const { id } = req.params;
  const file = await File.findById(id);

  // ✅ 檢查檔案是否屬於當前用戶
  if (file.userId !== req.user.id && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Access denied' });
  }

  res.download(file.path);
});
```

---

**修復 H5：Weak Password Policy（5 分鐘）**

```bash
npm install zxcvbn  # 密碼強度檢查

# 請求建立密碼驗證
請建立密碼強度驗證，要求：
- 至少 8 字元
- 包含大小寫字母
- 包含數字
- 包含特殊字元
- 不是常見弱密碼
```

**修復**：
```javascript
// src/middleware/validation.js
const zxcvbn = require('zxcvbn');

function validatePassword(password) {
  const errors = [];

  // 長度檢查
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }

  // 複雜度檢查
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain lowercase letters');
  }
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain uppercase letters');
  }
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain numbers');
  }
  if (!/[!@#$%^&*]/.test(password)) {
    errors.push('Password must contain special characters');
  }

  // 強度檢查（使用 zxcvbn）
  const strength = zxcvbn(password);
  if (strength.score < 3) {
    errors.push('Password is too weak');
  }

  return errors;
}

router.post('/register', (req, res, next) => {
  const { password } = req.body;
  const errors = validatePassword(password);

  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }

  next();
}, async (req, res) => {
  // 註冊邏輯
});
```

**檢查點**：
- [ ] C3 已修復（認證繞過）
- [ ] C1 和 H1 已修復（SQL Injection）
- [ ] C2 已修復（XSS）
- [ ] H3 已修復（Rate Limiting）
- [ ] H2 已修復（敏感資料日誌）
- [ ] H4 已修復（IDOR）
- [ ] H5 已修復（弱密碼）

---

### 階段四：驗證與測試（10 分鐘）

**目標**：確保所有修復有效

**步驟**：

1. **執行安全掃描工具**
```bash
# 安裝安全掃描工具
npm install --save-dev eslint-plugin-security

# 執行掃描
npm run lint:security

# 預期結果
✓ No security issues found
```

2. **執行單元測試**
```bash
npm test

# 預期結果
✓ All tests passing
```

3. **手動測試漏洞**
```bash
# 測試 SQL Injection 已修復
curl "http://localhost:3000/users/search?name=admin'%20OR%201=1--"
# 應該返回空或正常結果，而非所有用戶

# 測試 XSS 已修復
curl -X POST http://localhost:3000/comments \
  -H "Content-Type: application/json" \
  -d '{"content": "<script>alert(1)</script>"}'
# 檢查儲存的內容，應該被清理或轉義

# 測試 Rate Limiting
for i in {1..10}; do
  curl -X POST http://localhost:3000/login \
    -d "username=test&password=test"
done
# 第 6 次應該被限制
```

4. **使用 /grep 確認沒有遺漏**
```bash
# 再次搜尋危險模式
/grep "SELECT.*\$\{.*\}" src/ --type js
# 應該沒有結果（或只在註解中）

/grep "innerHTML.*=" src/ --type js
# 應該沒有結果或已經過清理
```

**檢查點**：
- [ ] 安全掃描通過
- [ ] 所有測試通過
- [ ] 手動測試確認修復
- [ ] /grep 確認無遺漏

---

### 階段五：建立安全檢查清單（5 分鐘）

**目標**：預防未來再犯

**步驟**：

1. **建立 SECURITY.md**
```bash
請建立 SECURITY.md 文件，記錄：
1. 常見安全漏洞檢查清單
2. 安全編碼規範
3. 提交前的安全檢查
4. 安全掃描工具使用
```

**產生的 SECURITY.md**：
```markdown
# Security Guidelines

## Pre-Commit Security Checklist

Before committing code, ensure:

### SQL Injection Prevention
- [ ] All database queries use parameterized queries
- [ ] No string concatenation in SQL
- [ ] No template literals in SQL
- [ ] Validate all user inputs

**Search**: `/grep "SELECT.*\$\{.*\}\|query.*\+" --type js`

### XSS Prevention
- [ ] All user inputs are sanitized
- [ ] Use `textContent` instead of `innerHTML`
- [ ] Avoid `dangerouslySetInnerHTML` in React
- [ ] Content Security Policy (CSP) headers set

**Search**: `/grep "innerHTML\|dangerouslySetInnerHTML" --type js`

### Authentication & Authorization
- [ ] All admin routes have auth middleware
- [ ] All sensitive endpoints have auth checks
- [ ] Token validation is secure
- [ ] Session management is proper

**Search**: `/grep "router\.\(get\|post\).*admin" --type js`

### Input Validation
- [ ] All inputs are validated
- [ ] File uploads are restricted
- [ ] Rate limiting on sensitive endpoints
- [ ] CORS is properly configured

### Sensitive Data
- [ ] No passwords/tokens in logs
- [ ] No sensitive data in error messages
- [ ] Secrets in environment variables
- [ ] Use HTTPS in production

**Search**: `/grep "logger.*password\|console\.log.*token" --type js`

### IDOR Prevention
- [ ] Check resource ownership before access
- [ ] Use UUIDs instead of sequential IDs
- [ ] Validate user permissions

**Search**: `/grep "findById.*req\.params" --type js`

## Automated Checks

Run before every commit:
```bash
npm run lint:security
npm run test:security
```

## Security Scanning Tools

- **ESLint Security**: `eslint-plugin-security`
- **Dependency Check**: `npm audit`
- **SAST**: `snyk test`

## Incident Response

If security issue found:
1. Assess severity (use CVSS)
2. Fix immediately if Critical/High
3. Update this checklist
4. Notify security team
```

2. **建立 Git Pre-commit Hook**
```bash
# .husky/pre-commit
#!/bin/sh

echo "🔒 Running security checks..."

# ESLint security check
npm run lint:security || {
  echo "❌ Security lint failed!"
  exit 1
}

# Check for common patterns
echo "🔍 Checking for dangerous patterns..."

if git diff --cached --name-only | grep -E '\.(js|ts|jsx|tsx)$' | xargs grep -n "\$\{.*SELECT\|INSERT.*+"; then
  echo "❌ Found potential SQL injection!"
  exit 1
fi

echo "✅ Security checks passed!"
```

**最終記憶沉澱**：
```bash
/memory save

主題：系統化安全漏洞修復流程

5 階段修復流程：

階段1️⃣：系統化搜尋（30 min）
- SQL Injection: /grep "SELECT.*\$\{.*\}"
- XSS: /grep "innerHTML\|dangerouslySetInnerHTML"
- Auth: /grep "router.*admin" + 檢查 middleware
- IDOR: /grep "findById.*req\.params"
- 敏感資料: /grep "logger.*password"
- Rate Limit: /grep "router\.post.*login"
- 建立完整清單

階段2️⃣：分類優先級（15 min）
- Critical: 直接控制權、資料外洩
- High: 認證繞過、IDOR、持久化攻擊
- Medium: 資訊洩漏、DoS
- 規劃修復順序

階段3️⃣：系統化修復（40 min）
- SQL Injection → 參數化查詢
- XSS → sanitize-html + textContent
- Auth Bypass → 添加 middleware
- IDOR → 檢查擁有者
- Rate Limiting → express-rate-limit
- 敏感日誌 → 移除或遮蔽
- 弱密碼 → 強度驗證

階段4️⃣：驗證測試（10 min）
- 安全掃描工具
- 單元測試
- 手動滲透測試
- /grep 確認無遺漏

階段5️⃣：預防機制（5 min）
- 建立 SECURITY.md
- 建立檢查清單
- 建立 pre-commit hook
- 記錄到 /memory

修復模式速查：

SQL Injection:
❌ `SELECT * FROM users WHERE id = '${id}'`
✅ db.query('SELECT * FROM users WHERE id = ?', [id])

XSS:
❌ element.innerHTML = userInput
✅ element.textContent = userInput

Auth Bypass:
❌ router.get('/admin', handler)
✅ router.get('/admin', requireAuth, requireAdmin, handler)

IDOR:
❌ const file = await File.findById(req.params.id)
✅ if (file.userId !== req.user.id) return 403

Rate Limiting:
✅ const limiter = rateLimit({ windowMs: 15*60*1000, max: 5 })

總時間：1.5 小時
修復漏洞：11 個（3 Critical + 5 High + 3 Medium）
```

**檢查點**：
- [ ] SECURITY.md 已建立
- [ ] Pre-commit hook 已設定
- [ ] 安全檢查清單已建立
- [ ] 使用 /memory 記錄流程

---

## 驗證標準

### 必須達成 ✅

- [ ] 使用 /grep 找出所有安全漏洞
- [ ] 所有 Critical 和 High 漏洞已修復
- [ ] 建立完整漏洞清單並分類
- [ ] 所有修復經過測試驗證
- [ ] 安全掃描工具檢查通過
- [ ] 建立 SECURITY.md 文檔
- [ ] 建立 pre-commit hook
- [ ] 使用 /memory 記錄修復模式

### 額外成就 🌟

- [ ] 修復所有 Medium 級別漏洞
- [ ] 建立自動化安全測試
- [ ] 整合 SAST 工具到 CI/CD
- [ ] 建立安全培訓材料
- [ ] 實作 Content Security Policy
- [ ] 建立漏洞賞金計劃
- [ ] 完成時間少於 1.5 小時

---

## 學習反思

### 反思問題

1. **搜尋策略**：
   - 哪些漏洞類型最容易遺漏？為什麼？
   - 如何系統化地搜尋所有漏洞類型？
   - /grep 的搜尋模式如何優化？

2. **優先級評估**：
   - 如何判斷漏洞的嚴重程度？
   - 修復順序如何影響整體效率？
   - 如何平衡速度與完整性？

3. **修復模式**：
   - 每種漏洞的標準修復方法是什麼？
   - 如何確保修復不引入新問題？
   - 如何在修復和功能之間平衡？

4. **預防機制**：
   - 如何防止未來再犯相同錯誤？
   - 自動化檢查的價值？
   - 團隊培訓的重要性？

### 延伸練習

1. **深入學習**：
   - 學習 OWASP Top 10
   - 練習滲透測試
   - 獲得安全認證（如 CEH）

2. **自動化工具**：
   - 整合 Snyk 到 CI/CD
   - 建立自動化安全測試
   - 建立安全儀表板

3. **流程改進**：
   - 建立安全開發生命週期（SDL）
   - 建立威脅建模流程
   - 定期安全審計

4. **知識分享**：
   - 整理成「安全修復手冊」
   - 舉辦團隊安全培訓
   - 建立安全知識庫

---

## 相關資源

### 下一步學習

- **模組 7：安全設計與實踐** - 深入學習安全架構
- **模組 9：DevSecOps** - 將安全整合到 CI/CD
- **OWASP Top 10** - 必讀的安全指南

### 工具參考

- **Static Analysis**:
  - ESLint Security Plugin
  - Snyk
  - SonarQube
  - Bandit (Python)

- **Dynamic Analysis**:
  - OWASP ZAP
  - Burp Suite
  - SQLMap

- **Dependency Scanning**:
  - npm audit
  - Snyk
  - Dependabot

### 學習資源

- **OWASP Top 10** (https://owasp.org/www-project-top-ten/)
- **PortSwigger Web Security Academy** (https://portswigger.net/web-security)
- **HackerOne Reports** - 真實漏洞案例
- **SANS Security Training**

### 相關概念

- **Defense in Depth** - 深度防禦
- **Principle of Least Privilege** - 最小權限原則
- **Secure by Default** - 預設安全
- **Fail Securely** - 安全失敗
- **Zero Trust** - 零信任架構

---

**建議完成時間**：1.5-2 小時（含驗證與預防）
**難度評估**：4/5
**重要度**：5/5（安全是不可妥協的）
**可複用性**：5/5（安全檢查清單可應用到所有專案）
