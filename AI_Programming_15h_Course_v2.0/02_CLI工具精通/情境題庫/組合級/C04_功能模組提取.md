# C04：功能模組提取（組合級）

## 情境資訊

**編號**：C04
**難度**：⭐⭐⭐⭐☆（組合級）
**預計時間**：2 小時
**學習目標**：
- 掌握從單體應用提取模組的系統化方法
- 熟練使用 /glob 和 /grep 識別模組邊界
- 學會使用 /read 分析依賴關係
- 理解如何使用 CLAUDE.md 記錄重構模式
- 建立安全的模組提取流程

**適用對象**：
- 完成模組 2 基礎理論
- 有重構經驗
- 需要處理微服務拆分的開發者

---

## 情境描述

### 背景

你的公司運營一個電商平台，最初是個簡單的 Node.js 單體應用。經過 3 年發展，程式碼已經變得龐大且難以維護：

```
Current Problems:
- 120,000 lines of code in one repo
- 25 developers working on same codebase
- Deployment takes 45 minutes
- One bug in checkout can break entire site
- Payment processing coupled with everything
```

技術主管決定將支付處理模組提取成獨立的微服務。你被分配到這個任務。

### 現有架構

```
monolith-app/
├── src/
│   ├── routes/
│   │   ├── products.js       # 產品路由
│   │   ├── orders.js         # 訂單路由（使用支付）
│   │   ├── users.js          # 用戶路由
│   │   ├── payments.js       # 支付路由（要提取）
│   │   └── admin.js          # 管理後台（使用支付）
│   ├── services/
│   │   ├── ProductService.js
│   │   ├── OrderService.js   # 依賴支付
│   │   ├── PaymentService.js # 要提取
│   │   ├── RefundService.js  # 要提取
│   │   ├── UserService.js
│   │   └── NotificationService.js  # 依賴支付
│   ├── models/
│   │   ├── Product.js
│   │   ├── Order.js          # 包含支付資料
│   │   ├── Payment.js        # 要提取
│   │   ├── Refund.js         # 要提取
│   │   └── User.js
│   ├── utils/
│   │   ├── validators.js     # 包含支付驗證
│   │   ├── formatters.js     # 包含支付格式化
│   │   └── encryption.js     # 支付加密（要提取）
│   ├── middleware/
│   │   ├── auth.js
│   │   ├── payment-validation.js  # 要提取
│   │   └── rate-limit.js
│   └── database/
│       ├── migrations/       # 包含支付相關表
│       └── seeders/
└── tests/

Total: 287 files, 120,000 lines
```

### 目標架構

```
# 提取後

## Monolith (主應用)
monolith-app/
└── src/
    ├── routes/
    │   ├── products.js
    │   ├── orders.js       # 改為呼叫 Payment Service API
    │   └── users.js
    ├── services/
    │   ├── OrderService.js # 移除支付邏輯，改呼叫 API
    │   └── ...
    └── clients/
        └── PaymentClient.js  # 新增：呼叫 Payment Service

## Payment Service (新微服務)
payment-service/
└── src/
    ├── routes/
    │   └── payments.js      # 從 monolith 移動過來
    ├── services/
    │   ├── PaymentService.js
    │   └── RefundService.js
    ├── models/
    │   ├── Payment.js
    │   └── Refund.js
    ├── utils/
    │   ├── payment-validators.js
    │   └── encryption.js
    └── database/
        └── migrations/
```

### 你的任務

1. **識別邊界**：找出所有與支付相關的程式碼
2. **分析依賴**：理解支付模組與其他模組的依賴關係
3. **提取程式碼**：將支付相關程式碼移到新專案
4. **建立 API 層**：在單體應用中建立 Payment Client
5. **測試驗證**：確保功能不受影響

### 限制條件

- 不能破壞現有功能
- 需要支援逐步遷移（單體和微服務共存）
- 資料庫遷移需要零停機
- 必須保持向後兼容
- 需要完整的依賴分析

---

## 學習重點

1. **模組邊界識別**
   - 如何找出所有相關檔案？
   - 如何識別隱藏的依賴？

2. **依賴關係分析**
   - 如何繪製依賴圖？
   - 如何處理循環依賴？

3. **安全提取策略**
   - 如何確保不遺漏？
   - 如何支援逐步遷移？

4. **知識沉澱**
   - 如何記錄提取模式？
   - 如何讓下次提取更容易？

---

## 建議解決流程

### 階段一：全面掃描與邊界識別（30 分鐘）

**目標**：找出所有與支付相關的檔案和程式碼

**步驟**：

1. **搜尋支付相關的檔案**
```bash
# 搜尋檔案名稱包含 payment 的檔案
/glob "**/*payment*.js"
/glob "**/*refund*.js"

# 預期結果
Found:
- src/routes/payments.js
- src/services/PaymentService.js
- src/services/RefundService.js
- src/models/Payment.js
- src/models/Refund.js
- src/middleware/payment-validation.js
- tests/payment.test.js
- tests/refund.test.js
```

2. **搜尋程式碼中使用支付的地方**
```bash
# 搜尋 import/require PaymentService
/grep "PaymentService" --type js

# 搜尋支付相關的方法呼叫
/grep "\.charge\|\.refund\|\.processPayment" src/ --type js -i

# 搜尋支付相關的資料庫查詢
/grep "payments\.|Payment\.find" src/ --type js -i
```

**預期發現**：
```
Imports of PaymentService found in:
- src/services/OrderService.js (5 uses)
- src/routes/orders.js (2 uses)
- src/routes/admin.js (3 uses)
- src/services/NotificationService.js (1 use)

Database queries found in:
- src/services/OrderService.js
- src/routes/admin.js
- src/services/AnalyticsService.js
```

3. **建立初步清單**
```bash
# 請 Claude 整理成結構化清單
請將搜尋結果整理成以下格式：

1. 核心支付檔案（要完整移動）
   - routes/
   - services/
   - models/
   - middleware/

2. 部分支付邏輯（需要重構）
   - OrderService.js（使用 PaymentService）
   - NotificationService.js（監聽支付事件）

3. 工具函數（需要判斷）
   - validators.js（可能包含支付和其他驗證）
   - formatters.js（可能包含支付和其他格式化）
   - encryption.js（專門用於支付，應該移動）

4. 資料庫相關
   - migrations/（需要分析哪些屬於支付）
   - seeders/
```

**Claude 產生的清單**：
```markdown
# 支付模組提取清單

## 🔴 Tier 1：核心支付檔案（100% 移動）

### Routes (2 files)
- [ ] src/routes/payments.js (347 lines)
- [ ] src/routes/refunds.js (189 lines)

### Services (3 files)
- [ ] src/services/PaymentService.js (562 lines)
  - Dependencies: PaymentGateway, encryption, validators
- [ ] src/services/RefundService.js (234 lines)
  - Dependencies: PaymentService
- [ ] src/services/PaymentGateway.js (421 lines)
  - External: Stripe API

### Models (2 files)
- [ ] src/models/Payment.js (156 lines)
- [ ] src/models/Refund.js (98 lines)

### Middleware (1 file)
- [ ] src/middleware/payment-validation.js (134 lines)

### Utils (1 file)
- [ ] src/utils/encryption.js (78 lines) - 只用於支付

**小計：9 files, ~2,219 lines**

## 🟡 Tier 2：部分依賴檔案（需要重構）

### 依賴支付的服務
- [ ] src/services/OrderService.js
  - 依賴：PaymentService.charge() (5 calls)
  - 動作：改為呼叫 Payment API

- [ ] src/services/NotificationService.js
  - 依賴：監聽支付事件
  - 動作：改為監聽 Payment Service webhook

- [ ] src/routes/orders.js
  - 依賴：直接呼叫 PaymentService (2 calls)
  - 動作：改為使用 OrderService（已經會呼叫 Payment API）

- [ ] src/routes/admin.js
  - 依賴：讀取支付統計 (3 queries)
  - 動作：改為呼叫 Payment API

### 混合工具函數
- [ ] src/utils/validators.js
  - 包含：支付驗證 + 其他驗證
  - 動作：提取支付驗證到 payment-service，保留其他

- [ ] src/utils/formatters.js
  - 包含：金額格式化 + 其他格式化
  - 動作：提取金額格式化到 payment-service，保留其他

**小計：6 files, 部分修改**

## 🟢 Tier 3：資料庫相關

### Migrations
- [ ] 20230101_create_payments_table.js (移動)
- [ ] 20230115_create_refunds_table.js (移動)
- [ ] 20230302_add_order_payment_relation.js (需要分析)

### Seeders
- [ ] payments.seed.js (移動)

## 📊 統計

- 完整移動：9 files, 2,219 lines
- 部分修改：6 files
- 資料庫：4 migrations, 1 seeder
- 總影響：19 files
```

4. **記錄到 CLAUDE.md**
```bash
# 建立專案專屬的 CLAUDE.md
請幫我建立 CLAUDE.md，記錄支付模組的邊界定義和提取策略。
```

**產生的 CLAUDE.md**：
```markdown
# Payment Module Extraction Guide

## Module Boundary Definition

### What belongs to Payment Service?
- All payment processing logic
- Refund processing
- Payment gateway integrations (Stripe, PayPal)
- Payment-specific validations and encryption
- Payment and Refund models

### What stays in Monolith?
- Order management (calls Payment API)
- User management
- Product catalog
- General-purpose utilities (non-payment validators, formatters)

### Gray Areas (Requires Discussion)
- Payment-related analytics (read-only queries)
- Notification for payment events (webhook?)

## Extraction Strategy

1. Phase 1: Create Payment Service skeleton
2. Phase 2: Move core files (Tier 1)
3. Phase 3: Refactor dependent files (Tier 2)
4. Phase 4: Database migration
5. Phase 5: Gradual traffic cutover

## Dependencies Map

```
PaymentService
  ├─ Used by: OrderService (charge on order creation)
  ├─ Used by: RefundService (charge reversals)
  ├─ Used by: NotificationService (payment events)
  └─ Used by: Admin routes (payment analytics)

  Dependencies:
  ├─ PaymentGateway → Stripe API (external)
  ├─ encryption utility
  └─ payment validators
```

## API Contract

### Endpoints to expose
- POST /api/payments
- POST /api/refunds
- GET /api/payments/:id
- GET /api/payments/orders/:orderId

### Webhooks
- POST /webhooks/payment-completed
- POST /webhooks/payment-failed
- POST /webhooks/refund-processed
```

**自然學到的方法**：
- 為什麼要分層（Tier 1/2/3）？因為可以規劃優先級
- 為什麼要統計行數？因為可以估算工作量
- 為什麼寫 CLAUDE.md？因為可以讓 AI 理解專案脈絡

**檢查點**：
- [ ] 找出所有核心支付檔案（Tier 1）
- [ ] 識別所有依賴（Tier 2）
- [ ] 分析資料庫影響（Tier 3）
- [ ] 建立完整清單
- [ ] 建立 CLAUDE.md 記錄邊界

---

### 階段二：依賴關係深入分析（30 分鐘）

**目標**：理解每個依賴的具體細節，避免遺漏

**步驟**：

1. **分析 OrderService 的依賴**
```bash
/read src/services/OrderService.js
```

**發現的依賴**：
```javascript
// src/services/OrderService.js

const PaymentService = require('./PaymentService');

class OrderService {
  async createOrder(userId, items) {
    // 1. 建立訂單記錄
    const order = await Order.create({ userId, items, status: 'pending' });

    try {
      // 2. 呼叫支付服務（❌ 緊耦合）
      const payment = await PaymentService.charge({
        orderId: order.id,
        amount: order.total,
        userId: userId
      });

      // 3. 更新訂單狀態
      order.paymentId = payment.id;
      order.status = 'paid';
      await order.save();

      return order;
    } catch (error) {
      // 4. 支付失敗處理
      order.status = 'payment_failed';
      await order.save();
      throw error;
    }
  }

  async getOrderWithPayment(orderId) {
    const order = await Order.findById(orderId);

    // ❌ 直接查詢支付資料
    const payment = await Payment.findOne({ orderId });

    return { ...order, payment };
  }
}
```

**分析**：
```bash
# 請 Claude 分析並建議重構方案
這個 OrderService 如何依賴 PaymentService？
提供重構建議，使其通過 API 呼叫而非直接依賴。
```

**Claude 的重構建議**：
```javascript
// 重構後的 OrderService

const PaymentClient = require('../clients/PaymentClient');

class OrderService {
  constructor(paymentClient = new PaymentClient()) {
    this.paymentClient = paymentClient;
  }

  async createOrder(userId, items) {
    const order = await Order.create({ userId, items, status: 'pending' });

    try {
      // ✅ 通過 API 呼叫
      const payment = await this.paymentClient.charge({
        orderId: order.id,
        amount: order.total,
        userId: userId
      });

      order.paymentId = payment.id;
      order.status = 'paid';
      await order.save();

      return order;
    } catch (error) {
      order.status = 'payment_failed';
      await order.save();
      throw error;
    }
  }

  async getOrderWithPayment(orderId) {
    const order = await Order.findById(orderId);

    // ✅ 通過 API 取得支付資料
    const payment = await this.paymentClient.getPayment(order.paymentId);

    return { ...order, payment };
  }
}
```

2. **分析工具函數的混合使用**
```bash
/read src/utils/validators.js
```

**發現**：
```javascript
// src/utils/validators.js（混合）

module.exports = {
  // 支付相關（要提取）
  validateCardNumber: (cardNumber) => { ... },
  validateCVV: (cvv) => { ... },
  validateAmount: (amount) => { ... },

  // 一般驗證（保留）
  validateEmail: (email) => { ... },
  validatePhone: (phone) => { ... },
  validatePostalCode: (code) => { ... }
};
```

**重構策略**：
```bash
# 請 Claude 建議如何分離
這個檔案包含支付和一般驗證，如何分離？
```

**Claude 的建議**：
```javascript
// monolith-app/src/utils/validators.js（保留一般驗證）
module.exports = {
  validateEmail: (email) => { ... },
  validatePhone: (phone) => { ... },
  validatePostalCode: (code) => { ... }
};

// payment-service/src/utils/validators.js（支付驗證）
module.exports = {
  validateCardNumber: (cardNumber) => { ... },
  validateCVV: (cvv) => { ... },
  validateAmount: (amount) => { ... }
};
```

3. **搜尋隱藏的依賴**
```bash
# 搜尋可能被忽略的依賴

# 搜尋事件監聽
/grep "payment.*event\|on.*payment" src/ --type js -i

# 搜尋直接的資料庫查詢
/grep "Payment\.find\|payments\." src/ --type js -i

# 搜尋配置依賴
/grep "STRIPE\|PAYMENT" --type js -i
```

**可能發現的隱藏依賴**：
```javascript
// src/services/AnalyticsService.js（容易遺漏）
class AnalyticsService {
  async getRevenue() {
    // ❌ 直接查詢支付表
    return await Payment.aggregate([
      { $group: { _id: null, total: { $sum: '$amount' } } }
    ]);
  }
}

// src/config/stripe.js（配置）
module.exports = {
  apiKey: process.env.STRIPE_API_KEY,  // 要移到 payment-service
  webhook: process.env.STRIPE_WEBHOOK_SECRET
};

// src/jobs/reconciliation.js（排程任務）
// 每日對帳任務，直接讀取支付資料
```

4. **繪製完整依賴圖**
```bash
請基於以上分析，繪製完整的依賴關係圖，包括：
1. PaymentService 被誰使用
2. PaymentService 使用了什麼
3. 隱藏依賴
4. 需要建立的新 API
```

**Claude 產生的依賴圖**：
```
┌─────────────────────────────────────────────────────┐
│              Monolith Dependencies                   │
└─────────────────────────────────────────────────────┘

OrderService ──────┐
                   │
NotificationService│──── PaymentService ──── PaymentGateway ──── Stripe API
                   │           │                    (external)
Admin Routes ──────┘           ├─── Payment Model
                               ├─── encryption utils
AnalyticsService ──────────────┤
                               └─── payment validators
Reconciliation Job ────────────┘

┌─────────────────────────────────────────────────────┐
│        After Extraction (Target State)               │
└─────────────────────────────────────────────────────┘

                    ┌──────────────────────┐
OrderService        │  Payment Service API │
NotificationService │                      │
Admin Routes    ────┤  GET /payments/:id   │
AnalyticsService    │  POST /payments      │
Reconciliation  ────┤  POST /refunds       │
                    │  GET /analytics      │
                    └──────────────────────┘
                              │
                    ┌─────────▼─────────┐
                    │ Payment Service   │
                    │ (Microservice)    │
                    │                   │
                    │ - PaymentService  │
                    │ - RefundService   │
                    │ - Models          │
                    │ - Validators      │
                    └───────────────────┘
```

**記憶沉澱**：
```bash
/memory save

主題：模組提取依賴分析方法

三層依賴搜尋策略：

1️⃣ 明顯依賴（容易找）
- import/require 語句
- 直接方法呼叫
- /grep "PaymentService" 即可找到

2️⃣ 資料層依賴（常被忽略）
- 直接的資料庫查詢（Payment.find）
- ORM 關聯（order.payment）
- 資料庫 JOIN
- /grep "Payment\.find\|payments\." 搜尋

3️⃣ 隱藏依賴（最容易遺漏）
- 事件監聽（payment.on('charged')）
- 排程任務（cron jobs）
- 配置依賴（STRIPE_API_KEY）
- 分析報表（直接查詢）
- /grep "payment.*event\|PAYMENT" 搜尋

重構模式：
- 直接呼叫 → API 呼叫（PaymentClient）
- 直接查詢 → API 端點
- 混合工具函數 → 分離到各服務
- 事件監聽 → Webhook

工具組合：
- /glob：找檔案
- /grep：找程式碼引用
- /read：理解邏輯
- CLAUDE.md：記錄邊界定義
```

**檢查點**：
- [ ] 分析所有服務層依賴
- [ ] 識別混合工具函數
- [ ] 發現隱藏依賴
- [ ] 繪製完整依賴圖
- [ ] 使用 /memory 記錄方法

---

### 階段三：建立 Payment Service 骨架（20 分鐘）

**目標**：建立新的微服務專案結構

**步驟**：

1. **建立專案結構**
```bash
mkdir payment-service
cd payment-service

# 請 Claude 幫忙建立標準 Node.js 微服務結構
請建立一個標準的 Express.js 微服務結構，包含：
- src/ (routes, services, models, utils, middleware)
- tests/
- config/
- package.json
- Dockerfile
- README.md
```

2. **移動核心檔案**
```bash
# 複製（不是移動，先保持雙份）核心支付檔案

# Routes
cp ../monolith-app/src/routes/payments.js ./src/routes/
cp ../monolith-app/src/routes/refunds.js ./src/routes/

# Services
cp ../monolith-app/src/services/PaymentService.js ./src/services/
cp ../monolith-app/src/services/RefundService.js ./src/services/
cp ../monolith-app/src/services/PaymentGateway.js ./src/services/

# Models
cp ../monolith-app/src/models/Payment.js ./src/models/
cp ../monolith-app/src/models/Refund.js ./src/models/

# Utils
cp ../monolith-app/src/utils/encryption.js ./src/utils/
# 從 validators.js 提取支付驗證（手動）

# Middleware
cp ../monolith-app/src/middleware/payment-validation.js ./src/middleware/
```

3. **修復引用路徑**
```bash
# 在 payment-service 中，修復所有 import 路徑
/grep "require\(.*\.\./\.\./\)" src/ --type js

# 請 Claude 幫忙修復
請修復所有 require 路徑，因為檔案結構改變了。
```

4. **建立 API 端點**
```bash
/read src/routes/payments.js

# 請求修改
請將這個 Express route 改造成 RESTful API，並添加：
1. API 版本前綴 (/api/v1)
2. 適當的錯誤處理
3. 請求驗證
4. 回應格式標準化
```

**檢查點**：
- [ ] Payment Service 專案結構建立
- [ ] 核心檔案已複製
- [ ] 引用路徑已修復
- [ ] API 端點已建立

---

### 階段四：建立 API Client 層（20 分鐘）

**目標**：在單體應用中建立 Payment API 客戶端

**步驟**：

1. **建立 PaymentClient**
```bash
# 在 monolith-app 中建立
# monolith-app/src/clients/PaymentClient.js

請建立一個 PaymentClient 類別，封裝所有對 Payment Service 的 HTTP 呼叫。

方法需要包含：
- charge(data): 建立支付
- refund(paymentId, amount): 退款
- getPayment(paymentId): 取得支付資訊
- getPaymentsByOrder(orderId): 取得訂單的所有支付

使用 axios 或 fetch，包含：
- 錯誤處理
- Retry 機制
- Timeout 設定
- 日誌記錄
```

**產生的 PaymentClient**：
```javascript
// monolith-app/src/clients/PaymentClient.js

const axios = require('axios');
const logger = require('../utils/logger');

class PaymentClient {
  constructor() {
    this.baseURL = process.env.PAYMENT_SERVICE_URL || 'http://localhost:3001';
    this.timeout = 5000;
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  async charge(data) {
    try {
      logger.info(`Charging payment for order ${data.orderId}`);

      const response = await this.client.post('/api/v1/payments', data);
      return response.data;
    } catch (error) {
      logger.error(`Payment charge failed: ${error.message}`);
      throw new Error(`Payment service error: ${error.message}`);
    }
  }

  async refund(paymentId, amount) {
    try {
      const response = await this.client.post('/api/v1/refunds', {
        paymentId,
        amount
      });
      return response.data;
    } catch (error) {
      logger.error(`Refund failed: ${error.message}`);
      throw error;
    }
  }

  async getPayment(paymentId) {
    try {
      const response = await this.client.get(`/api/v1/payments/${paymentId}`);
      return response.data;
    } catch (error) {
      logger.error(`Get payment failed: ${error.message}`);
      throw error;
    }
  }

  async getPaymentsByOrder(orderId) {
    try {
      const response = await this.client.get('/api/v1/payments', {
        params: { orderId }
      });
      return response.data;
    } catch (error) {
      logger.error(`Get payments by order failed: ${error.message}`);
      throw error;
    }
  }
}

module.exports = PaymentClient;
```

2. **重構 OrderService 使用 PaymentClient**
```bash
/read src/services/OrderService.js

# 請求重構
請將這個 OrderService 重構，改為使用 PaymentClient 而非直接依賴 PaymentService。
```

**檢查點**：
- [ ] PaymentClient 已建立
- [ ] 包含所有必要方法
- [ ] 包含錯誤處理和 retry
- [ ] OrderService 已重構使用 PaymentClient

---

### 階段五：測試與驗證（20 分鐘）

**目標**：確保兩種模式都能正常運作

**步驟**：

1. **測試 Payment Service 獨立運作**
```bash
cd payment-service
npm install
npm test

# 啟動服務
npm start

# 測試 API
curl -X POST http://localhost:3001/api/v1/payments \
  -H "Content-Type: application/json" \
  -d '{
    "orderId": "ORD-123",
    "amount": 99.99,
    "userId": "user-456"
  }'
```

2. **測試單體應用呼叫 Payment Service**
```bash
cd ../monolith-app

# 設定環境變數
export PAYMENT_SERVICE_URL=http://localhost:3001

# 執行測試
npm test -- OrderService

# 手動測試建立訂單
npm start
# 建立訂單，確認支付流程正常
```

3. **驗證沒有遺漏**
```bash
# 確認單體應用不再直接依賴 PaymentService
/grep "require.*PaymentService" src/ --type js

# 應該只找到 PaymentClient，不應有 PaymentService（除了註解）
```

4. **建立遷移檢查清單**
```bash
請建立一個檢查清單，確保提取完成且沒有遺漏。
```

**產生的檢查清單**：
```markdown
# Payment Module Extraction Checklist

## Phase 1: Preparation ✅
- [x] Identify all payment-related files
- [x] Analyze dependencies
- [x] Create dependency graph
- [x] Document module boundary in CLAUDE.md

## Phase 2: Payment Service Setup ✅
- [x] Create payment-service project
- [x] Copy core files (routes, services, models)
- [x] Fix import paths
- [x] Create API endpoints
- [x] Write tests

## Phase 3: Monolith Refactoring ✅
- [x] Create PaymentClient
- [x] Refactor OrderService
- [x] Refactor Admin routes
- [x] Refactor NotificationService
- [x] Update tests

## Phase 4: Validation
- [ ] Payment Service tests passing
- [ ] Monolith tests passing
- [ ] Integration tests passing
- [ ] No direct PaymentService imports in monolith
- [ ] All payment operations work through API

## Phase 5: Deployment (Future)
- [ ] Database migration strategy
- [ ] Gradual traffic cutover plan
- [ ] Rollback plan
- [ ] Monitoring and alerts
```

**最終記憶沉澱**：
```bash
/memory save

主題：功能模組提取完整流程（單體 → 微服務）

5 階段提取流程：

階段1️⃣：邊界識別（30 min）
- /glob 找所有相關檔案
- /grep 找所有引用
- 分層（Tier 1/2/3）
- 建立 CLAUDE.md 記錄邊界
- 工具：/glob, /grep, CLAUDE.md

階段2️⃣：依賴分析（30 min）
- 分析每個依賴細節
- 識別混合工具函數
- 發現隱藏依賴（事件、任務、配置）
- 繪製依賴圖
- 工具：/read, /grep, /memory

階段3️⃣：建立新服務（20 min）
- 建立專案結構
- 複製核心檔案（保留雙份）
- 修復引用路徑
- 建立 API 端點

階段4️⃣：建立 Client 層（20 min）
- 建立 API Client 類別
- 重構依賴服務改用 Client
- 移除直接依賴

階段5️⃣：測試驗證（20 min）
- 測試新服務獨立運作
- 測試單體呼叫新服務
- /grep 確認無遺漏
- 建立檢查清單

關鍵成功因素：
- 完整的依賴分析（避免遺漏）
- 保留雙份程式碼（先不刪除）
- API Client 封裝（隔離變更）
- 充分測試（確保不破壞）
- 使用 CLAUDE.md 記錄邊界

常見陷阱：
- 忽略資料層依賴
- 忽略隱藏依賴（事件、任務）
- 過早刪除舊程式碼
- 沒有 API Client 封裝

總時間：2 小時
提取規模：9 核心檔案 + 6 重構檔案
```

**檢查點**：
- [ ] Payment Service 獨立運作正常
- [ ] 單體應用通過 API 呼叫正常
- [ ] 所有測試通過
- [ ] 無直接依賴遺留
- [ ] 使用 /memory 記錄流程

---

## 驗證標準

### 必須達成 ✅

- [ ] 使用 /glob 和 /grep 找出所有相關檔案
- [ ] 識別 Tier 1/2/3 檔案並分類
- [ ] 分析所有依賴關係（包括隱藏依賴）
- [ ] 建立 CLAUDE.md 記錄模組邊界
- [ ] Payment Service 獨立運作
- [ ] 建立 PaymentClient 封裝 API 呼叫
- [ ] 重構所有依賴服務
- [ ] 所有測試通過
- [ ] 無直接 PaymentService 引用遺留
- [ ] 使用 /memory 記錄提取流程

### 額外成就 🌟

- [ ] 建立自動化腳本掃描依賴
- [ ] 實作 Circuit Breaker 模式
- [ ] 添加 API 版本控制
- [ ] 建立完整的 API 文檔
- [ ] 實作資料庫遷移策略
- [ ] 建立流量逐步切換機制
- [ ] 整理成團隊的「模組提取 SOP」

---

## 學習反思

### 反思問題

1. **邊界識別**：
   - 如何判斷一個檔案是否屬於支付模組？
   - 混合工具函數如何處理最合適？
   - 如何確保邊界定義清晰？

2. **依賴分析**：
   - 哪些依賴最容易遺漏？為什麼？
   - 如何系統化地發現隱藏依賴？
   - 循環依賴如何處理？

3. **提取策略**：
   - 為什麼先複製而非移動？
   - API Client 的價值是什麼？
   - 如何平衡速度與完整性？

4. **測試驗證**：
   - 如何確保沒有遺漏？
   - 如何測試兩種模式共存？
   - 回滾計劃重要嗎？

### 延伸練習

1. **完善遷移**：
   - 實作資料庫遷移（支付表分離）
   - 建立流量逐步切換機制
   - 實作 Circuit Breaker

2. **自動化工具**：
   - 建立腳本自動掃描依賴
   - 建立依賴關係視覺化
   - 建立遷移進度追蹤

3. **提取其他模組**：
   - 應用相同流程提取用戶模組
   - 應用相同流程提取通知模組
   - 整理成可復用的流程

4. **知識沉澱**：
   - 整理成「微服務拆分 SOP」
   - 建立依賴分析檢查清單
   - 分享到團隊知識庫

---

## 相關資源

### 下一步學習

- **C05：安全漏洞修復** - 學習系統化安全審查
- **模組 6：資料庫設計與遷移** - 學習資料庫拆分策略
- **模組 11：微服務架構** - 學習完整微服務設計

### 工具參考

- **Dependency Cruiser** - 依賴關係分析工具
- **Madge** - JavaScript 模組依賴視覺化
- **API Gateway** (Kong, AWS API Gateway) - API 管理
- **Circuit Breaker** (Hystrix, Resilience4j) - 容錯機制

### 相關概念

- **Strangler Fig Pattern** - 逐步替換遺留系統
- **Anti-Corruption Layer** - 防腐層隔離舊系統
- **API Gateway Pattern** - 統一 API 入口
- **Database per Service** - 每個服務獨立資料庫
- **Saga Pattern** - 分散式事務

---

**建議完成時間**：2-2.5 小時（含測試與反思）
**難度評估**：4/5
**重要度**：5/5（微服務拆分是架構演進的關鍵技能）
**可複用性**：5/5（此流程可應用到任何模組提取）
