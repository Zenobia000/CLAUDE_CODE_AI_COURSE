# C06：測試覆蓋率提升（組合級）

## 情境資訊

**編號**：C06
**難度**：⭐⭐⭐☆☆（組合級）
**預計時間**：2 小時
**學習目標**：
- 掌握快速理解無文檔代碼的方法
- 學會使用 /read 深度分析業務邏輯
- 練習系統化的測試用例設計
- 建立測試模式記憶庫

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉 Python 測試框架（pytest）
- 需要為遺留代碼添加測試

---

## 情境描述

### 背景

你剛加入一家電商公司的後端團隊，接手了一個核心的庫存管理模組。這個模組已經運行了 2 年，處理著每天數萬筆訂單的庫存更新，但存在一個致命問題：**測試覆蓋率為 0%**。

上個月發生了一次嚴重的生產事故：某次代碼變更導致庫存數量計算錯誤，造成超賣 500 單，損失 20 萬元。事後分析發現，如果有完善的測試，這個問題在部署前就能被發現。

### 現有代碼

公司要求你在兩週內為這個模組建立完整的測試套件，目標覆蓋率達到 90% 以上。

```python
# src/inventory/manager.py

from typing import Optional, List, Dict
from datetime import datetime
from .models import Product, StockTransaction
from .exceptions import InsufficientStockError, InvalidOperationError

class InventoryManager:
    """庫存管理器 - 處理所有庫存相關操作"""

    def __init__(self, db_connection):
        self.db = db_connection
        self._lock_cache = {}  # 庫存鎖定緩存

    def check_availability(self, product_id: str, quantity: int) -> bool:
        """
        檢查庫存是否充足
        需要考慮：實際庫存、已鎖定庫存、安全庫存
        """
        product = self._get_product(product_id)
        if not product:
            return False

        # 計算可用庫存 = 實際庫存 - 已鎖定庫存 - 安全庫存
        locked_qty = self._get_locked_quantity(product_id)
        available = product.stock - locked_qty - product.safety_stock

        # 特殊處理：預售商品
        if product.is_presale:
            available = product.presale_limit

        return available >= quantity

    def reserve_stock(
        self,
        product_id: str,
        quantity: int,
        order_id: str,
        expires_in_minutes: int = 15
    ) -> bool:
        """
        鎖定庫存（下單時調用）
        鎖定會在 N 分鐘後自動過期
        """
        if not self.check_availability(product_id, quantity):
            return False

        # 創建鎖定記錄
        lock_key = f"{order_id}_{product_id}"
        expiry_time = datetime.now().timestamp() + (expires_in_minutes * 60)

        self._lock_cache[lock_key] = {
            "product_id": product_id,
            "quantity": quantity,
            "order_id": order_id,
            "expires_at": expiry_time
        }

        # 記錄交易
        self._log_transaction(
            product_id=product_id,
            quantity=-quantity,
            transaction_type="RESERVE",
            reference_id=order_id
        )

        return True

    def confirm_reservation(self, order_id: str, product_id: str) -> bool:
        """
        確認預留（支付成功後調用）
        將鎖定的庫存真正扣除
        """
        lock_key = f"{order_id}_{product_id}"

        if lock_key not in self._lock_cache:
            raise InvalidOperationError(f"No reservation found for order {order_id}")

        lock_info = self._lock_cache[lock_key]

        # 檢查是否已過期
        if datetime.now().timestamp() > lock_info["expires_at"]:
            # 自動釋放過期鎖定
            del self._lock_cache[lock_key]
            raise InvalidOperationError(f"Reservation expired for order {order_id}")

        # 扣除實際庫存
        product = self._get_product(product_id)
        product.stock -= lock_info["quantity"]
        self._update_product(product)

        # 記錄交易
        self._log_transaction(
            product_id=product_id,
            quantity=-lock_info["quantity"],
            transaction_type="CONFIRM",
            reference_id=order_id
        )

        # 移除鎖定
        del self._lock_cache[lock_key]

        return True

    def cancel_reservation(self, order_id: str, product_id: str) -> bool:
        """
        取消預留（支付失敗或用戶取消訂單）
        釋放鎖定的庫存
        """
        lock_key = f"{order_id}_{product_id}"

        if lock_key not in self._lock_cache:
            # 可能已經過期自動釋放了，不算錯誤
            return True

        lock_info = self._lock_cache[lock_key]

        # 記錄交易
        self._log_transaction(
            product_id=product_id,
            quantity=lock_info["quantity"],
            transaction_type="CANCEL",
            reference_id=order_id
        )

        # 移除鎖定
        del self._lock_cache[lock_key]

        return True

    def adjust_stock(
        self,
        product_id: str,
        quantity: int,
        reason: str,
        operator: str
    ) -> bool:
        """
        手動調整庫存（盤點、損耗、補貨等）
        quantity 可正可負
        """
        product = self._get_product(product_id)
        if not product:
            raise InvalidOperationError(f"Product {product_id} not found")

        new_stock = product.stock + quantity

        # 防止庫存變為負數
        if new_stock < 0:
            raise InvalidOperationError(
                f"Cannot adjust stock to negative value (current: {product.stock}, adjustment: {quantity})"
            )

        product.stock = new_stock
        self._update_product(product)

        # 記錄交易
        self._log_transaction(
            product_id=product_id,
            quantity=quantity,
            transaction_type="ADJUST",
            reference_id=f"manual_{operator}",
            notes=reason
        )

        return True

    def batch_reserve(
        self,
        items: List[Dict[str, any]],
        order_id: str
    ) -> Dict[str, any]:
        """
        批量鎖定庫存（購物車多商品下單）
        要麼全部成功，要麼全部回滾
        """
        reserved_items = []

        try:
            for item in items:
                success = self.reserve_stock(
                    product_id=item["product_id"],
                    quantity=item["quantity"],
                    order_id=order_id
                )

                if not success:
                    # 回滾已經鎖定的
                    for reserved in reserved_items:
                        self.cancel_reservation(order_id, reserved["product_id"])

                    return {
                        "success": False,
                        "failed_product": item["product_id"],
                        "reason": "Insufficient stock"
                    }

                reserved_items.append(item)

            return {
                "success": True,
                "reserved_items": reserved_items
            }

        except Exception as e:
            # 發生任何錯誤都回滾
            for reserved in reserved_items:
                self.cancel_reservation(order_id, reserved["product_id"])

            return {
                "success": False,
                "reason": str(e)
            }

    def get_stock_level(self, product_id: str) -> Dict[str, int]:
        """
        獲取庫存詳細信息
        """
        product = self._get_product(product_id)
        if not product:
            return None

        locked = self._get_locked_quantity(product_id)

        return {
            "total_stock": product.stock,
            "locked_stock": locked,
            "available_stock": product.stock - locked - product.safety_stock,
            "safety_stock": product.safety_stock
        }

    def cleanup_expired_reservations(self) -> int:
        """
        清理過期的庫存鎖定
        由定時任務調用
        """
        now = datetime.now().timestamp()
        expired_keys = []

        for lock_key, lock_info in self._lock_cache.items():
            if now > lock_info["expires_at"]:
                expired_keys.append(lock_key)

        for key in expired_keys:
            lock_info = self._lock_cache[key]
            self._log_transaction(
                product_id=lock_info["product_id"],
                quantity=lock_info["quantity"],
                transaction_type="EXPIRE",
                reference_id=lock_info["order_id"]
            )
            del self._lock_cache[key]

        return len(expired_keys)

    # Private methods

    def _get_product(self, product_id: str) -> Optional[Product]:
        """從數據庫獲取商品信息"""
        return self.db.query(Product).filter_by(id=product_id).first()

    def _update_product(self, product: Product) -> None:
        """更新商品信息到數據庫"""
        self.db.commit()

    def _get_locked_quantity(self, product_id: str) -> int:
        """計算商品當前被鎖定的總數量"""
        now = datetime.now().timestamp()
        total_locked = 0

        for lock_info in self._lock_cache.values():
            if lock_info["product_id"] == product_id:
                # 只計算未過期的鎖定
                if now <= lock_info["expires_at"]:
                    total_locked += lock_info["quantity"]

        return total_locked

    def _log_transaction(
        self,
        product_id: str,
        quantity: int,
        transaction_type: str,
        reference_id: str,
        notes: str = None
    ) -> None:
        """記錄庫存變動日誌"""
        transaction = StockTransaction(
            product_id=product_id,
            quantity=quantity,
            transaction_type=transaction_type,
            reference_id=reference_id,
            notes=notes,
            created_at=datetime.now()
        )
        self.db.add(transaction)
        self.db.commit()
```

### 你的任務

為 `InventoryManager` 建立完整的測試套件：

1. **理解業務邏輯**：深入分析每個方法的職責和邏輯
2. **識別測試場景**：正常流程、邊界條件、異常情況
3. **編寫測試用例**：達到 90% 以上覆蓋率
4. **建立測試模式庫**：沉澱可復用的測試經驗

---

## 學習重點

### 目標 1：快速理解遺留代碼

學會使用 `/read` 系統化分析無文檔代碼：
- 識別每個方法的職責
- 理解方法之間的調用關係
- 發現隱藏的業務規則
- 找出潛在的 bug 或邏輯漏洞

### 目標 2：系統化測試設計

掌握完整的測試設計方法論：
- **Happy Path**：正常業務流程測試
- **Edge Cases**：邊界條件測試
- **Error Handling**：異常處理測試
- **Integration**：方法間協作測試

### 目標 3：測試用例組織

學會結構化組織測試：
```python
tests/
├── test_inventory_basic.py          # 基礎功能測試
├── test_inventory_reservation.py    # 預留流程測試
├── test_inventory_concurrent.py     # 併發場景測試
└── test_inventory_edge_cases.py     # 邊界情況測試
```

### 目標 4：知識沉澱

使用 `/memory` 建立測試模式庫：
- 常見測試場景清單
- 測試 fixture 範本
- Mock 策略
- 斷言技巧

---

## 建議解決流程

### 階段一：深度代碼理解（30 分鐘）

**目標**：完全理解 InventoryManager 的業務邏輯

#### 步驟 1：整體結構分析

```bash
/read src/inventory/manager.py

提示詞：
請詳細分析 InventoryManager 類的設計：

1. 這個類的核心職責是什麼？
2. 有哪些公開方法（API）？每個方法做什麼？
3. 有哪些私有方法？它們如何支持公開方法？
4. 類的狀態（self._lock_cache）如何管理？
5. 依賴了哪些外部組件（db_connection, Product, etc.）？

請繪製方法調用關係圖。
```

**預期 Claude 輸出**：

```markdown
## InventoryManager 分析報告

### 核心職責
庫存管理器，負責電商系統的庫存控制，包括：
- 庫存可用性檢查
- 庫存預留/鎖定機制（防止超賣）
- 庫存確認/取消
- 庫存手動調整
- 批量操作
- 過期清理

### 公開 API（9 個方法）

1. **check_availability(product_id, quantity)**
   - 檢查庫存是否充足
   - 考慮：實際庫存、鎖定庫存、安全庫存
   - 特殊處理：預售商品

2. **reserve_stock(product_id, quantity, order_id, expires_in_minutes)**
   - 鎖定庫存（下單時）
   - 創建帶過期時間的鎖定記錄
   - 記錄交易日誌

3. **confirm_reservation(order_id, product_id)**
   - 確認預留（支付成功）
   - 真正扣除庫存
   - 移除鎖定記錄

4. **cancel_reservation(order_id, product_id)**
   - 取消預留（支付失敗/用戶取消）
   - 釋放鎖定

5. **adjust_stock(product_id, quantity, reason, operator)**
   - 手動調整庫存
   - 盤點、補貨、損耗等場景

6. **batch_reserve(items, order_id)**
   - 批量鎖定庫存
   - 事務性：全成功或全回滾

7. **get_stock_level(product_id)**
   - 獲取庫存詳細信息

8. **cleanup_expired_reservations()**
   - 清理過期鎖定
   - 定時任務調用

### 私有方法（4 個）

- **_get_product(product_id)**：數據庫查詢
- **_update_product(product)**：數據庫更新
- **_get_locked_quantity(product_id)**：計算鎖定總量
- **_log_transaction(...)**：記錄交易日誌

### 狀態管理

**self._lock_cache**：內存緩存，存儲庫存鎖定信息
- 格式：`{order_id}_{product_id}` → lock_info
- 包含：product_id, quantity, order_id, expires_at

### 方法調用關係圖

```
Public APIs:
┌──────────────────────────────────────────────────┐
│ check_availability                               │
│   └─ _get_product                                │
│   └─ _get_locked_quantity                        │
│                                                   │
│ reserve_stock                                     │
│   └─ check_availability                          │
│   └─ _log_transaction                            │
│                                                   │
│ confirm_reservation                               │
│   └─ _get_product                                │
│   └─ _update_product                             │
│   └─ _log_transaction                            │
│                                                   │
│ cancel_reservation                                │
│   └─ _log_transaction                            │
│                                                   │
│ adjust_stock                                      │
│   └─ _get_product                                │
│   └─ _update_product                             │
│   └─ _log_transaction                            │
│                                                   │
│ batch_reserve                                     │
│   └─ reserve_stock (循環調用)                     │
│   └─ cancel_reservation (錯誤回滾)                │
│                                                   │
│ get_stock_level                                   │
│   └─ _get_product                                │
│   └─ _get_locked_quantity                        │
│                                                   │
│ cleanup_expired_reservations                      │
│   └─ _log_transaction                            │
└──────────────────────────────────────────────────┘
```

### 關鍵業務規則

1. **可用庫存計算**：`實際庫存 - 鎖定庫存 - 安全庫存`
2. **預售特殊處理**：預售商品使用預售限額
3. **鎖定過期機制**：默認 15 分鐘
4. **批量操作原子性**：batch_reserve 必須全成功或全回滾
5. **防止負庫存**：adjust_stock 會檢查

### 潛在問題 ⚠️

1. **併發問題**：_lock_cache 是內存字典，多進程不共享
2. **過期清理**：依賴定時任務，可能有延遲
3. **缺少鎖機制**：高併發下可能超賣
4. **異常處理不完整**：某些方法缺少 try-except
5. **數據庫事務**：confirm_reservation 等方法沒有顯式事務控制
```

**檢查點**：
- [ ] 理解了每個公開方法的職責
- [ ] 明白方法之間的調用關係
- [ ] 識別出關鍵業務規則
- [ ] 發現了潛在問題

---

#### 步驟 2：識別測試場景

```bash
提示詞：
基於以上分析，請列出 InventoryManager 需要測試的所有場景。

分類：
1. 正常流程（Happy Path）
2. 邊界條件（Boundary Cases）
3. 異常情況（Error Cases）
4. 併發場景（Concurrency）

每個場景包含：
- 場景描述
- 測試目標
- 預期結果
```

**預期輸出**：

```markdown
## 測試場景清單

### A. 正常流程測試（Happy Path）

#### A1. 庫存檢查
- **場景**：商品庫存充足，檢查通過
- **測試**：check_availability(product_id, quantity) 返回 True
- **預期**：可用庫存 >= 請求數量

#### A2. 庫存預留
- **場景**：成功鎖定庫存
- **測試**：reserve_stock() 返回 True
- **預期**：_lock_cache 中新增記錄，交易日誌已記錄

#### A3. 確認預留
- **場景**：支付成功，確認扣除庫存
- **測試**：confirm_reservation() 返回 True
- **預期**：實際庫存減少，鎖定記錄移除

#### A4. 取消預留
- **場景**：用戶取消訂單，釋放庫存
- **測試**：cancel_reservation() 返回 True
- **預期**：鎖定記錄移除，交易日誌記錄 CANCEL

#### A5. 手動調整庫存
- **場景**：盤點後補充庫存
- **測試**：adjust_stock(product_id, +100, "補貨", "admin")
- **預期**：庫存增加 100，記錄交易日誌

#### A6. 批量預留
- **場景**：購物車 3 件商品，全部預留成功
- **測試**：batch_reserve(items, order_id)
- **預期**：3 個商品都成功鎖定

### B. 邊界條件測試（Boundary Cases）

#### B1. 庫存剛好足夠
- **場景**：可用庫存 = 請求數量
- **測試**：check_availability(product_id, available_stock)
- **預期**：返回 True

#### B2. 庫存不足 1 件
- **場景**：可用庫存 = 請求數量 - 1
- **測試**：check_availability(product_id, available_stock + 1)
- **預期**：返回 False

#### B3. 安全庫存邊界
- **場景**：實際庫存 > 請求數量，但 - 安全庫存後不足
- **測試**：考慮 safety_stock 的影響
- **預期**：返回 False

#### B4. 預售商品
- **場景**：預售商品，實際庫存為 0
- **測試**：is_presale=True，使用 presale_limit
- **預期**：按預售限額檢查

#### B5. 鎖定即將過期
- **場景**：鎖定還有 1 秒過期
- **測試**：confirm_reservation() 在過期前調用
- **預期**：成功確認

#### B6. 鎖定剛剛過期
- **場景**：鎖定已過期 1 秒
- **測試**：confirm_reservation() 在過期後調用
- **預期**：拋出 InvalidOperationError

### C. 異常情況測試（Error Cases）

#### C1. 商品不存在
- **場景**：product_id 不存在
- **測試**：check_availability("non_existent_id", 1)
- **預期**：返回 False

#### C2. 數量為負數
- **場景**：請求數量 < 0
- **測試**：reserve_stock(product_id, -1, order_id)
- **預期**：應該失敗（目前代碼未檢查！）

#### C3. 數量為 0
- **場景**：請求數量 = 0
- **測試**：reserve_stock(product_id, 0, order_id)
- **預期**：應該失敗或特殊處理

#### C4. 重複確認
- **場景**：對同一訂單調用兩次 confirm_reservation()
- **測試**：第二次應該失敗
- **預期**：拋出 InvalidOperationError

#### C5. 確認不存在的預留
- **場景**：order_id 沒有對應的鎖定
- **測試**：confirm_reservation("fake_order", product_id)
- **預期**：拋出 InvalidOperationError

#### C6. 調整導致負庫存
- **場景**：adjust_stock(product_id, -9999, ...)
- **測試**：調整後庫存變為負數
- **預期**：拋出 InvalidOperationError

#### C7. 批量預留部分失敗
- **場景**：5 件商品，第 3 件庫存不足
- **測試**：batch_reserve()
- **預期**：前 2 件回滾，返回失敗信息

#### C8. 取消不存在的預留
- **場景**：cancel_reservation() 對不存在的 order_id
- **測試**：應該不報錯（代碼中已處理）
- **預期**：返回 True

### D. 併發場景測試（Concurrency）

#### D1. 併發檢查庫存
- **場景**：2 個請求同時檢查同一商品
- **測試**：模擬多線程調用
- **預期**：結果一致

#### D2. 併發預留（可能超賣）
- **場景**：庫存只有 1 件，2 個請求同時預留
- **測試**：模擬競態條件
- **預期**：只有 1 個成功（目前可能有 bug！）

#### D3. 預留和確認併發
- **場景**：A 預留時，B 同時確認
- **測試**：鎖定狀態一致性
- **預期**：不應該出現數據不一致

### E. 時間相關測試

#### E1. 過期清理功能
- **場景**：有 10 個過期鎖定
- **測試**：cleanup_expired_reservations()
- **預期**：清理 10 個，返回 10

#### E2. 時間邊界
- **場景**：剛好在過期時間點確認
- **測試**：使用 mock 時間
- **預期**：明確的成功或失敗行為

### F. 狀態一致性測試

#### F1. 鎖定後的可用庫存
- **場景**：預留 5 件後，再次檢查可用庫存
- **測試**：get_stock_level()
- **預期**：locked_stock = 5，available_stock 減少 5

#### F2. 確認後的庫存變化
- **場景**：確認預留後，檢查總庫存
- **測試**：confirm_reservation() → get_stock_level()
- **預期**：total_stock 減少，locked_stock 清零

---

**總計**：約 30+ 個測試場景
```

**檢查點**：
- [ ] 列出了所有正常流程
- [ ] 識別了關鍵邊界條件
- [ ] 考慮了異常情況
- [ ] 思考了併發問題

---

### 階段二：設計測試架構（30 分鐘）

**目標**：建立清晰的測試結構

#### 步驟 1：設計測試 Fixtures

```bash
提示詞：
請設計測試所需的 fixtures（pytest），包括：
1. Mock 數據庫連接
2. 測試用的 Product 數據
3. InventoryManager 實例
4. 常用的測試輔助函數

要求：可復用、易維護
```

**生成測試基礎設施**：

```python
# tests/conftest.py

import pytest
from unittest.mock import Mock, MagicMock
from datetime import datetime
from src.inventory.manager import InventoryManager
from src.inventory.models import Product

@pytest.fixture
def mock_db():
    """Mock 數據庫連接"""
    db = Mock()
    db.query = Mock()
    db.add = Mock()
    db.commit = Mock()
    return db

@pytest.fixture
def sample_product():
    """標準測試商品"""
    product = Product(
        id="PROD001",
        name="測試商品",
        stock=100,           # 實際庫存
        safety_stock=10,     # 安全庫存
        is_presale=False,
        presale_limit=0
    )
    return product

@pytest.fixture
def presale_product():
    """預售商品"""
    product = Product(
        id="PRESALE001",
        name="預售商品",
        stock=0,             # 實際庫存為 0
        safety_stock=0,
        is_presale=True,
        presale_limit=500    # 預售限額
    )
    return product

@pytest.fixture
def low_stock_product():
    """低庫存商品"""
    product = Product(
        id="LOW001",
        name="低庫存商品",
        stock=15,            # 只有 15 件
        safety_stock=10,     # 安全庫存 10
        is_presale=False,
        presale_limit=0
    )
    return product

@pytest.fixture
def inventory_manager(mock_db):
    """庫存管理器實例"""
    manager = InventoryManager(mock_db)
    return manager

@pytest.fixture
def setup_product_in_db(mock_db, sample_product):
    """配置數據庫 mock 返回測試商品"""
    def _setup(product=None):
        if product is None:
            product = sample_product

        mock_query = Mock()
        mock_filter = Mock()
        mock_filter.first.return_value = product
        mock_query.filter_by.return_value = mock_filter
        mock_db.query.return_value = mock_query

        return product

    return _setup

@pytest.fixture
def freeze_time(monkeypatch):
    """凍結時間（用於測試過期）"""
    def _freeze(timestamp):
        class MockDatetime:
            @staticmethod
            def now():
                return datetime.fromtimestamp(timestamp)

        monkeypatch.setattr("src.inventory.manager.datetime", MockDatetime)

    return _freeze
```

**檢查點**：
- [ ] 設計了可復用的 fixtures
- [ ] Mock 了外部依賴（數據庫）
- [ ] 準備了各種測試數據

---

#### 步驟 2：編寫第一批測試

```bash
提示詞：
請為 check_availability() 方法編寫完整的測試用例，
涵蓋正常情況、邊界條件、異常情況。

要求：
- 使用 pytest
- 測試名稱清晰
- 每個測試一個斷言點
- 添加註釋說明測試目的
```

**生成測試文件**：

```python
# tests/test_inventory_basic.py

import pytest
from src.inventory.manager import InventoryManager

class TestCheckAvailability:
    """測試庫存可用性檢查"""

    def test_sufficient_stock_returns_true(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：庫存充足時返回 True"""
        # Arrange
        setup_product_in_db(sample_product)
        # stock=100, safety_stock=10 → available=90

        # Act
        result = inventory_manager.check_availability("PROD001", 50)

        # Assert
        assert result is True

    def test_insufficient_stock_returns_false(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：庫存不足時返回 False"""
        # Arrange
        setup_product_in_db(sample_product)
        # available = 90

        # Act
        result = inventory_manager.check_availability("PROD001", 100)

        # Assert
        assert result is False

    def test_exact_available_stock_returns_true(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：請求數量剛好等於可用庫存"""
        # Arrange
        setup_product_in_db(sample_product)
        available = 90  # 100 - 10(safety)

        # Act
        result = inventory_manager.check_availability("PROD001", available)

        # Assert
        assert result is True

    def test_one_more_than_available_returns_false(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：請求數量比可用庫存多 1 件"""
        # Arrange
        setup_product_in_db(sample_product)
        available = 90

        # Act
        result = inventory_manager.check_availability("PROD001", available + 1)

        # Assert
        assert result is False

    def test_product_not_found_returns_false(
        self,
        inventory_manager,
        mock_db
    ):
        """測試：商品不存在時返回 False"""
        # Arrange
        mock_query = Mock()
        mock_filter = Mock()
        mock_filter.first.return_value = None  # 商品不存在
        mock_query.filter_by.return_value = mock_filter
        mock_db.query.return_value = mock_query

        # Act
        result = inventory_manager.check_availability("NON_EXISTENT", 1)

        # Assert
        assert result is False

    def test_presale_product_uses_presale_limit(
        self,
        inventory_manager,
        setup_product_in_db,
        presale_product
    ):
        """測試：預售商品使用預售限額，不考慮實際庫存"""
        # Arrange
        setup_product_in_db(presale_product)
        # stock=0, presale_limit=500 → available=500

        # Act
        result = inventory_manager.check_availability("PRESALE001", 300)

        # Assert
        assert result is True

    def test_considers_locked_stock(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：考慮已鎖定的庫存"""
        # Arrange
        setup_product_in_db(sample_product)

        # 先鎖定 20 件
        inventory_manager.reserve_stock("PROD001", 20, "ORDER001")

        # Act
        # available = 100 - 10(safety) - 20(locked) = 70
        result = inventory_manager.check_availability("PROD001", 70)

        # Assert
        assert result is True

    def test_locked_stock_reduces_availability(
        self,
        inventory_manager,
        setup_product_in_db,
        sample_product
    ):
        """測試：鎖定庫存後可用庫存減少"""
        # Arrange
        setup_product_in_db(sample_product)
        inventory_manager.reserve_stock("PROD001", 50, "ORDER001")

        # Act
        # available = 100 - 10 - 50 = 40
        result = inventory_manager.check_availability("PROD001", 41)

        # Assert
        assert result is False
```

**檢查點**：
- [ ] 測試了正常情況
- [ ] 測試了邊界條件
- [ ] 測試了異常情況
- [ ] 考慮了鎖定庫存的影響

---

### 階段三：完成完整測試套件（50 分鐘）

**目標**：為所有方法編寫測試，達到 90% 覆蓋率

#### 步驟 1：為核心方法編寫測試

```bash
提示詞：
請為以下方法編寫完整測試：
1. reserve_stock()
2. confirm_reservation()
3. cancel_reservation()
4. batch_reserve()

每個方法至少 5 個測試用例。
```

#### 步驟 2：測試邊界和異常

```bash
提示詞：
請為以下場景編寫測試：
1. 過期鎖定的處理
2. 重複操作（重複確認、重複取消）
3. 並發操作（模擬競態條件）
4. 數據一致性驗證
```

#### 步驟 3：執行測試並檢查覆蓋率

```bash
# 執行測試
pytest tests/ -v

# 檢查覆蓋率
pytest tests/ --cov=src/inventory --cov-report=term-missing

# 預期輸出
----------- coverage: platform linux, python 3.10.0 -----------
Name                            Stmts   Miss  Cover   Missing
-------------------------------------------------------------
src/inventory/manager.py          180     12    93%   45-48, 234-237
-------------------------------------------------------------
TOTAL                             180     12    93%
```

**檢查點**：
- [ ] 所有公開方法都有測試
- [ ] 覆蓋率達到 90% 以上
- [ ] 所有測試通過
- [ ] 測試執行時間合理（< 5 秒）

---

### 階段四：知識沉澱與優化（10 分鐘）

**目標**：記錄測試經驗，建立可復用模式

#### 步驟 1：記憶測試模式

```bash
/memory save

主題：遺留代碼測試最佳實踐

關鍵步驟：
1. 使用 /read 深度分析代碼邏輯
   - 識別方法職責
   - 繪製調用關係圖
   - 發現隱藏的業務規則

2. 系統化測試場景設計
   - Happy Path：正常流程
   - Boundary Cases：邊界條件（=, +1, -1）
   - Error Cases：異常情況
   - Concurrency：併發場景
   - Time-based：時間相關

3. 設計可復用 Fixtures
   - Mock 外部依賴
   - 準備多種測試數據
   - 輔助函數（freeze_time, setup_db）

4. 測試組織結構
   - 按功能分文件（test_basic, test_reservation）
   - 每個方法一個測試類
   - 測試名稱描述性強

5. 覆蓋率目標
   - 核心業務邏輯：>95%
   - 邊界條件：必須覆蓋
   - 異常處理：必須測試

測試命名模式：
- test_{method}__{scenario}__returns_{expected}
- test_{method}_with_{condition}_raises_{exception}
- test_{method}_when_{state}_then_{behavior}

相關工具：pytest, pytest-cov, pytest-mock
相關指令：/read（理解代碼），/glob（找測試文件）
```

#### 步驟 2：生成測試報告

```bash
提示詞：
請生成一份測試報告，包含：
1. 測試覆蓋率統計
2. 測試場景清單
3. 發現的潛在 bug
4. 改進建議
```

**預期報告**：

```markdown
# InventoryManager 測試報告

## 測試統計

- **總測試數**：37 個
- **通過率**：100%
- **代碼覆蓋率**：93%
- **執行時間**：2.3 秒

## 測試分布

| 測試類型 | 數量 | 說明 |
|---------|------|------|
| 正常流程 | 12 | Happy path 測試 |
| 邊界條件 | 10 | Boundary cases |
| 異常處理 | 8 | Error handling |
| 併發場景 | 4 | Concurrency tests |
| 狀態一致性 | 3 | State consistency |

## 發現的問題 ⚠️

### 高風險

1. **併發競態條件**（未修復）
   - 位置：reserve_stock()
   - 問題：內存 _lock_cache 無鎖保護
   - 影響：高併發下可能超賣
   - 建議：使用 Redis + SETNX 或數據庫行鎖

2. **缺少輸入驗證**
   - 位置：reserve_stock(quantity)
   - 問題：未檢查 quantity 是否為負數或 0
   - 影響：可能導致異常行為
   - 建議：添加參數驗證

### 中風險

3. **過期清理依賴外部定時任務**
   - 位置：cleanup_expired_reservations()
   - 問題：如果定時任務失敗，過期鎖定不會清理
   - 建議：在 check_availability 時同時清理過期

4. **數據庫事務未顯式控制**
   - 位置：confirm_reservation()
   - 問題：庫存扣除和日誌記錄未在同一事務
   - 建議：使用 db.begin() 顯式事務

## 改進建議

### 立即執行
- [ ] 添加輸入參數驗證
- [ ] 為 batch_reserve 添加數據庫事務

### 短期改進
- [ ] 將 _lock_cache 遷移到 Redis
- [ ] 添加分佈式鎖機制
- [ ] 完善異常處理

### 長期優化
- [ ] 考慮使用消息隊列處理庫存變更
- [ ] 實現庫存預警機制
- [ ] 添加性能監控

## 測試維護

### 運行測試
```bash
# 運行所有測試
pytest tests/

# 運行特定測試
pytest tests/test_inventory_reservation.py

# 查看覆蓋率
pytest --cov=src/inventory --cov-report=html
```

### CI/CD 集成
建議在 CI 中添加：
- 測試覆蓋率閾值：90%
- 測試執行時間限制：< 10 秒
- 失敗時阻止合併
```

**檢查點**：
- [ ] 沉澱了測試方法論到 /memory
- [ ] 生成了完整的測試報告
- [ ] 識別了代碼中的潛在問題
- [ ] 提供了可操作的改進建議

---

## 驗證標準

### 必須達成 ✅

- [ ] 成功為 InventoryManager 編寫完整測試套件
- [ ] 代碼覆蓋率達到 90% 以上
- [ ] 所有測試通過
- [ ] 測試結構清晰，易於維護
- [ ] 使用 /memory 沉澱了測試模式
- [ ] 發現了至少 3 個代碼問題

### 額外成就 🌟

- [ ] 覆蓋率達到 95% 以上
- [ ] 編寫了併發測試（使用 threading 或 multiprocessing）
- [ ] 設計了測試 fixtures 庫可供其他模組復用
- [ ] 生成了 HTML 格式的測試報告
- [ ] 為發現的 bug 提供了修復代碼

---

## 學習反思

### 反思問題

1. **代碼理解**：
   - 沒有文檔時，如何快速理解複雜代碼？
   - /read 如何幫助你發現業務邏輯？
   - 你發現了哪些隱藏的業務規則？

2. **測試設計**：
   - 如何確保沒有遺漏重要的測試場景？
   - 邊界條件測試的價值是什麼？
   - 併發測試為什麼特別重要？

3. **質量保障**：
   - 90% 覆蓋率夠嗎？未覆蓋的 10% 是什麼？
   - 如何平衡測試數量與維護成本？
   - 測試如何幫助未來的重構？

4. **知識沉澱**：
   - /memory 中沉澱的模式如何復用？
   - 如何建立團隊的測試標準？

### 延伸練習

1. **性能測試**：
   - 使用 pytest-benchmark 測試性能
   - 找出性能瓶頸（如 _get_locked_quantity 的 O(n) 複雜度）

2. **集成測試**：
   - 使用真實數據庫（SQLite in-memory）
   - 測試完整的訂單流程

3. **修復發現的 Bug**：
   - 實現分佈式鎖
   - 添加輸入驗證
   - 優化併發處理

---

## 相關資源

### 下一步學習

- **C07**：代碼風格統一 - 使用 /grep 批量重構
- **C09**：性能瓶頸優化 - 識別並優化慢方法
- **模組 3**：TDD/BDD - 測試驅動開發深度實踐

### 工具參考

- **pytest**：Python 測試框架
- **pytest-cov**：覆蓋率報告
- **pytest-mock**：Mock 工具
- **pytest-benchmark**：性能測試
- **hypothesis**：基於屬性的測試（進階）

### 學習資源

- **《Test Driven Development》**（Kent Beck）
- **《Working Effectively with Legacy Code》**（Michael Feathers）
- **pytest 官方文檔**
- **Python Mock 最佳實踐**

---

**建議完成時間**：2-3 小時
**難度評估**：3.5/5
**重要度**：5/5（測試是代碼質量的保障）
**可複用性**：5/5（測試模式可應用到任何遺留代碼）
