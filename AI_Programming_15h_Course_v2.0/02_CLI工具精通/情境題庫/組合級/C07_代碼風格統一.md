# C07：代碼風格統一（組合級）

## 情境資訊

**編號**：C07
**難度**：⭐⭐⭐☆☆（組合級）
**預計時間**：1.5 小時
**學習目標**：
- 掌握使用 /grep 批量查找代碼模式
- 學會系統化分析風格不一致問題
- 練習安全的批量重構技巧
- 建立代碼風格檢查清單

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉 Python 命名規範（PEP 8）
- 需要統一團隊代碼風格

---

## 情境描述

### 背景

你在一家快速成長的 SaaS 公司擔任技術負責人。過去 2 年，公司從 3 人成長到 15 人，每個開發者都有自己的編碼習慣。現在代碼庫充斥著各種風格：

- **命名風格混亂**：駝峰、蛇形、大小寫混用
- **錯誤處理不一致**：有的返回 None，有的拋異常，有的返回錯誤碼
- **格式不統一**：有的單引號，有的雙引號，縮排混亂
- **註釋風格各異**：有的詳細，有的完全沒有

這導致新人上手困難，代碼審查耗時，bug 增加。公司決定統一代碼風格，你需要在不破壞功能的前提下，系統化地重構整個代碼庫。

### 現有問題示例

```python
# src/api/user_service.py - 開發者 A 的風格

class UserService:
    def GetUserById(self, userId):  # 駝峰 + 蛇形混用
        """查詢用戶"""
        try:
            user = self.db.query(User).filter_by(id=userId).first()
            if user == None:  # 使用 == None
                return None
            return user
        except:  # 裸 except
            return None

    def createUser(self, data):  # 小駝峰
        userName = data.get('username')  # 駝峰命名
        passWord = data.get('password')
        # 單引號
        if not userName or not passWord:
            return {'error': 'Invalid input'}  # 返回字典錯誤
        # ...

# src/api/order_service.py - 開發者 B 的風格

class OrderService:
    def get_order_by_id(self, order_id):  # 蛇形命名（正確）
        """
        根據訂單ID查詢訂單

        Args:
            order_id: 訂單ID

        Returns:
            Order object or None
        """  # 詳細 docstring
        order = self.db.query(Order).filter_by(id=order_id).first()
        if order is None:  # 使用 is None（正確）
            raise OrderNotFoundError(f"Order {order_id} not found")  # 拋異常
        return order

    def create_order(self, data):
        user_id = data.get("user_id")  # 雙引號
        items = data.get("items")

        if not user_id:
            raise ValidationError("Missing user_id")  # 拋異常

        if not items or len(items) == 0:  # 冗餘檢查
            raise ValidationError("Order must have at least one item")
        # ...

# src/api/product_service.py - 開發者 C 的風格

class ProductService:
    def Get_Product(self, ID):  # 大小寫混亂
        result = self.db.query(Product).filter_by(id=ID).first()
        if not result:
            return -1  # 返回錯誤碼（不一致）
        return result

    def UpdateProduct(self, id, data):  # 大駝峰
        p = self.db.query(Product).filter_by(id=id).first()  # 模糊命名
        if p == None:
            return -1
        p.name = data['name']
        p.price = data['price']
        self.db.commit()
        return 0  # 返回成功碼

# src/utils/helpers.py - 各種輔助函數

def check_email(email):  # 蛇形
    """檢查郵箱格式"""
    import re
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return re.match(pattern, email) is not None

def ValidatePhoneNumber(phone):  # 大駝峰
    # 沒有 docstring
    import re
    return re.match(r'^\d{11}$', phone) != None  # 使用 != None

def format_date(d):  # 模糊命名
    """格式化日期"""
    return d.strftime('%Y-%m-%d')

def FormatDateTime(dt):  # 重複功能，不同命名
    """格式化日期時間"""
    return dt.strftime("%Y-%m-%d %H:%M:%S")
```

### 你的任務

系統化地統一代碼風格，包括：

1. **命名規範統一**：
   - 類名：大駝峰（PascalCase）
   - 函數/方法：蛇形（snake_case）
   - 變數：蛇形（snake_case）
   - 常數：大寫蛇形（UPPER_SNAKE_CASE）

2. **錯誤處理統一**：
   - 統一使用異常處理
   - 定義標準的異常類
   - 移除錯誤碼返回

3. **代碼格式統一**：
   - 統一使用雙引號
   - 統一 None 判斷方式（使用 is/is not）
   - 移除冗餘代碼

4. **文檔風格統一**：
   - 所有公開方法必須有 docstring
   - 使用統一的 docstring 格式（Google Style）

---

## 學習重點

### 目標 1：模式識別與批量查找

學會使用 /grep 找出所有風格問題：
- 正則表達式精準匹配
- 上下文查看（-C 參數）
- 多種模式組合搜尋
- 結果分類與優先級排序

### 目標 2：安全的批量重構

掌握不破壞功能的重構技巧：
- 小步修改，頻繁測試
- 使用 IDE 重構功能（重命名）
- Git 提交策略（每類修改一個 commit）
- 自動化工具輔助（black, isort）

### 目標 3：建立代碼風格指南

使用 CLAUDE.md 記錄團隊標準：
- 命名規範
- 錯誤處理標準
- 格式要求
- 自動化檢查（pre-commit hooks）

### 目標 4：漸進式改進策略

學會處理大規模重構：
- 優先級排序（高影響 vs 低風險）
- 分批次執行
- 新舊代碼共存策略
- 團隊溝通與培訓

---

## 建議解決流程

### 階段一：全面掃描與分類（20 分鐘）

**目標**：識別所有風格問題，按嚴重程度分類

#### 步驟 1：掃描命名問題

```bash
/grep "def [A-Z]" --type py

提示詞：
請找出所有不符合 PEP 8 命名規範的函數和方法：

1. 大駝峰命名的函數（應該用蛇形）
2. 大小寫混用的函數
3. 單字母或模糊的變數名

對每類問題統計數量，並列出前 10 個最需要修改的。
```

**預期 Claude 輸出**：

```markdown
## 命名問題掃描報告

### 函數命名問題

#### 1. 大駝峰命名函數（28 處）

應該使用 snake_case，但使用了 PascalCase：

src/api/user_service.py:15
    def GetUserById(self, userId):

src/api/user_service.py:25
    def createUser(self, data):

src/api/product_service.py:42
    def UpdateProduct(self, id, data):

src/utils/helpers.py:67
    def ValidatePhoneNumber(phone):

src/utils/helpers.py:78
    def FormatDateTime(dt):

... (共 28 處)

#### 2. 大小寫混用（12 處）

完全不規範的命名：

src/api/product_service.py:8
    def Get_Product(self, ID):

src/utils/validators.py:23
    def Check_Email(email_addr):

... (共 12 處)

#### 3. 參數命名問題（45 處）

駝峰命名的參數（應該用 snake_case）：

src/api/user_service.py:15
    def GetUserById(self, userId):  # 應該是 user_id

src/api/order_service.py:89
    def update_order(self, orderId, orderData):  # 兩個都要改

... (共 45 處)

### 變數命名問題

#### 4. 模糊命名（67 處）

src/api/product_service.py:45
    p = self.db.query(Product)...  # p → product

src/utils/helpers.py:12
    d = datetime.now()  # d → current_date

src/api/order_service.py:234
    data = ...  # 過於通用

... (共 67 處)

### 類命名問題

#### 5. 小駝峰或蛇形命名的類（3 處）

src/models/userProfile.py:5
    class userProfile:  # 應該是 UserProfile

src/utils/helpers.py:123
    class date_formatter:  # 應該是 DateFormatter

### 優先級建議

🔴 **高優先（影響 API 接口）**：
- 公開 API 方法命名（12 處）
- 數據模型類命名（3 處）

🟡 **中優先（內部使用）**：
- 私有方法命名（35 處）
- 輔助函數命名（20 處）

🟢 **低優先（局部變數）**：
- 局部變數命名（67 處）
- 可以逐步改進
```

**檢查點**：
- [ ] 找出所有命名問題
- [ ] 按類型分類
- [ ] 評估了影響範圍
- [ ] 確定了優先級

---

#### 步驟 2：掃描錯誤處理不一致

```bash
/grep "return None" --type py -C 2
/grep "return -1" --type py -C 2
/grep "return \{.*error" --type py -C 2

提示詞：
請分析項目中的錯誤處理模式，找出不一致之處：

1. 返回 None 表示錯誤（多少處？）
2. 返回錯誤碼（-1, 0, 1 等）
3. 返回錯誤字典 {"error": ...}
4. 拋出異常

統計每種模式的使用頻率，並建議統一方案。
```

**預期輸出**：

```markdown
## 錯誤處理模式分析

### 現狀統計

| 模式 | 數量 | 檔案數 | 示例 |
|------|------|--------|------|
| 返回 None | 34 | 12 | `return None` |
| 返回錯誤碼 | 18 | 5 | `return -1`, `return 0` |
| 返回錯誤字典 | 12 | 4 | `return {"error": "msg"}` |
| 拋出異常 | 45 | 8 | `raise XxxError(...)` |

### 問題示例

#### 模式 1: 返回 None（不推薦）

src/api/user_service.py:18
```python
def GetUserById(self, userId):
    user = self.db.query(User).filter_by(id=userId).first()
    if user == None:
        return None  # 呼叫方需要檢查 None
    return user
```

**問題**：
- 呼叫方容易忘記檢查
- None 可能是合法返回值（歧義）
- 不知道失敗原因

#### 模式 2: 返回錯誤碼（不推薦）

src/api/product_service.py:48
```python
def UpdateProduct(self, id, data):
    p = self.db.query(Product).filter_by(id=id).first()
    if p == None:
        return -1  # 魔術數字
    # ...
    return 0  # 成功？
```

**問題**：
- 魔術數字，不易理解
- 需要文檔說明錯誤碼含義
- C 語言風格，不 Pythonic

#### 模式 3: 返回錯誤字典（不一致）

src/api/user_service.py:28
```python
def createUser(self, data):
    if not userName:
        return {'error': 'Invalid input'}
    # ...
    return user_object  # 類型不一致！
```

**問題**：
- 返回類型不一致（字典 vs 對象）
- 呼叫方需要判斷類型
- 不符合 Python 慣例

#### 模式 4: 拋出異常（推薦✅）

src/api/order_service.py:23
```python
def get_order_by_id(self, order_id):
    order = self.db.query(Order).filter_by(id=order_id).first()
    if order is None:
        raise OrderNotFoundError(f"Order {order_id} not found")
    return order
```

**優點**：
- 清晰明確
- 強制呼叫方處理
- 可以傳遞詳細錯誤信息
- 符合 Python 最佳實踐

### 建議的統一方案

#### 方案：統一使用異常處理

1. **定義異常層級**：

```python
# src/exceptions.py

class AppException(Exception):
    """應用異常基類"""
    pass

class NotFoundError(AppException):
    """資源未找到"""
    pass

class ValidationError(AppException):
    """驗證錯誤"""
    pass

class DatabaseError(AppException):
    """數據庫錯誤"""
    pass
```

2. **遷移策略**：

Phase 1: 添加異常類（不破壞現有代碼）
Phase 2: 逐步遷移高優先 API
Phase 3: 遷移內部方法
Phase 4: 移除舊模式

### 遷移工作量評估

- 需要修改方法數：64 個
- 預計時間：2-3 天
- 風險：中（需要更新所有呼叫方）
```

**檢查點**：
- [ ] 識別了所有錯誤處理模式
- [ ] 統計了使用頻率
- [ ] 提出了統一方案
- [ ] 評估了遷移工作量

---

#### 步驟 3：掃描代碼格式問題

```bash
/grep "== None" --type py
/grep "!= None" --type py
/grep "if not.*or len\(" --type py

提示詞：
請找出以下代碼格式問題：

1. 使用 == None 而非 is None
2. 使用 != None 而非 is not None
3. 冗餘的長度檢查（if not x or len(x) == 0）
4. 裸 except 子句
5. 單引號 vs 雙引號混用

對每個問題提供正確的替代方案。
```

**預期輸出**：

```markdown
## 代碼格式問題清單

### 1. None 判斷方式錯誤（67 處）

❌ **錯誤**：
```python
if user == None:
if data != None:
```

✅ **正確**：
```python
if user is None:
if data is not None:
```

**原因**：
- `==` 是值比較，`is` 是身份比較
- None 是單例，應該用 is
- PEP 8 明確要求

**位置**：
- src/api/user_service.py: 5 處
- src/api/product_service.py: 8 處
- src/api/order_service.py: 12 處
- ... (共 67 處)

### 2. 冗餘的集合檢查（23 處）

❌ **錯誤**：
```python
if not items or len(items) == 0:
    # ...
```

✅ **正確**：
```python
if not items:
    # 空集合/列表本身就是 False
    # ...
```

**原因**：
- Python 中空集合即 False
- len() 調用是多餘的

### 3. 裸 except 子句（15 處）

❌ **錯誤**：
```python
try:
    # ...
except:  # 捕獲所有異常，包括 KeyboardInterrupt
    return None
```

✅ **正確**：
```python
try:
    # ...
except Exception as e:  # 只捕獲 Exception 子類
    logger.error(f"Error: {e}")
    raise
```

### 4. 導入位置不規範（34 處）

❌ **錯誤**：
```python
def check_email(email):
    import re  # 函數內導入
    return re.match(pattern, email)
```

✅ **正確**：
```python
import re  # 文件頂部導入

def check_email(email):
    return re.match(pattern, email)
```

### 修復優先級

🔴 **Critical（必須修復）**：
- 裸 except（15 處）- 可能隱藏嚴重 bug
- None 判斷錯誤（67 處）- 潛在邏輯問題

🟡 **Important（建議修復）**：
- 冗餘檢查（23 處）- 影響可讀性
- 導入位置（34 處）- 影響性能

🟢 **Nice to have**：
- 單雙引號統一 - 自動化工具處理（black）
```

**檢查點**：
- [ ] 找出所有格式問題
- [ ] 理解了錯誤原因
- [ ] 知道正確寫法
- [ ] 評估了修復優先級

---

### 階段二：制定重構計劃（15 分鐘）

**目標**：制定安全、可執行的重構計劃

```bash
提示詞：
基於以上分析，請制定詳細的重構計劃：

1. 按影響範圍分組（API、內部方法、工具函數）
2. 每組內按風險排序（高風險先測試，低風險可批量）
3. 每步的測試策略
4. Git 提交策略（什麼時候 commit）

要求：可執行、可追蹤、可回滾
```

**預期計劃**：

```markdown
## 重構執行計劃

### Phase 1: 準備工作（10 分鐘）

#### 1.1 建立安全網
- [ ] 確保所有測試通過
- [ ] 創建重構分支：`git checkout -b refactor/code-style-unification`
- [ ] 備份關鍵配置

#### 1.2 建立風格指南
- [ ] 更新 CLAUDE.md 添加團隊規範
- [ ] 定義異常類體系
- [ ] 準備自動化工具配置（.flake8, pyproject.toml）

### Phase 2: Critical 修復（20 分鐘）

#### 2.1 修復裸 except（15 處）

**執行**：
```bash
/grep "except:" --type py -C 3
# 逐個修改為 except Exception as e
```

**測試**：每修改 5 個，運行一次測試
**提交**：`git commit -m "fix: replace bare except with explicit Exception handling"`

#### 2.2 修復 None 判斷（67 處）

**執行**：
```bash
# 可以使用 sed 批量替換
find . -name "*.py" -exec sed -i 's/== None/is None/g' {} \;
find . -name "*.py" -exec sed -i 's/!= None/is not None/g' {} \;
```

**測試**：運行完整測試套件
**提交**：`git commit -m "style: use 'is None' instead of '== None'"`

### Phase 3: API 層重構（30 分鐘）

#### 3.1 統一公開 API 命名（12 處，高優先）

**重點方法**：
1. UserService.GetUserById → get_user_by_id
2. UserService.createUser → create_user
3. ProductService.Get_Product → get_product
4. ProductService.UpdateProduct → update_product

**執行策略**：
- 使用 IDE 重構功能（自動更新所有引用）
- 每個類重構後運行測試
- 一個類一個 commit

**測試**：
```bash
# 每個服務重構後
pytest tests/test_user_service.py -v
pytest tests/test_product_service.py -v
```

**提交**：
```bash
git commit -m "refactor(user-service): rename methods to follow snake_case convention"
git commit -m "refactor(product-service): rename methods to follow snake_case convention"
```

#### 3.2 統一錯誤處理（API 層優先，28 處）

**策略**：
- 先添加異常類（不破壞現有代碼）
- 創建適配層（同時支持舊/新方式）
- 逐步遷移
- 移除舊代碼

**示例遷移**：

```python
# Step 1: 添加新方法（不刪除舊方法）
def get_user_by_id(self, user_id):
    """新方法：拋出異常"""
    user = self.db.query(User).filter_by(id=user_id).first()
    if user is None:
        raise NotFoundError(f"User {user_id} not found")
    return user

def GetUserById(self, userId):
    """舊方法：標記為廢棄，內部調用新方法"""
    import warnings
    warnings.warn("GetUserById is deprecated, use get_user_by_id", DeprecationWarning)
    try:
        return self.get_user_by_id(userId)
    except NotFoundError:
        return None  # 保持舊行為

# Step 2: 更新呼叫方使用新方法

# Step 3: 移除舊方法
```

**提交**：每個服務一個 commit

### Phase 4: 內部方法與工具函數（20 分鐘）

#### 4.1 重命名輔助函數（20 處）

**批量處理**：
- ValidatePhoneNumber → validate_phone_number
- FormatDateTime → format_datetime
- Check_Email → check_email

**工具**：使用 IDE 批量重構或編寫腳本

#### 4.2 消除模糊命名（67 處）

**分批處理**：
- p → product
- d → date / data（根據上下文）
- u → user
- i → item / index（根據上下文）

**策略**：優先修改高頻使用的變數

### Phase 5: 自動化格式化（5 分鐘）

#### 5.1 使用 black 統一格式

```bash
# 安裝
pip install black isort

# 格式化所有文件
black src/ tests/

# 排序 import
isort src/ tests/
```

#### 5.2 提交格式化變更

```bash
git commit -m "style: apply black formatting to entire codebase"
git commit -m "style: sort imports with isort"
```

### Phase 6: 文檔與配置（10 分鐘）

#### 6.1 更新 CLAUDE.md

添加團隊代碼規範：
- 命名規範
- 錯誤處理標準
- 格式要求

#### 6.2 配置 pre-commit hooks

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.0.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
  - repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
      - id: flake8
```

### 驗證清單

每個 Phase 完成後檢查：

- [ ] 所有測試通過
- [ ] 代碼可以正常運行
- [ ] Git commit 信息清晰
- [ ] 沒有遺漏的問題

### 回滾計劃

如果出現問題：

```bash
# 回滾到特定 commit
git reset --hard <commit-hash>

# 或撤銷最後一次 commit
git reset --soft HEAD~1
```

### 時間估算

| Phase | 時間 | 風險 |
|-------|------|------|
| Phase 1 | 10 min | 低 |
| Phase 2 | 20 min | 低（純格式） |
| Phase 3 | 30 min | 中（影響 API） |
| Phase 4 | 20 min | 低 |
| Phase 5 | 5 min | 極低（自動化） |
| Phase 6 | 10 min | 低 |
| **總計** | **95 min** | - |
```

**檢查點**：
- [ ] 制定了詳細的執行計劃
- [ ] 評估了風險
- [ ] 確定了測試策略
- [ ] 規劃了 Git 提交

---

### 階段三：執行重構（50 分鐘）

**目標**：按計劃安全地執行重構

#### 執行要點

1. **小步前進**：每次只改一類問題
2. **頻繁測試**：每 5-10 個修改運行一次測試
3. **及時提交**：每完成一個邏輯單元就 commit
4. **保持專注**：不要順手修改計劃外的問題

#### 使用 Claude 輔助執行

```bash
# 示例：批量修改 None 判斷

提示詞：
請幫我修改以下文件中的 None 判斷方式：
- src/api/user_service.py
- src/api/product_service.py

要求：
1. 將所有 == None 改為 is None
2. 將所有 != None 改為 is not None
3. 保持其他代碼不變
4. 每個文件分別輸出修改後的完整代碼
```

```bash
# 示例：重命名方法

提示詞：
請重構 UserService 類：

1. GetUserById → get_user_by_id
2. createUser → create_user
3. 同時更新 docstring
4. 添加類型提示

輸出重構後的完整代碼，我會用 /write 寫入文件。
```

**檢查點**：
- [ ] 按計劃執行每個 Phase
- [ ] 每步都運行了測試
- [ ] Git 歷史清晰可追溯
- [ ] 沒有破壞現有功能

---

### 階段四：驗證與文檔化（5 分鐘）

**目標**：確保重構成功，沉澱經驗

#### 步驟 1：最終驗證

```bash
# 運行完整測試套件
pytest tests/ -v

# 檢查代碼風格
flake8 src/ tests/

# 檢查覆蓋率（確保沒有下降）
pytest --cov=src --cov-report=term-missing
```

#### 步驟 2：生成重構報告

```bash
提示詞：
請生成一份重構報告，包含：

1. 修改統計（多少個文件、多少處修改）
2. 修改前後對比示例
3. 改進效果（可讀性、一致性）
4. 遺留問題（如果有）
5. 後續建議

使用表格和代碼塊展示。
```

#### 步驟 3：沉澱到記憶庫

```bash
/memory save

主題：代碼風格統一重構最佳實踐

核心流程：
1. 掃描與分類（/grep 批量查找）
   - 命名問題：def [A-Z], class [a-z]
   - 格式問題：== None, != None, 裸 except
   - 錯誤處理：return None, return -1
   - 按影響範圍和風險分類

2. 制定計劃
   - 按優先級：Critical → API → 內部 → 工具
   - 按風險：高風險小步測試，低風險可批量
   - Git 策略：每類修改一個 commit
   - 回滾預案

3. 安全執行
   - 小步前進：一次只改一類問題
   - 頻繁測試：每 5-10 處修改測試一次
   - IDE 重構：利用自動重命名功能
   - 保持專注：不順手改其他問題

4. 自動化工具
   - black：代碼格式化
   - isort：import 排序
   - flake8：風格檢查
   - pre-commit：提交前自動檢查

5. 預防機制
   - 更新 CLAUDE.md 記錄規範
   - 配置 pre-commit hooks
   - 代碼審查檢查清單
   - 新人培訓文檔

批量查找模式：
- 函數命名：/grep "def [A-Z]" --type py
- 類命名：/grep "class [a-z]" --type py
- None 判斷：/grep "== None\|!= None" --type py
- 裸 except：/grep "except:" --type py -C 2
- 錯誤返回：/grep "return None\|return -1" --type py

常見錯誤模式：
- 命名：駝峰/蛇形混用，模糊命名（p, d, data）
- 格式：== None, != None, 裸 except
- 錯誤處理：返回 None/錯誤碼/錯誤字典不一致
- 導入：函數內導入，順序混亂

重構風險評估：
- 低風險：格式化（None 判斷、引號統一）→ 可批量
- 中風險：內部方法重命名 → 小步測試
- 高風險：公開 API 重命名 → 謹慎，考慮相容期

相關工具：black, isort, flake8, pre-commit
相關指令：/grep（批量查找），/read（理解上下文）
```

**檢查點**：
- [ ] 所有測試通過
- [ ] 代碼風格一致
- [ ] 生成了重構報告
- [ ] 沉澱了經驗到 /memory

---

## 驗證標準

### 必須達成 ✅

- [ ] 成功統一所有命名規範（函數、方法、變數）
- [ ] 統一了錯誤處理方式（使用異常）
- [ ] 修復了所有格式問題（None 判斷、裸 except）
- [ ] 所有測試通過，功能未破壞
- [ ] 更新了 CLAUDE.md 記錄團隊規範
- [ ] 使用 /memory 沉澱了重構經驗

### 額外成就 🌟

- [ ] 配置了 pre-commit hooks 自動檢查
- [ ] 使用自動化工具（black, isort）
- [ ] 編寫了團隊代碼風格培訓文檔
- [ ] 建立了持續改進機制（定期掃描）
- [ ] Git 歷史清晰，每個 commit 都可獨立審查

---

## 學習反思

### 反思問題

1. **模式識別**：
   - /grep 如何幫助你快速找到所有問題？
   - 正則表達式在批量查找中的作用？
   - 如何確保沒有遺漏？

2. **重構策略**：
   - 為什麼要按優先級和風險分階段執行？
   - 小步前進 vs 大規模修改，各有什麼利弊？
   - 如何平衡重構速度與安全性？

3. **自動化價值**：
   - 哪些工作適合自動化工具？哪些需要人工判斷？
   - pre-commit hooks 如何預防未來的風格問題？
   - 自動化檢查的局限性是什麼？

4. **團隊協作**：
   - 如何讓團隊接受新的代碼規範？
   - 如何處理正在進行的功能開發與重構的衝突？
   - 代碼審查清單如何幫助維持質量？

### 延伸練習

1. **自動化重構腳本**：
   - 編寫 Python 腳本自動執行常見重構
   - 使用 AST（抽象語法樹）分析和修改代碼
   - 集成到 CI/CD 流程

2. **建立風格檢查儀表板**：
   - 統計各類風格問題的趨勢
   - 可視化代碼質量改進
   - 設置質量門檻（quality gates）

3. **處理更複雜的重構**：
   - 統一資料庫查詢模式
   - 統一日誌記錄方式
   - 統一配置管理

---

## 相關資源

### 下一步學習

- **C08**：依賴項升級 - 處理 breaking changes
- **C09**：性能瓶頸優化 - 使用 /grep 找慢查詢
- **C10**：錯誤處理增強 - 系統化改進異常處理

### 工具參考

- **black**：Python 代碼格式化工具
- **isort**：Import 語句排序工具
- **flake8**：代碼風格檢查
- **pylint**：更嚴格的代碼質量工具
- **pre-commit**：Git hooks 框架
- **rope**：Python 重構庫

### 學習資源

- **PEP 8**：Python 官方風格指南
- **《Refactoring》**（Martin Fowler）
- **《Clean Code》**（Robert C. Martin）
- **AST 文檔**：抽象語法樹操作

---

**建議完成時間**：1.5-2 小時
**難度評估**：3/5
**重要度**：4/5（代碼一致性對團隊協作很重要）
**可複用性**：5/5（方法可應用到任何代碼庫）
