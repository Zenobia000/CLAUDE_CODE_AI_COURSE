# C01：開源專案首次貢獻（組合級）

## 情境資訊

**編號**：C01
**難度**：⭐⭐⭐☆☆（組合級）
**預計時間**：1.5 小時
**學習目標**：
- 掌握快速理解陌生程式碼庫的系統化方法
- 熟練使用 /glob、/grep、/read 組合探索專案結構
- 學會使用 /memory 保存專案慣例與模式
- 建立開源貢獻的標準工作流程

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉 Git 基本操作
- 想要開始參與開源專案的開發者

---

## 情境描述

### 背景

你在 GitHub 上發現一個有趣的開源專案 **TaskFlow**（React + TypeScript 的任務管理應用），Star 數 2.3k，活躍維護中。你想為它貢獻代碼，在 Issues 中找到一個標記為 "good first issue" 的任務：

**Issue #342: 添加任務優先級過濾功能**
```
Currently users can only filter tasks by status (todo/done).
We need a new filter option for task priority (low/medium/high).

Requirements:
- Add priority dropdown to filter bar
- Filter should work with existing status filter
- Preserve filter state in URL query params
- Follow existing code conventions
```

這是你第一次為這個專案貢獻，你需要先理解專案結構、編碼規範、測試要求，然後才能動手實作。

### 專案資訊

```bash
# 專案結構預覽
taskflow/
├── src/
│   ├── components/       # 150+ React 組件
│   ├── hooks/           # 自定義 Hooks
│   ├── utils/           # 工具函數
│   ├── types/           # TypeScript 類型定義
│   ├── api/             # API 層
│   └── store/           # 狀態管理
├── tests/
├── docs/
├── package.json
└── CONTRIBUTING.md

總計：
- 187 個 TypeScript 檔案
- 23,456 行程式碼
- 85 個組件
- 你完全沒看過這個專案
```

### 你的任務

1. **探索階段**：快速理解專案結構與編碼規範
2. **定位階段**：找到需要修改的檔案
3. **分析階段**：理解現有過濾器實作方式
4. **實作階段**：添加優先級過濾功能
5. **驗證階段**：確保符合專案標準並通過測試

### 限制條件

- 你沒有時間逐一閱讀 187 個檔案
- 必須遵循專案既有的編碼風格
- 需要與現有過濾器邏輯整合
- 必須通過 ESLint 和測試檢查

---

## 學習重點

1. **系統化探索陌生程式碼庫的方法**
   - 從哪裡開始？先看什麼？
   - 如何快速建立專案心智模型

2. **CLI 工具組合技巧**
   - /glob：找檔案模式
   - /grep：搜尋關鍵程式碼
   - /read：深入理解實作細節
   - --add-dir：動態添加需要的檔案到上下文

3. **知識沉澱與復用**
   - 使用 /memory 記錄專案慣例
   - 保存常見模式以便未來參考

4. **開源貢獻最佳實踐**
   - 如何找到正確的切入點
   - 如何確保程式碼符合專案標準

---

## 建議解決流程

### 階段一：專案概覽與文檔研讀（15 分鐘）

**目標**：建立專案的第一印象，理解貢獻指南

**步驟**：

1. **讀取貢獻指南**
```bash
/read CONTRIBUTING.md
/read README.md
```

**你會學到**：
- 專案的分支策略
- 測試要求
- 提交訊息格式
- 編碼規範

2. **檢視專案結構**
```bash
/glob "src/**/*.ts*"
/glob "src/**/*.test.ts*"
```

**分析輸出**：
```
發現模式：
- 組件都在 src/components/ 下
- 每個組件有對應的 .test.tsx 檔案
- 使用 index.ts 做模組匯出
```

3. **尋找過濾相關的檔案**
```bash
/grep "filter" --type ts -i
```

**預期結果**：
```
找到關鍵檔案：
- src/components/FilterBar/FilterBar.tsx
- src/components/FilterBar/StatusFilter.tsx
- src/hooks/useTaskFilter.ts
- src/store/filterSlice.ts
```

**自然學到的概念**：
- 為什麼先讀文檔？因為可以避免違反專案規範，節省 review 時間
- 為什麼用 /glob 而不是 ls？因為可以找到模式，理解專案組織方式
- 為什麼用 /grep 搜尋？因為能快速定位相關程式碼

**檢查點**：
- [ ] 理解專案的目錄結構慣例
- [ ] 知道測試檔案的命名規則
- [ ] 找到與任務相關的檔案清單（至少 3-5 個）

---

### 階段二：深入分析現有實作（30 分鐘）

**目標**：理解現有的狀態過濾器是如何實作的

**步驟**：

1. **閱讀過濾器組件**
```bash
/read src/components/FilterBar/FilterBar.tsx
/read src/components/FilterBar/StatusFilter.tsx
```

**分析重點**：
```typescript
// 你會發現的模式
import { useTaskFilter } from '@/hooks/useTaskFilter';

const StatusFilter = () => {
  const { status, setStatus } = useTaskFilter();

  return (
    <Select
      value={status}
      onChange={setStatus}
      options={STATUS_OPTIONS}
    />
  );
};
```

**關鍵發現**：
- 使用自定義 Hook `useTaskFilter` 管理過濾狀態
- 組件只負責 UI，邏輯在 Hook 中
- 使用共享的 `Select` 組件

2. **研究狀態管理邏輯**
```bash
/read src/hooks/useTaskFilter.ts
/read src/store/filterSlice.ts
```

**發現的模式**：
```typescript
// useTaskFilter.ts
export const useTaskFilter = () => {
  const dispatch = useDispatch();
  const { status } = useSelector(selectFilters);

  const setStatus = (newStatus: TaskStatus) => {
    dispatch(filterActions.setStatus(newStatus));
    updateURLParams({ status: newStatus });
  };

  return { status, setStatus };
};
```

**關鍵知識點**：
- 使用 Redux Toolkit 管理狀態
- URL 參數與狀態同步（`updateURLParams`）
- 有專門的 selector 函數

3. **查看類型定義**
```bash
/grep "TaskStatus" --type ts
/read src/types/task.ts
```

**發現**：
```typescript
// 現有類型
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  DONE = 'done'
}

// 需要添加
export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high'
}
```

4. **檢查測試案例**
```bash
/read src/components/FilterBar/StatusFilter.test.tsx
/read src/hooks/useTaskFilter.test.ts
```

**學到的測試模式**：
```typescript
// 測試結構
describe('StatusFilter', () => {
  it('renders all status options', () => { ... });
  it('updates state when option selected', () => { ... });
  it('syncs with URL params', () => { ... });
});
```

**自然學到的工作流程**：
- 為什麼從組件開始讀？因為組件是用戶看到的部分，容易理解
- 為什麼接著讀 Hook？因為這裡是業務邏輯所在
- 為什麼要看測試？因為測試揭示了預期行為和邊界情況

**記憶沉澱**：
```bash
/memory save

主題：TaskFlow 專案編碼慣例

發現的模式：
1. 組件結構
   - 組件放在 src/components/<ComponentName>/<ComponentName>.tsx
   - 測試檔案與組件同目錄，命名為 <ComponentName>.test.tsx
   - 使用 index.ts 做統一匯出

2. 狀態管理模式
   - 使用 Redux Toolkit (createSlice)
   - 自定義 Hook 封裝 dispatch 和 selector
   - URL 參數與 Redux 狀態保持同步

3. 過濾器實作模式
   - 過濾狀態存在 store/filterSlice.ts
   - 每種過濾器有獨立的組件（如 StatusFilter）
   - 組件通過 useTaskFilter Hook 存取狀態

4. 命名慣例
   - 組件：PascalCase
   - Hook：use + PascalCase
   - 類型：PascalCase
   - Actions：camelCase

5. 測試要求
   - 每個組件必須有對應測試
   - 測試涵蓋：渲染、用戶互動、狀態同步

下次遇到類似 Redux + React 專案可以直接使用這個模式
```

**檢查點**：
- [ ] 理解過濾器的資料流（Component → Hook → Redux → URL）
- [ ] 知道需要修改哪些檔案（至少 5 個）
- [ ] 理解測試的預期結構
- [ ] 已使用 /memory 保存關鍵慣例

---

### 階段三：規劃實作方案（15 分鐘）

**目標**：制定清晰的實作計劃

**步驟**：

1. **列出需要修改的檔案**
```bash
# 使用 Claude 幫助規劃
基於我對現有 StatusFilter 的理解，請幫我列出添加 PriorityFilter 需要修改的所有檔案，並說明每個檔案需要做什麼。
```

**Claude 可能的回應**：
```markdown
需要修改的檔案：

1. src/types/task.ts
   - 添加 TaskPriority enum
   - 更新 Task interface 包含 priority 欄位

2. src/store/filterSlice.ts
   - 添加 priority 狀態
   - 添加 setPriority action
   - 更新 selector

3. src/hooks/useTaskFilter.ts
   - 添加 priority 和 setPriority 到回傳值
   - 處理 URL 同步

4. src/components/FilterBar/PriorityFilter.tsx（新建）
   - 仿照 StatusFilter 結構
   - 使用 useTaskFilter Hook

5. src/components/FilterBar/PriorityFilter.test.tsx（新建）
   - 仿照 StatusFilter 測試案例

6. src/components/FilterBar/FilterBar.tsx
   - 引入並渲染 PriorityFilter

7. src/components/FilterBar/index.ts
   - 匯出 PriorityFilter
```

2. **確認實作策略**
```bash
# 詢問最佳實踐
請確認以下實作策略是否符合專案慣例：

1. 先添加類型定義
2. 更新 Redux store 和 selector
3. 更新 Hook
4. 建立 PriorityFilter 組件
5. 整合到 FilterBar
6. 撰寫測試

還是有更好的順序？
```

**自然學到的概念**：
- 為什麼要規劃？因為可以避免遺漏步驟，減少返工
- 為什麼請 Claude 幫忙確認？因為 AI 可以指出潛在的遺漏

**檢查點**：
- [ ] 有完整的檔案清單
- [ ] 理解每個檔案的修改目的
- [ ] 確定實作順序

---

### 階段四：分步驟實作（40 分鐘）

**目標**：按計劃實作功能

**步驟**：

1. **添加類型定義**
```bash
/read src/types/task.ts

# 請求 Claude 幫助
請參考現有的 TaskStatus enum，幫我添加 TaskPriority enum 和更新 Task interface。
保持與專案風格一致。
```

**Claude 產生的程式碼**：
```typescript
// 添加到 src/types/task.ts

export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high'
}

export interface Task {
  id: string;
  title: string;
  status: TaskStatus;
  priority: TaskPriority; // 新增
  createdAt: Date;
  updatedAt: Date;
}

export const PRIORITY_OPTIONS = [
  { value: TaskPriority.LOW, label: 'Low' },
  { value: TaskPriority.MEDIUM, label: 'Medium' },
  { value: TaskPriority.HIGH, label: 'High' }
];
```

2. **更新 Redux store**
```bash
/read src/store/filterSlice.ts

# 請求修改
請參考現有的 status 狀態，添加 priority 相關的狀態和 action。
```

**產生的修改**：
```typescript
// 更新 src/store/filterSlice.ts

interface FilterState {
  status: TaskStatus | null;
  priority: TaskPriority | null; // 新增
}

const initialState: FilterState = {
  status: null,
  priority: null // 新增
};

const filterSlice = createSlice({
  name: 'filters',
  initialState,
  reducers: {
    setStatus: (state, action: PayloadAction<TaskStatus | null>) => {
      state.status = action.payload;
    },
    setPriority: (state, action: PayloadAction<TaskPriority | null>) => { // 新增
      state.priority = action.payload;
    },
    clearFilters: (state) => {
      state.status = null;
      state.priority = null; // 新增
    }
  }
});

// 更新 selector
export const selectFilters = (state: RootState) => state.filters;
```

3. **更新 Hook**
```bash
/read src/hooks/useTaskFilter.ts

# 請求修改
請添加 priority 相關的邏輯，仿照 status 的模式。
```

4. **建立 PriorityFilter 組件**
```bash
/read src/components/FilterBar/StatusFilter.tsx

# 請求建立
請基於 StatusFilter 的結構，建立 PriorityFilter 組件。
檔案路徑：src/components/FilterBar/PriorityFilter.tsx
```

**產生的組件**：
```typescript
// src/components/FilterBar/PriorityFilter.tsx

import React from 'react';
import { Select } from '@/components/common/Select';
import { useTaskFilter } from '@/hooks/useTaskFilter';
import { PRIORITY_OPTIONS } from '@/types/task';

export const PriorityFilter: React.FC = () => {
  const { priority, setPriority } = useTaskFilter();

  return (
    <Select
      value={priority}
      onChange={setPriority}
      options={PRIORITY_OPTIONS}
      placeholder="Filter by priority"
      aria-label="Priority filter"
    />
  );
};
```

5. **整合到 FilterBar**
```bash
/read src/components/FilterBar/FilterBar.tsx

# 請求修改
請在 FilterBar 中引入並渲染 PriorityFilter，放在 StatusFilter 旁邊。
```

6. **建立測試**
```bash
/read src/components/FilterBar/StatusFilter.test.tsx

# 請求建立
請基於 StatusFilter 的測試，建立 PriorityFilter.test.tsx。
```

**產生的測試**：
```typescript
// src/components/FilterBar/PriorityFilter.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { PriorityFilter } from './PriorityFilter';
import { store } from '@/store';

describe('PriorityFilter', () => {
  it('renders all priority options', () => {
    render(
      <Provider store={store}>
        <PriorityFilter />
      </Provider>
    );

    const select = screen.getByLabelText('Priority filter');
    expect(select).toBeInTheDocument();
  });

  it('updates state when option selected', () => {
    // ... (仿照 StatusFilter 測試)
  });

  it('syncs with URL params', () => {
    // ...
  });
});
```

7. **更新匯出**
```bash
/read src/components/FilterBar/index.ts

# 請求修改
請添加 PriorityFilter 的匯出。
```

**自然學到的實作模式**：
- 為什麼從類型開始？因為類型是契約，先定義好可以避免後續錯誤
- 為什麼先改 store 再改 Hook？因為 Hook 依賴 store
- 為什麼最後寫測試？其實應該先寫（TDD），但這裡為了教學順序調整

**檢查點**：
- [ ] 所有檔案都已修改或建立
- [ ] 程式碼風格與專案一致
- [ ] 沒有 TypeScript 錯誤

---

### 階段五：驗證與測試（20 分鐘）

**目標**：確保功能正常且符合專案標準

**步驟**：

1. **執行 TypeScript 檢查**
```bash
# 在終端執行
npm run type-check
```

**預期輸出**：
```
✓ No TypeScript errors found
```

2. **執行測試**
```bash
npm test -- PriorityFilter
```

**預期輸出**：
```
PASS src/components/FilterBar/PriorityFilter.test.tsx
  PriorityFilter
    ✓ renders all priority options (45ms)
    ✓ updates state when option selected (32ms)
    ✓ syncs with URL params (28ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
```

3. **執行 ESLint**
```bash
npm run lint
```

**如果有錯誤**：
```bash
# 請 Claude 幫忙修復
我收到以下 ESLint 錯誤：
[貼上錯誤訊息]

請幫我修正，並解釋為什麼會有這個錯誤。
```

4. **手動測試功能**
```bash
npm run dev

# 在瀏覽器中測試：
# 1. 打開過濾器
# 2. 選擇優先級
# 3. 檢查 URL 是否更新
# 4. 檢查任務列表是否正確過濾
# 5. 與狀態過濾器一起使用
```

5. **使用 Claude 做最後檢查**
```bash
請幫我檢查以下項目是否都符合 TaskFlow 專案規範：

1. 檔案命名
2. 組件結構
3. 測試覆蓋率
4. TypeScript 類型定義
5. 是否有遺漏的邊界情況

我的修改清單：
- src/types/task.ts
- src/store/filterSlice.ts
- src/hooks/useTaskFilter.ts
- src/components/FilterBar/PriorityFilter.tsx
- src/components/FilterBar/PriorityFilter.test.tsx
- src/components/FilterBar/FilterBar.tsx
- src/components/FilterBar/index.ts
```

**自然學到的驗證流程**：
- 為什麼要分階段測試？因為可以快速定位問題
- 為什麼請 Claude 做最後檢查？因為可能遺漏一些細節

**最終記憶沉澱**：
```bash
/memory save

主題：開源專案首次貢獻完整工作流程

階段1️⃣：專案探索（15 min）
- 讀文檔：CONTRIBUTING.md, README.md
- 找模式：/glob 了解目錄結構
- 搜關鍵字：/grep 定位相關檔案

階段2️⃣：深入分析（30 min）
- 讀組件：理解 UI 層實作
- 讀邏輯：理解 Hook 和 Store
- 讀測試：理解預期行為
- 用 /memory 保存專案慣例

階段3️⃣：規劃實作（15 min）
- 列出需要修改的檔案
- 確定修改順序
- 請 Claude 確認計劃

階段4️⃣：實作（40 min）
- 遵循專案現有模式
- 一次修改一個檔案
- 保持與專案風格一致

階段5️⃣：驗證（20 min）
- TypeScript 檢查
- 單元測試
- Linter 檢查
- 手動測試
- 最後審查

關鍵成功因素：
- 不要急著寫程式碼，先理解專案
- 善用 /memory 記錄慣例
- 小步前進，頻繁驗證
- 充分利用 Claude 的模式識別能力

總時間：1.5 小時（含驗證）
```

**檢查點**：
- [ ] 所有測試通過
- [ ] 無 TypeScript 錯誤
- [ ] 無 ESLint 警告
- [ ] 功能正常運作
- [ ] 程式碼符合專案規範

---

## 驗證標準

### 必須達成 ✅

- [ ] 成功找到所有需要修改的檔案（使用 /glob, /grep, /read）
- [ ] 理解並記錄專案的編碼慣例（使用 /memory）
- [ ] 實作的程式碼風格與專案一致
- [ ] 所有測試通過（包括新建的測試）
- [ ] TypeScript 和 ESLint 檢查通過
- [ ] 功能正常運作（手動測試確認）
- [ ] 使用 /memory 至少保存 2 個知識點

### 額外成就 🌟

- [ ] 發現並修正專案中的現有 bug
- [ ] 添加額外的邊界情況測試
- [ ] 改進現有文檔（如 README）
- [ ] 建立 PR 模板（基於專案慣例）
- [ ] 優化現有的過濾器邏輯
- [ ] 完成整個流程不超過 1.5 小時

---

## 學習反思

### 反思問題

1. **探索策略**：
   - 你用什麼順序探索專案？為什麼選這個順序？
   - 哪些 CLI 工具組合最有效？
   - 如果再做一次，你會改變什麼？

2. **模式識別**：
   - 你如何快速識別專案的編碼模式？
   - /memory 在哪些時機點最有價值？
   - 如何判斷是否已經理解專案結構？

3. **工具使用**：
   - /glob、/grep、/read 各在什麼情境最適用？
   - 何時應該 --add-dir 添加整個目錄？
   - 如何平衡閱讀廣度與深度？

4. **實作策略**：
   - 遵循現有模式重要嗎？為什麼？
   - 如何確保沒有遺漏必要的修改？
   - 測試驅動開發在這種情境下適用嗎？

### 延伸練習

1. **進階功能**：
   - 添加多選過濾（可同時選多個優先級）
   - 添加過濾器組合邏輯（AND/OR）
   - 添加過濾器預設值功能

2. **效能優化**：
   - 分析過濾邏輯的效能瓶頸
   - 添加 debounce 優化 URL 更新
   - 使用 React.memo 減少不必要的重渲染

3. **流程自動化**：
   - 建立腳本自動檢查程式碼規範
   - 建立 Git pre-commit hook 自動執行測試
   - 建立 PR checklist 確保不遺漏步驟

4. **知識管理**：
   - 整理成「開源貢獻 SOP」文件
   - 建立專案探索檢查清單
   - 為其他專案建立類似的探索筆記

---

## 相關資源

### 下一步學習

- **C02：API版本遷移** - 學習系統化修改大量檔案
- **C04：功能模組提取** - 學習識別模組邊界
- **模組 3：IDE整合實戰** - 學習在 IDE 中使用 AI 加速開發

### 工具參考

- **GitHub CLI (`gh`)** - 管理 Issues 和 PR
- **ESLint** - 程式碼風格檢查
- **Jest** - JavaScript 測試框架
- **React Testing Library** - React 組件測試

### 開源貢獻資源

- **First Timers Only** (https://www.firsttimersonly.com/) - 新手友善專案
- **Good First Issue** (https://goodfirstissue.dev/) - 適合新手的 Issues
- **How to Contribute to Open Source** (https://opensource.guide/how-to-contribute/)

### 相關概念

- **Repository Pattern** - 資料存取抽象
- **Redux Toolkit** - 狀態管理
- **React Hooks** - React 狀態邏輯復用
- **URL State Management** - URL 與應用狀態同步

---

**建議完成時間**：1.5-2 小時（含反思與延伸）
**難度評估**：3/5
**重要度**：5/5（開源貢獻是開發者職涯的重要技能）
**可複用性**：5/5（此流程可應用到任何開源專案）
