# C10：錯誤處理增強（組合級）

## 情境資訊

**編號**：C10
**難度**：⭐⭐⭐☆☆（組合級）
**預計時間**：1.5 小時
**學習目標**：
- 掌握使用 /grep 查找錯誤處理問題
- 學會系統化改進異常處理
- 練習建立統一的錯誤處理架構
- 建立錯誤處理最佳實踐清單

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉 Python 異常處理機制
- 需要改進代碼健壯性

---

## 情境描述

### 背景

你在一家金融科技公司負責支付系統的維護。最近一個月，生產環境頻繁出現神秘的錯誤：

- **用戶投訴**：支付失敗但不知道原因（只顯示"系統錯誤"）
- **運維困擾**：日誌缺失關鍵信息，難以定位問題
- **數據不一致**：某些錯誤導致訂單狀態異常
- **安全隱患**：錯誤信息洩漏敏感數據

昨天發生了一起嚴重事故：支付接口異常，但錯誤沒有被正確捕獲，導致 500 個訂單狀態不一致。老闆要求你在一週內系統化地改進所有錯誤處理。

### 現有代碼問題

```python
# apps/payments/services.py

import requests
from decimal import Decimal
from .models import Payment, Transaction

class PaymentService:
    """支付服務 - 充滿錯誤處理問題"""

    def process_payment(self, order_id, amount, payment_method):
        """處理支付 - 問題 1：裸 except，吞掉所有異常"""
        try:
            # 創建支付記錄
            payment = Payment.objects.create(
                order_id=order_id,
                amount=amount,
                payment_method=payment_method,
                status='pending'
            )

            # 調用第三方支付 API
            result = self._call_payment_gateway(payment)

            # 更新支付狀態
            payment.status = 'completed'
            payment.transaction_id = result['transaction_id']
            payment.save()

            return True
        except:  # ❌ 裸 except，捕獲所有異常包括 KeyboardInterrupt
            return False  # ❌ 只返回 False，不知道失敗原因


    def _call_payment_gateway(self, payment):
        """調用支付網關 - 問題 2：未處理網絡異常"""
        url = "https://api.payment-gateway.com/charge"
        data = {
            "amount": payment.amount,
            "currency": "USD",
            "payment_method": payment.payment_method
        }

        # ❌ 沒有處理 requests.exceptions（超時、網絡錯誤等）
        response = requests.post(url, json=data)

        # ❌ 沒有檢查 HTTP 狀態碼
        return response.json()


    def refund_payment(self, payment_id, reason):
        """退款 - 問題 3：錯誤信息洩漏敏感數據"""
        payment = Payment.objects.get(id=payment_id)

        # ❌ 如果 payment 不存在，拋出異常，暴露數據庫結構
        if payment.status != 'completed':
            raise Exception(f"Cannot refund payment {payment_id} with status {payment.status}")
            # ❌ 使用通用 Exception，難以捕獲特定錯誤

        try:
            result = self._call_refund_api(payment)
            payment.status = 'refunded'
            payment.save()
            return True
        except Exception as e:
            # ❌ 錯誤信息可能包含敏感數據
            print(f"Refund failed: {e}")  # ❌ 使用 print，日誌不完整
            return False


    def check_payment_status(self, order_id):
        """檢查支付狀態 - 問題 4：返回值不一致"""
        payment = Payment.objects.filter(order_id=order_id).first()

        if not payment:
            return None  # ❌ 有時返回 None

        if payment.status == 'completed':
            return True  # ❌ 有時返回 True
        else:
            return False  # ❌ 有時返回 False
            # ❌ 返回類型不一致，呼叫方難以處理


# apps/orders/services.py

class OrderService:
    """訂單服務"""

    def create_order(self, user_id, items):
        """創建訂單 - 問題 5：缺少事務控制"""
        # 創建訂單
        order = Order.objects.create(
            user_id=user_id,
            status='pending'
        )

        # 創建訂單項
        for item in items:
            OrderItem.objects.create(
                order=order,
                product_id=item['product_id'],
                quantity=item['quantity']
            )
            # ❌ 如果中途失敗，前面的 OrderItem 已經創建，數據不一致

        # 扣減庫存
        for item in items:
            product = Product.objects.get(id=item['product_id'])
            # ❌ 如果 product 不存在，拋出異常，訂單已創建但庫存未扣
            product.stock -= item['quantity']
            if product.stock < 0:
                # ❌ 拋出異常，但訂單和訂單項已創建
                raise ValueError("Insufficient stock")
            product.save()

        return order


    def cancel_order(self, order_id):
        """取消訂單 - 問題 6：錯誤處理不完整"""
        order = Order.objects.get(id=order_id)
        # ❌ 如果訂單不存在，拋出 DoesNotExist 異常，沒有處理

        if order.status == 'cancelled':
            # ❌ 重複取消，但沒有明確的錯誤處理
            return

        # 回滾庫存
        for item in order.items.all():
            product = item.product
            product.stock += item.quantity
            product.save()
            # ❌ 如果 save() 失敗，前面的已經更新，數據不一致

        order.status = 'cancelled'
        order.save()


# apps/api/views.py

from rest_framework.views import APIView
from rest_framework.response import Response

class PaymentAPIView(APIView):
    """支付 API - 問題 7：API 錯誤處理不統一"""

    def post(self, request):
        order_id = request.data.get('order_id')
        amount = request.data.get('amount')

        # ❌ 沒有參數驗證
        if not order_id:
            return Response({'error': 'Missing order_id'}, status=400)
            # ❌ 錯誤格式不統一

        try:
            service = PaymentService()
            result = service.process_payment(order_id, amount, 'credit_card')

            if result:
                return Response({'success': True})
            else:
                # ❌ 不知道失敗原因，用戶只看到 "失敗"
                return Response({'error': 'Payment failed'}, status=500)

        except Exception as e:
            # ❌ 返回原始異常信息，可能洩漏敏感數據
            return Response({'error': str(e)}, status=500)


# apps/utils/logger.py

import logging

logger = logging.getLogger(__name__)

def log_error(message):
    """記錄錯誤 - 問題 8：日誌信息不完整"""
    logger.error(message)  # ❌ 沒有上下文信息（用戶、請求、堆疊）


# 問題 9：沒有統一的異常類體系

# 問題 10：沒有錯誤監控和告警
```

### 典型錯誤場景

**場景 1：支付失敗，數據不一致**

```python
# 創建了 Payment 記錄（status='pending'）
payment = Payment.objects.create(...)

# 調用支付 API 失敗（網絡超時）
result = self._call_payment_gateway(payment)  # 拋出異常

# ❌ 異常被裸 except 吞掉，返回 False
# ❌ Payment 記錄狀態仍是 'pending'，但支付實際失敗
# ❌ 訂單系統以為支付正在處理
```

**場景 2：創建訂單失敗，庫存已扣**

```python
# 創建訂單成功
order = Order.objects.create(...)

# 創建第 1 個訂單項成功
OrderItem.objects.create(...)

# 創建第 2 個訂單項時，商品不存在
OrderItem.objects.create(product_id='NOT_EXIST')  # 拋出異常

# ❌ 異常未處理，訂單和第 1 個訂單項已創建
# ❌ 如果已經扣庫存，庫存也無法回滾
```

**場景 3：錯誤信息洩漏**

```python
# 用戶請求退款，但支付 ID 錯誤
refund_payment('invalid_id', 'reason')

# 拋出異常：
# Exception: Payment matching query does not exist.

# ❌ 錯誤返回給前端，洩漏了數據庫模型信息
# ❌ 攻擊者可以推測數據庫結構
```

### 你的任務

系統化地改進錯誤處理：

1. **識別問題**：找出所有錯誤處理問題
2. **設計架構**：建立統一的異常類和錯誤處理機制
3. **重構代碼**：
   - 替換裸 except
   - 添加事務控制
   - 統一 API 錯誤格式
   - 完善日誌記錄
4. **建立監控**：實現錯誤追蹤和告警

---

## 學習重點

### 目標 1：使用 /grep 查找錯誤處理問題

學會識別常見錯誤處理反模式：
- 裸 except 子句
- 返回值不一致
- 缺少日誌記錄
- 錯誤信息洩漏
- 缺少事務控制

### 目標 2：設計異常處理架構

建立完善的異常體系：
- 自定義異常類層級
- 異常處理中間件
- 統一錯誤響應格式
- 錯誤碼設計

### 目標 3：事務控制與數據一致性

掌握數據一致性保障：
- 數據庫事務（atomic）
- 補償機制（Saga）
- 冪等性設計
- 分佈式事務

### 目標 4：日誌與監控

建立完善的錯誤追蹤：
- 結構化日誌
- 上下文信息（用戶、請求、堆疊）
- 錯誤聚合和告警（Sentry）
- 可觀測性

---

## 建議解決流程

### 階段一：識別錯誤處理問題（20 分鐘）

**目標**：找出所有錯誤處理問題

#### 步驟 1：查找裸 except

```bash
/grep "except:" --type py -C 3

提示詞：
請找出所有裸 except 子句（except: 而不是 except Exception:）：

1. 統計數量和位置
2. 分析每個 except 的問題
3. 評估影響（可能隱藏哪些異常？）
4. 提供修復方案

對於每個裸 except，說明應該捕獲哪些具體異常。
```

**預期輸出**：

```markdown
## 裸 Except 問題清單

### 問題 1：支付處理的裸 except（高風險）

**位置**：apps/payments/services.py:25

```python
try:
    # ... 支付邏輯 ...
    payment.save()
    return True
except:  # ❌ 裸 except
    return False
```

**問題**：
- 捕獲所有異常，包括 SystemExit, KeyboardInterrupt
- 數據庫錯誤、網絡錯誤、業務錯誤全部被吞掉
- 只返回 False，不知道失敗原因
- Payment 記錄可能處於不一致狀態

**修復方案**：
```python
try:
    # ... 支付邏輯 ...
    payment.save()
    return payment
except PaymentGatewayError as e:
    # 支付網關錯誤
    logger.error(f"Payment gateway error: {e}", exc_info=True)
    payment.status = 'failed'
    payment.error_message = str(e)
    payment.save()
    raise
except requests.exceptions.RequestException as e:
    # 網絡錯誤
    logger.error(f"Network error during payment: {e}", exc_info=True)
    raise PaymentNetworkError("Payment service unavailable") from e
except Exception as e:
    # 其他錯誤
    logger.critical(f"Unexpected payment error: {e}", exc_info=True)
    raise
```

---

### 總計：找到 **8 個裸 except**

| 位置 | 風險等級 | 影響 |
|------|---------|------|
| payments/services.py:25 | 高 | 數據不一致 |
| orders/services.py:45 | 高 | 庫存錯誤 |
| api/views.py:67 | 中 | 用戶體驗差 |
| utils/helpers.py:12 | 低 | 日誌缺失 |
```

**檢查點**：
- [ ] 找出所有裸 except
- [ ] 評估了風險
- [ ] 提供了修復方案

---

#### 步驟 2：查找返回值不一致

```bash
/grep "return None\|return True\|return False" --type py -C 2

提示詞：
請找出返回值類型不一致的函數：

1. 有時返回 None，有時返回對象
2. 有時返回 True/False，有時返回對象
3. 有時返回數據，有時返回錯誤信息

對每個函數提供統一的返回值設計。
```

**預期輸出**：

```markdown
## 返回值不一致問題

### 問題 1：check_payment_status 返回類型不一致

**位置**：apps/payments/services.py:78

```python
def check_payment_status(self, order_id):
    payment = Payment.objects.filter(order_id=order_id).first()

    if not payment:
        return None  # ❌ 返回 None

    if payment.status == 'completed':
        return True  # ❌ 返回 True
    else:
        return False  # ❌ 返回 False
```

**問題**：
- 返回類型：None | bool
- 呼叫方需要判斷類型：`if result is None` vs `if result`
- 容易出錯

**修復方案 1：統一返回對象**
```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class PaymentStatus:
    exists: bool
    is_completed: bool
    status: Optional[str]

def check_payment_status(self, order_id) -> PaymentStatus:
    payment = Payment.objects.filter(order_id=order_id).first()

    if not payment:
        return PaymentStatus(exists=False, is_completed=False, status=None)

    return PaymentStatus(
        exists=True,
        is_completed=(payment.status == 'completed'),
        status=payment.status
    )
```

**修復方案 2：使用異常表示錯誤**
```python
def check_payment_status(self, order_id) -> str:
    """返回支付狀態，如果不存在則拋出異常"""
    payment = Payment.objects.filter(order_id=order_id).first()

    if not payment:
        raise PaymentNotFoundError(f"Payment for order {order_id} not found")

    return payment.status
```

---

### 總計：找到 **12 個返回值不一致的函數**
```

**檢查點**：
- [ ] 找出返回值不一致的函數
- [ ] 提供了統一的設計方案

---

#### 步驟 3：查找缺少事務控制

```bash
/grep "\.save\(\)" --type py -C 5

提示詞：
請找出缺少事務控制的多步驟操作：

1. 多個 .save() 操作
2. 多個 .create() 操作
3. 涉及多個模型的更新
4. 中途可能失敗的操作

對每個場景說明為什麼需要事務，以及如何添加。
```

**預期輸出**：

```markdown
## 缺少事務控制問題

### 問題 1：創建訂單缺少事務（嚴重）

**位置**：apps/orders/services.py:23

```python
def create_order(self, user_id, items):
    # Step 1: 創建訂單
    order = Order.objects.create(...)  # ✓ 成功

    # Step 2: 創建訂單項
    for item in items:
        OrderItem.objects.create(...)  # ✓ 成功 2 個
        # ❌ 第 3 個失敗，前 2 個已經創建

    # Step 3: 扣減庫存
    for item in items:
        product.stock -= item['quantity']
        product.save()  # ❌ 還沒執行
```

**問題**：
- 3 步操作沒有事務保護
- 任何一步失敗，前面的已經提交
- 數據不一致：訂單創建但訂單項缺失

**修復方案**：
```python
from django.db import transaction

@transaction.atomic
def create_order(self, user_id, items):
    """使用 atomic 裝飾器，自動回滾"""
    # Step 1: 創建訂單
    order = Order.objects.create(
        user_id=user_id,
        status='pending'
    )

    # Step 2: 創建訂單項
    for item in items:
        OrderItem.objects.create(
            order=order,
            product_id=item['product_id'],
            quantity=item['quantity']
        )

    # Step 3: 扣減庫存
    for item in items:
        product = Product.objects.select_for_update().get(
            id=item['product_id']
        )  # 行鎖，防止併發
        if product.stock < item['quantity']:
            raise InsufficientStockError(
                f"Product {product.name} has insufficient stock"
            )
        product.stock -= item['quantity']
        product.save()

    return order

# 如果任何步驟拋出異常，整個事務回滾
```

---

### 總計：找到 **5 個缺少事務控制的操作**
```

**檢查點**：
- [ ] 找出缺少事務的操作
- [ ] 理解了事務的重要性
- [ ] 提供了修復方案

---

### 階段二：設計錯誤處理架構（25 分鐘）

**目標**：建立統一的異常體系和錯誤處理機制

#### 步驟 1：設計異常類層級

```bash
提示詞：
請為支付系統設計完整的異常類體系：

1. 基礎異常類
2. 業務異常（支付失敗、庫存不足等）
3. 技術異常（網絡錯誤、數據庫錯誤等）
4. 每個異常包含：錯誤碼、用戶消息、開發者消息

要求：
- 清晰的層級結構
- 易於擴展
- 包含必要的上下文信息
```

**設計方案**：

```python
# apps/core/exceptions.py

class AppException(Exception):
    """應用異常基類"""

    def __init__(
        self,
        message: str,
        error_code: str = None,
        user_message: str = None,
        status_code: int = 500,
        details: dict = None
    ):
        self.message = message  # 開發者看的詳細信息
        self.error_code = error_code or 'UNKNOWN_ERROR'
        self.user_message = user_message or '系統錯誤，請稍後重試'
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)

    def to_dict(self):
        """轉換為 API 響應格式"""
        return {
            'error_code': self.error_code,
            'message': self.user_message,
            'details': self.details
        }


# 業務異常（400-499）

class BusinessException(AppException):
    """業務異常基類"""
    def __init__(self, message, error_code, user_message, details=None):
        super().__init__(
            message=message,
            error_code=error_code,
            user_message=user_message,
            status_code=400,
            details=details
        )


class ValidationError(BusinessException):
    """驗證錯誤"""
    def __init__(self, message, field=None):
        super().__init__(
            message=message,
            error_code='VALIDATION_ERROR',
            user_message='輸入信息不正確，請檢查',
            details={'field': field} if field else {}
        )


class InsufficientStockError(BusinessException):
    """庫存不足"""
    def __init__(self, product_name, available, requested):
        super().__init__(
            message=f"Insufficient stock for {product_name}",
            error_code='INSUFFICIENT_STOCK',
            user_message=f'商品 {product_name} 庫存不足',
            details={
                'available': available,
                'requested': requested
            }
        )


class PaymentFailedError(BusinessException):
    """支付失敗"""
    def __init__(self, reason, transaction_id=None):
        super().__init__(
            message=f"Payment failed: {reason}",
            error_code='PAYMENT_FAILED',
            user_message='支付失敗，請檢查支付信息或稍後重試',
            details={'transaction_id': transaction_id}
        )


# 資源異常（404）

class ResourceNotFoundException(AppException):
    """資源未找到"""
    def __init__(self, resource_type, resource_id):
        super().__init__(
            message=f"{resource_type} {resource_id} not found",
            error_code='RESOURCE_NOT_FOUND',
            user_message=f'{resource_type}不存在',
            status_code=404,
            details={'resource_type': resource_type, 'resource_id': resource_id}
        )


class OrderNotFoundError(ResourceNotFoundException):
    """訂單未找到"""
    def __init__(self, order_id):
        super().__init__('Order', order_id)


class PaymentNotFoundError(ResourceNotFoundException):
    """支付未找到"""
    def __init__(self, payment_id):
        super().__init__('Payment', payment_id)


# 技術異常（500-599）

class TechnicalException(AppException):
    """技術異常基類"""
    def __init__(self, message, error_code, details=None):
        super().__init__(
            message=message,
            error_code=error_code,
            user_message='系統繁忙，請稍後重試',
            status_code=500,
            details=details
        )


class PaymentGatewayError(TechnicalException):
    """支付網關錯誤"""
    def __init__(self, gateway_message, gateway_code=None):
        super().__init__(
            message=f"Payment gateway error: {gateway_message}",
            error_code='PAYMENT_GATEWAY_ERROR',
            details={
                'gateway_message': gateway_message,
                'gateway_code': gateway_code
            }
        )


class PaymentNetworkError(TechnicalException):
    """支付網絡錯誤"""
    def __init__(self, message):
        super().__init__(
            message=f"Network error: {message}",
            error_code='PAYMENT_NETWORK_ERROR'
        )


class DatabaseError(TechnicalException):
    """數據庫錯誤"""
    def __init__(self, operation, message):
        super().__init__(
            message=f"Database {operation} error: {message}",
            error_code='DATABASE_ERROR',
            details={'operation': operation}
        )


# 權限異常（401, 403）

class PermissionDeniedError(AppException):
    """權限不足"""
    def __init__(self, action, resource):
        super().__init__(
            message=f"Permission denied for {action} on {resource}",
            error_code='PERMISSION_DENIED',
            user_message='您沒有權限執行此操作',
            status_code=403,
            details={'action': action, 'resource': resource}
        )
```

#### 步驟 2：實現統一的錯誤處理中間件

```python
# apps/core/middleware.py

import logging
import traceback
from django.http import JsonResponse
from .exceptions import AppException

logger = logging.getLogger(__name__)

class ErrorHandlingMiddleware:
    """統一錯誤處理中間件"""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        try:
            response = self.get_response(request)
            return response
        except AppException as e:
            # 業務異常：記錄警告
            logger.warning(
                f"Business exception: {e.error_code}",
                extra={
                    'error_code': e.error_code,
                    'user_id': getattr(request.user, 'id', None),
                    'path': request.path,
                    'details': e.details
                }
            )
            return JsonResponse(e.to_dict(), status=e.status_code)

        except Exception as e:
            # 未預期的異常：記錄錯誤
            logger.error(
                f"Unexpected error: {str(e)}",
                exc_info=True,
                extra={
                    'user_id': getattr(request.user, 'id', None),
                    'path': request.path,
                    'method': request.method
                }
            )

            # 生產環境不暴露詳細錯誤
            return JsonResponse({
                'error_code': 'INTERNAL_ERROR',
                'message': '系統錯誤，請聯繫客服',
                'details': {}
            }, status=500)

    def process_exception(self, request, exception):
        """Django 會調用這個方法處理視圖中的異常"""
        # 已經在 __call__ 中處理，這裡返回 None
        return None
```

#### 步驟 3：實現結構化日誌

```python
# apps/core/logging.py

import logging
import json
from datetime import datetime

class StructuredLogger:
    """結構化日誌記錄器"""

    def __init__(self, name):
        self.logger = logging.getLogger(name)

    def log_error(
        self,
        message,
        error_code=None,
        user_id=None,
        order_id=None,
        payment_id=None,
        exception=None,
        **extra
    ):
        """記錄錯誤，包含完整上下文"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': 'ERROR',
            'message': message,
            'error_code': error_code,
            'context': {
                'user_id': user_id,
                'order_id': order_id,
                'payment_id': payment_id,
                **extra
            }
        }

        if exception:
            log_data['exception'] = {
                'type': type(exception).__name__,
                'message': str(exception),
                'traceback': traceback.format_exc()
            }

        self.logger.error(json.dumps(log_data))

    def log_business_event(
        self,
        event_type,
        user_id=None,
        order_id=None,
        **extra
    ):
        """記錄業務事件"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': 'INFO',
            'event_type': event_type,
            'context': {
                'user_id': user_id,
                'order_id': order_id,
                **extra
            }
        }

        self.logger.info(json.dumps(log_data))
```

**檢查點**：
- [ ] 設計了異常類層級
- [ ] 實現了統一錯誤處理
- [ ] 建立了結構化日誌

---

### 階段三：重構現有代碼（35 分鐘）

**目標**：應用新的錯誤處理架構

#### 步驟 1：重構支付服務

```python
# apps/payments/services.py（重構後）

import requests
from django.db import transaction
from apps.core.exceptions import (
    PaymentFailedError,
    PaymentGatewayError,
    PaymentNetworkError,
    PaymentNotFoundError
)
from apps.core.logging import StructuredLogger

logger = StructuredLogger(__name__)

class PaymentService:
    """支付服務（重構後）"""

    @transaction.atomic
    def process_payment(self, order_id, amount, payment_method):
        """
        處理支付

        Args:
            order_id: 訂單 ID
            amount: 支付金額
            payment_method: 支付方式

        Returns:
            Payment: 支付記錄

        Raises:
            PaymentFailedError: 支付失敗
            PaymentGatewayError: 支付網關錯誤
            PaymentNetworkError: 網絡錯誤
        """
        # 創建支付記錄
        payment = Payment.objects.create(
            order_id=order_id,
            amount=amount,
            payment_method=payment_method,
            status='pending'
        )

        try:
            # 調用第三方支付 API
            result = self._call_payment_gateway(payment)

            # 更新支付狀態
            payment.status = 'completed'
            payment.transaction_id = result['transaction_id']
            payment.save()

            # 記錄業務事件
            logger.log_business_event(
                event_type='payment_completed',
                order_id=order_id,
                payment_id=payment.id,
                amount=float(amount),
                method=payment_method
            )

            return payment

        except PaymentGatewayError as e:
            # 支付網關錯誤
            payment.status = 'failed'
            payment.error_message = str(e)
            payment.save()

            logger.log_error(
                message="Payment gateway error",
                error_code='PAYMENT_GATEWAY_ERROR',
                order_id=order_id,
                payment_id=payment.id,
                exception=e
            )

            raise

        except requests.exceptions.Timeout as e:
            # 網絡超時
            payment.status = 'timeout'
            payment.save()

            logger.log_error(
                message="Payment gateway timeout",
                error_code='PAYMENT_TIMEOUT',
                order_id=order_id,
                payment_id=payment.id,
                exception=e
            )

            raise PaymentNetworkError("支付服務超時") from e

        except requests.exceptions.RequestException as e:
            # 其他網絡錯誤
            logger.log_error(
                message="Payment network error",
                error_code='PAYMENT_NETWORK_ERROR',
                order_id=order_id,
                payment_id=payment.id,
                exception=e
            )

            raise PaymentNetworkError("支付服務不可用") from e

        except Exception as e:
            # 未預期的錯誤
            logger.log_error(
                message="Unexpected payment error",
                error_code='PAYMENT_UNEXPECTED_ERROR',
                order_id=order_id,
                payment_id=payment.id,
                exception=e
            )

            raise


    def _call_payment_gateway(self, payment):
        """
        調用支付網關

        Raises:
            PaymentGatewayError: 支付網關返回錯誤
            requests.exceptions.RequestException: 網絡錯誤
        """
        url = "https://api.payment-gateway.com/charge"
        data = {
            "amount": float(payment.amount),
            "currency": "USD",
            "payment_method": payment.payment_method
        }

        try:
            response = requests.post(
                url,
                json=data,
                timeout=10  # 10 秒超時
            )

            # 檢查 HTTP 狀態碼
            response.raise_for_status()

            result = response.json()

            # 檢查業務狀態
            if result.get('status') != 'success':
                raise PaymentGatewayError(
                    gateway_message=result.get('message', 'Unknown error'),
                    gateway_code=result.get('code')
                )

            return result

        except requests.exceptions.HTTPError as e:
            # HTTP 錯誤（4xx, 5xx）
            raise PaymentGatewayError(
                gateway_message=f"HTTP {e.response.status_code}",
                gateway_code=str(e.response.status_code)
            ) from e


    def refund_payment(self, payment_id, reason):
        """
        退款

        Args:
            payment_id: 支付 ID
            reason: 退款原因

        Returns:
            Payment: 更新後的支付記錄

        Raises:
            PaymentNotFoundError: 支付不存在
            PaymentFailedError: 退款失敗（支付狀態不允許退款）
        """
        # 查詢支付記錄
        try:
            payment = Payment.objects.get(id=payment_id)
        except Payment.DoesNotExist:
            raise PaymentNotFoundError(payment_id)

        # 檢查支付狀態
        if payment.status != 'completed':
            raise PaymentFailedError(
                reason=f"Cannot refund payment with status {payment.status}",
                transaction_id=payment.transaction_id
            )

        # 調用退款 API
        try:
            result = self._call_refund_api(payment, reason)

            payment.status = 'refunded'
            payment.refund_reason = reason
            payment.save()

            logger.log_business_event(
                event_type='payment_refunded',
                payment_id=payment.id,
                reason=reason
            )

            return payment

        except Exception as e:
            logger.log_error(
                message="Refund failed",
                error_code='REFUND_ERROR',
                payment_id=payment.id,
                exception=e
            )
            raise
```

**檢查點**：
- [ ] 替換了裸 except
- [ ] 添加了事務控制
- [ ] 使用了自定義異常
- [ ] 完善了日誌記錄

---

#### 步驟 2：重構訂單服務

```python
# apps/orders/services.py（重構後）

from django.db import transaction
from apps.core.exceptions import (
    InsufficientStockError,
    OrderNotFoundError
)

class OrderService:
    """訂單服務（重構後）"""

    @transaction.atomic
    def create_order(self, user_id, items):
        """
        創建訂單（使用事務保證一致性）

        Args:
            user_id: 用戶 ID
            items: 訂單項列表

        Returns:
            Order: 創建的訂單

        Raises:
            InsufficientStockError: 庫存不足
            ValidationError: 參數驗證失敗
        """
        # 創建訂單
        order = Order.objects.create(
            user_id=user_id,
            status='pending'
        )

        # 創建訂單項並檢查庫存
        for item in items:
            # 行鎖，防止併發問題
            product = Product.objects.select_for_update().get(
                id=item['product_id']
            )

            # 檢查庫存
            if product.stock < item['quantity']:
                raise InsufficientStockError(
                    product_name=product.name,
                    available=product.stock,
                    requested=item['quantity']
                )

            # 創建訂單項
            OrderItem.objects.create(
                order=order,
                product=product,
                quantity=item['quantity'],
                price=product.price
            )

            # 扣減庫存
            product.stock -= item['quantity']
            product.save()

        logger.log_business_event(
            event_type='order_created',
            user_id=user_id,
            order_id=order.id,
            item_count=len(items)
        )

        return order
        # 如果任何步驟失敗，事務自動回滾


    @transaction.atomic
    def cancel_order(self, order_id):
        """
        取消訂單（使用事務保證庫存正確回滾）

        Args:
            order_id: 訂單 ID

        Raises:
            OrderNotFoundError: 訂單不存在
            ValidationError: 訂單狀態不允許取消
        """
        try:
            order = Order.objects.select_for_update().get(id=order_id)
        except Order.DoesNotExist:
            raise OrderNotFoundError(order_id)

        # 檢查訂單狀態
        if order.status == 'cancelled':
            logger.log_business_event(
                event_type='order_already_cancelled',
                order_id=order_id
            )
            return order  # 冪等：已取消，直接返回

        if order.status not in ['pending', 'confirmed']:
            raise ValidationError(
                f"Cannot cancel order with status {order.status}",
                field='status'
            )

        # 回滾庫存
        for item in order.items.all():
            product = Product.objects.select_for_update().get(id=item.product_id)
            product.stock += item.quantity
            product.save()

        # 更新訂單狀態
        order.status = 'cancelled'
        order.save()

        logger.log_business_event(
            event_type='order_cancelled',
            order_id=order_id
        )

        return order
```

**檢查點**：
- [ ] 添加了事務控制
- [ ] 使用了行鎖防止併發
- [ ] 處理了冪等性
- [ ] 完善了異常處理

---

### 階段四：建立監控（10 分鐘）

**目標**：實現錯誤追蹤和告警

#### 整合 Sentry

```python
# settings.py

import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration

sentry_sdk.init(
    dsn="YOUR_SENTRY_DSN",
    integrations=[DjangoIntegration()],
    environment="production",
    traces_sample_rate=0.1,  # 10% 的請求追蹤性能
    send_default_pii=False,   # 不發送個人信息
    before_send=filter_sensitive_data  # 過濾敏感數據
)

def filter_sensitive_data(event, hint):
    """過濾敏感數據"""
    # 移除信用卡號等敏感信息
    if 'request' in event and 'data' in event['request']:
        data = event['request']['data']
        if 'card_number' in data:
            data['card_number'] = '****'
        if 'cvv' in data:
            data['cvv'] = '***'
    return event
```

#### 沉澱經驗

```bash
/memory save

主題：錯誤處理與異常設計最佳實踐

核心原則：
1. 絕不使用裸 except
   - 始終指定具體異常類型
   - 或使用 except Exception（不捕獲 SystemExit）
   - 記錄異常上下文（exc_info=True）

2. 設計清晰的異常層級
   - 業務異常（400）：用戶錯誤，可恢復
   - 技術異常（500）：系統錯誤，不可恢復
   - 資源異常（404）：資源未找到
   - 權限異常（403）：權限不足

3. 異常信息分離
   - 開發者信息：詳細的技術細節（日誌）
   - 用戶信息：友好的提示（API 響應）
   - 絕不向用戶暴露技術細節

4. 事務控制
   - 多步驟操作必須使用 @transaction.atomic
   - 涉及多個模型更新的操作
   - 使用 select_for_update() 防止併發
   - 考慮冪等性設計

5. 結構化日誌
   - 使用 JSON 格式
   - 包含上下文：user_id, order_id, request_id
   - 記錄堆疊信息：exc_info=True
   - 區分錯誤級別：error, warning, info

查找模式：
- 裸 except：/grep "except:" --type py -C 3
- 返回值不一致：/grep "return None\|return True" --type py
- 缺少事務：/grep "\.save\(\)" --type py -C 5
- 錯誤日誌：/grep "print\|logger\.error" --type py

異常設計模式：
```python
class AppException(Exception):
    error_code: str
    user_message: str
    status_code: int
    details: dict
```

事務模式：
```python
from django.db import transaction

@transaction.atomic
def multi_step_operation():
    # Step 1
    # Step 2
    # Step 3
    # 任何異常自動回滾
```

日誌模式：
```python
logger.error(
    "Operation failed",
    exc_info=True,
    extra={
        'user_id': user_id,
        'operation': 'payment',
        'context': {...}
    }
)
```

錯誤響應格式：
```json
{
  "error_code": "PAYMENT_FAILED",
  "message": "支付失敗，請檢查支付信息",
  "details": {"field": "card_number"}
}
```

監控工具：Sentry, Datadog, ELK Stack
相關指令：/grep（查找錯誤處理問題），/read（理解異常流程）
```

**檢查點**：
- [ ] 整合了 Sentry
- [ ] 沉澱了經驗到 /memory
- [ ] 建立了錯誤處理檢查清單

---

## 驗證標準

### 必須達成 ✅

- [ ] 替換了所有裸 except
- [ ] 設計了異常類層級（至少 3 層）
- [ ] 為關鍵操作添加了事務控制
- [ ] 實現了統一的錯誤處理中間件
- [ ] 建立了結構化日誌記錄
- [ ] 整合了錯誤監控（Sentry）
- [ ] 使用 /memory 沉澱了經驗

### 額外成就 🌟

- [ ] 實現了錯誤重試機制
- [ ] 設計了補償事務（Saga）
- [ ] 建立了錯誤統計和分析
- [ ] 編寫了錯誤處理文檔
- [ ] 實現了告警系統（釘釘/Slack）
- [ ] 所有 API 返回統一的錯誤格式

---

## 學習反思

### 反思問題

1. **裸 except 的危害**：
   - 為什麼絕不能使用裸 except？
   - 可能隱藏哪些關鍵異常？
   - 如何正確捕獲異常？

2. **事務的重要性**：
   - 什麼時候需要事務？
   - @transaction.atomic 的工作原理？
   - 如何處理分佈式事務？

3. **錯誤信息設計**：
   - 如何平衡安全性和可用性？
   - 用戶消息和開發者消息的區別？
   - 如何避免信息洩漏？

4. **監控與告警**：
   - Sentry 如何幫助定位問題？
   - 如何設置合理的告警閾值？
   - 錯誤聚合的價值是什麼？

### 延伸練習

1. **實現重試機制**：
   - 對網絡錯誤自動重試
   - 指數退避策略
   - 最大重試次數

2. **實現熔斷器模式**：
   - 當第三方服務不可用時自動熔斷
   - 避免雪崩效應
   - 自動恢復

3. **實現 Saga 模式**：
   - 長事務的補償機制
   - 分佈式事務一致性
   - 狀態機設計

---

## 相關資源

### 下一步學習

- **模組 3**：TDD/BDD - 測試驅動開發
- **模組 4**：分佈式系統 - 分佈式事務
- **模組 5**：可觀測性 - 日誌、監控、追蹤

### 工具參考

- **Sentry**：錯誤追蹤和監控
- **ELK Stack**：日誌聚合分析
- **Datadog**：應用性能監控
- **PagerDuty**：告警和事件管理

### 學習資源

- **《Effective Python》** - Exception Handling
- **Django 文檔** - Database Transactions
- **《Release It!》** - Stability Patterns
- **Sentry 最佳實踐**

---

**建議完成時間**：1.5-2 小時
**難度評估**：3.5/5
**重要度**：5/5（錯誤處理是系統健壯性的基礎）
**可複用性**：5/5（異常設計可應用到任何項目）
