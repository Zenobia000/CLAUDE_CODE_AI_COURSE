# C09：性能瓶頸優化（組合級）

## 情境資訊

**編號**：C09
**難度**：⭐⭐⭐⭐☆（組合級）
**預計時間**：1.5 小時
**學習目標**：
- 掌握使用 /grep 查找性能問題模式
- 學會分析 N+1 查詢問題
- 練習系統化的性能優化方法
- 建立性能優化檢查清單

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉數據庫查詢優化
- 需要解決性能問題

---

## 情境描述

### 背景

你負責一個社交電商平台的後端 API。系統上線半年後，用戶量從 1000 增長到 50000。最近一週，用戶投訴不斷：

- **商品列表頁**：加載需要 5-8 秒（原本 < 1 秒）
- **訂單詳情頁**：打開需要 3 秒（原本即時）
- **用戶動態流**：完全無法加載，超時報錯
- **管理後台**：統計報表需要 30 秒以上

運維團隊發現數據庫 CPU 使用率持續 90% 以上，慢查詢日誌爆滿。老闆給了你 3 天時間解決問題，否則會影響公司融資。

### 現有代碼問題

```python
# apps/products/views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from .models import Product, Category, Review, ProductImage
from .serializers import ProductSerializer

class ProductListView(APIView):
    """商品列表 API - 目前響應時間：5-8 秒"""

    def get(self, request):
        # 問題 1：加載所有商品（沒有分頁）
        products = Product.objects.all()

        # 問題 2：序列化時觸發 N+1 查詢
        serializer = ProductSerializer(products, many=True)

        return Response(serializer.data)


class ProductSerializer(serializers.ModelSerializer):
    """商品序列化器"""
    category_name = serializers.CharField(source='category.name')  # N+1
    review_count = serializers.SerializerMethodField()            # N+1
    avg_rating = serializers.SerializerMethodField()              # N+1
    images = serializers.SerializerMethodField()                  # N+1

    class Meta:
        model = Product
        fields = ['id', 'name', 'price', 'category_name',
                  'review_count', 'avg_rating', 'images']

    def get_review_count(self, obj):
        # 問題：每個商品都執行一次查詢
        return Review.objects.filter(product=obj).count()

    def get_avg_rating(self, obj):
        # 問題：每個商品都執行一次聚合查詢
        from django.db.models import Avg
        result = Review.objects.filter(product=obj).aggregate(Avg('rating'))
        return result['rating__avg'] or 0

    def get_images(self, obj):
        # 問題：每個商品都查詢一次圖片
        images = ProductImage.objects.filter(product=obj)[:3]
        return [img.url for img in images]


# apps/orders/views.py

class OrderDetailView(APIView):
    """訂單詳情 API - 目前響應時間：3 秒"""

    def get(self, request, order_id):
        order = Order.objects.get(id=order_id)

        # 問題 1：序列化時 N+1 查詢
        serializer = OrderSerializer(order)

        # 問題 2：計算訂單統計（重複計算）
        stats = self.calculate_order_stats(order)

        return Response({
            'order': serializer.data,
            'stats': stats
        })

    def calculate_order_stats(self, order):
        # 問題：每次都重新計算，沒有緩存
        total_items = 0
        total_weight = 0

        # N+1：遍歷訂單項
        for item in order.items.all():
            total_items += item.quantity
            # N+1：查詢商品信息
            total_weight += item.product.weight * item.quantity

        return {
            'total_items': total_items,
            'total_weight': total_weight
        }


class OrderSerializer(serializers.ModelSerializer):
    """訂單序列化器"""
    user_name = serializers.CharField(source='user.username')     # N+1
    items = OrderItemSerializer(many=True)                         # N+1
    shipping_address = serializers.SerializerMethodField()         # N+1

    def get_shipping_address(self, obj):
        # N+1：查詢地址
        address = Address.objects.filter(user=obj.user, is_default=True).first()
        return address.full_address if address else None


# apps/social/views.py

class UserFeedView(APIView):
    """用戶動態流 - 目前：超時"""

    def get(self, request):
        user = request.user

        # 問題 1：獲取所有關注用戶的所有動態（沒有限制）
        following_ids = user.following.values_list('id', flat=True)
        posts = Post.objects.filter(author_id__in=following_ids)

        # 問題 2：按創建時間排序（沒有索引）
        posts = posts.order_by('-created_at')

        # 問題 3：每個動態都查詢評論數、點贊數
        result = []
        for post in posts:
            # N+1：查詢評論數
            comment_count = Comment.objects.filter(post=post).count()
            # N+1：查詢點贊數
            like_count = Like.objects.filter(post=post).count()
            # N+1：查詢作者信息
            author = post.author

            result.append({
                'id': post.id,
                'content': post.content,
                'author': author.username,
                'author_avatar': author.avatar_url,
                'comment_count': comment_count,
                'like_count': like_count,
                'created_at': post.created_at
            })

        return Response(result)


# apps/analytics/views.py

class DashboardStatsView(APIView):
    """管理後台統計 - 目前：30+ 秒"""

    def get(self, request):
        # 問題：所有統計都實時計算，沒有緩存
        stats = {
            'total_users': self.get_total_users(),
            'total_orders': self.get_total_orders(),
            'total_revenue': self.get_total_revenue(),
            'today_orders': self.get_today_orders(),
            'popular_products': self.get_popular_products(),
            'user_growth': self.get_user_growth(),
            'revenue_trend': self.get_revenue_trend(),
        }

        return Response(stats)

    def get_total_users(self):
        # 問題：每次都 COUNT(*)
        return User.objects.count()

    def get_total_orders(self):
        return Order.objects.count()

    def get_total_revenue(self):
        from django.db.models import Sum
        # 問題：聚合查詢很慢
        result = Order.objects.aggregate(Sum('total_amount'))
        return result['total_amount__sum'] or 0

    def get_popular_products(self):
        from django.db.models import Count
        # 問題：複雜的聚合查詢，沒有索引
        products = Product.objects.annotate(
            order_count=Count('orderitem')
        ).order_by('-order_count')[:10]

        # N+1：序列化
        return [
            {
                'id': p.id,
                'name': p.name,
                'category': p.category.name,  # N+1
                'order_count': p.order_count
            }
            for p in products
        ]

    def get_user_growth(self):
        # 問題：按日期分組查詢，非常慢
        from django.db.models.functions import TruncDate
        from django.db.models import Count

        growth = User.objects.annotate(
            date=TruncDate('date_joined')
        ).values('date').annotate(
            count=Count('id')
        ).order_by('date')

        return list(growth)
```

### 數據庫慢查詢日誌

```sql
-- Query 1: 執行 500 次/秒，每次 20ms = 10 秒
SELECT * FROM products_review WHERE product_id = 123;
SELECT * FROM products_review WHERE product_id = 124;
SELECT * FROM products_review WHERE product_id = 125;
...

-- Query 2: 執行 200 次/秒，每次 50ms = 10 秒
SELECT * FROM products_productimage WHERE product_id = 123 LIMIT 3;
SELECT * FROM products_productimage WHERE product_id = 124 LIMIT 3;
...

-- Query 3: 1 次，但需要 5 秒
SELECT * FROM social_post WHERE author_id IN (1, 2, 3, ..., 5000)
ORDER BY created_at DESC;

-- Query 4: 執行 3000 次/秒，每次 10ms = 30 秒
SELECT COUNT(*) FROM social_comment WHERE post_id = 1;
SELECT COUNT(*) FROM social_comment WHERE post_id = 2;
...
```

### 你的任務

系統化地解決性能問題：

1. **識別瓶頸**：找出所有 N+1 查詢、慢查詢
2. **分析影響**：評估每個問題的性能影響
3. **優化實施**：
   - 使用 select_related / prefetch_related
   - 添加數據庫索引
   - 實現緩存策略
   - 添加分頁
4. **驗證效果**：測量優化前後的性能差異

---

## 學習重點

### 目標 1：使用 /grep 查找性能問題模式

學會識別常見性能問題：
- N+1 查詢模式（`.all()` 後循環，SerializerMethodField）
- 缺少 select_related/prefetch_related
- 缺少分頁（`.all()` 無限制）
- 重複計算（循環內查詢）

### 目標 2：理解 ORM 查詢優化

掌握 Django ORM 優化技巧：
- **select_related**：優化 ForeignKey 和 OneToOne
- **prefetch_related**：優化 ManyToMany 和反向 ForeignKey
- **only/defer**：只加載需要的字段
- **annotate**：數據庫層聚合

### 目標 3：數據庫優化

了解數據庫層面優化：
- 添加索引（WHERE, ORDER BY, JOIN 字段）
- 查詢計劃分析（EXPLAIN）
- 避免全表掃描

### 目標 4：緩存策略

學會使用緩存提升性能：
- 查詢結果緩存（Redis）
- 計算結果緩存
- 設置合理的過期時間

---

## 建議解決流程

### 階段一：識別性能瓶頸（20 分鐘）

**目標**：找出所有性能問題點

#### 步驟 1：查找 N+1 查詢模式

```bash
/grep "\.all\(\)" --type py -C 3

提示詞：
請找出可能導致 N+1 查詢的代碼模式：

1. SerializerMethodField 方法中的查詢
2. for 循環中的 ORM 查詢
3. 序列化器中訪問關聯對象（source='xxx.yyy'）
4. 缺少 select_related 或 prefetch_related

對每個問題評估：
- 查詢次數（N 有多大？）
- 每次查詢耗時
- 總體影響（查詢次數 × 耗時）
```

**預期輸出**：

```markdown
## N+1 查詢問題清單

### 問題 1：商品列表 N+1（高影響）

**位置**：apps/products/views.py:15 + ProductSerializer

**問題代碼**：
```python
products = Product.objects.all()  # 1 次查詢
serializer = ProductSerializer(products, many=True)

# 序列化時觸發：
# - category.name：500 次（每個商品 1 次）
# - review_count：500 次
# - avg_rating：500 次
# - images：500 次
# 總計：2001 次查詢
```

**影響評估**：
- 商品數量：500
- 每次查詢：20ms
- 總耗時：500 × 20ms × 4 = 40 秒 ⚠️

**優化方案**：
```python
products = Product.objects.all() \
    .select_related('category') \
    .prefetch_related('reviews', 'images')

# 或使用 annotate
from django.db.models import Count, Avg
products = Product.objects.all() \
    .select_related('category') \
    .prefetch_related('images') \
    .annotate(
        review_count=Count('reviews'),
        avg_rating=Avg('reviews__rating')
    )

# 查詢次數：1（主查詢）+ 1（category）+ 1（images）= 3 次
# 優化效果：從 2001 次 → 3 次
```

---

### 問題 2：訂單詳情 N+1（中影響）

**位置**：apps/orders/views.py:30

**問題代碼**：
```python
order = Order.objects.get(id=order_id)  # 1 次

# calculate_order_stats 中：
for item in order.items.all():  # N+1：查詢訂單項
    total_weight += item.product.weight * item.quantity  # N+1：查詢商品
```

**影響評估**：
- 訂單項數量：平均 5
- 查詢次數：1 + 5 + 5 = 11 次
- 總耗時：11 × 20ms = 220ms

**優化方案**：
```python
order = Order.objects.select_related('user').prefetch_related(
    Prefetch('items', queryset=OrderItem.objects.select_related('product'))
).get(id=order_id)

# 查詢次數：1（主查詢 + user）+ 1（items + products）= 2 次
```

---

### 問題 3：用戶動態流（極高影響）

**位置**：apps/social/views.py:50

**問題代碼**：
```python
posts = Post.objects.filter(author_id__in=following_ids)  # 1 次

for post in posts:  # 假設 3000 個動態
    comment_count = Comment.objects.filter(post=post).count()  # 3000 次
    like_count = Like.objects.filter(post=post).count()        # 3000 次
    author = post.author                                        # 3000 次

# 總計：1 + 3000 × 3 = 9001 次查詢
```

**影響評估**：
- 動態數量：3000
- 查詢次數：9001 次
- 總耗時：9001 × 10ms = 90 秒（超時）⚠️⚠️⚠️

**優化方案**：
```python
from django.db.models import Count

posts = Post.objects.filter(author_id__in=following_ids) \
    .select_related('author') \
    .prefetch_related('comments', 'likes') \
    .annotate(
        comment_count=Count('comments'),
        like_count=Count('likes')
    )[:100]  # 添加分頁限制

# 查詢次數：1（主查詢 + author + annotate）= 1 次
# 優化效果：從 90 秒 → 200ms
```

---

### 問題 4：統計報表重複計算（高影響）

**位置**：apps/analytics/views.py:80

**問題**：
- 每次請求都執行 7 個聚合查詢
- 數據變化不頻繁，但每秒查詢多次
- 總耗時：30 秒

**優化方案**：使用 Redis 緩存

```python
from django.core.cache import cache

def get(self, request):
    cache_key = 'dashboard_stats'
    stats = cache.get(cache_key)

    if stats is None:
        stats = self.calculate_stats()
        cache.set(cache_key, stats, timeout=300)  # 緩存 5 分鐘

    return Response(stats)

# 優化效果：從 30 秒 → < 10ms（緩存命中）
```

---

### 優先級排序

| 問題 | 影響 | 難度 | 優先級 |
|------|------|------|--------|
| 用戶動態流 | 極高（90s） | 中 | 🔴 P0 |
| 商品列表 | 高（40s） | 低 | 🔴 P0 |
| 統計報表 | 高（30s） | 低 | 🟡 P1 |
| 訂單詳情 | 中（220ms） | 低 | 🟡 P1 |

### 修復順序

1. **P0 問題**（今天必須修）：
   - 用戶動態流
   - 商品列表

2. **P1 問題**（明天修）：
   - 統計報表緩存
   - 訂單詳情優化
```

**檢查點**：
- [ ] 找出所有 N+1 查詢
- [ ] 評估了性能影響
- [ ] 確定了優化優先級
- [ ] 準備了優化方案

---

#### 步驟 2：查找缺少索引的字段

```bash
/grep "order_by\|filter\(" --type py -C 2

提示詞：
請找出可能需要添加數據庫索引的字段：

1. WHERE 條件字段（filter）
2. ORDER BY 字段（order_by）
3. JOIN 字段（ForeignKey）
4. 高頻查詢字段

對每個字段評估：
- 查詢頻率
- 數據量
- 是否已有索引
```

**預期輸出**：

```markdown
## 索引建議

### 缺少索引的字段

#### 1. Post.created_at（ORDER BY 字段）

**查詢**：
```python
posts.order_by('-created_at')
```

**問題**：3000 條記錄排序，沒有索引 → 全表掃描

**解決**：
```python
# models.py
class Post(models.Model):
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
```

#### 2. Review.product_id（外鍵，高頻查詢）

**查詢**：
```python
Review.objects.filter(product=obj)
```

**問題**：Django 自動為 ForeignKey 創建索引，但檢查確認

#### 3. OrderItem.order_id（外鍵）

已有索引 ✓

### 複合索引建議

#### Comment.post_id + created_at

**查詢**：
```python
Comment.objects.filter(post=post).order_by('-created_at')
```

**建議**：創建複合索引

```python
class Comment(models.Model):
    # ...
    class Meta:
        indexes = [
            models.Index(fields=['post', '-created_at']),
        ]
```
```

**檢查點**：
- [ ] 識別了需要索引的字段
- [ ] 評估了索引影響
- [ ] 準備了 migration

---

### 階段二：實施優化（50 分鐘）

**目標**：按優先級修復性能問題

#### 步驟 1：優化商品列表（P0，15 分鐘）

```bash
提示詞：
請優化 ProductListView 和 ProductSerializer，解決 N+1 查詢問題：

要求：
1. 使用 select_related 優化 category
2. 使用 annotate 計算 review_count 和 avg_rating
3. 使用 prefetch_related 優化 images
4. 添加分頁（每頁 20 條）
5. 只查詢必要的字段

輸出優化後的完整代碼。
```

**優化後代碼**：

```python
# apps/products/views.py

from rest_framework.pagination import PageNumberPagination
from django.db.models import Count, Avg

class ProductPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

class ProductListView(APIView):
    """商品列表 API - 優化後：< 200ms"""

    def get(self, request):
        # 優化 1：使用 select_related 優化外鍵
        # 優化 2：使用 annotate 聚合計算
        # 優化 3：使用 prefetch_related 優化反向關聯
        products = Product.objects.select_related('category') \
            .prefetch_related(
                Prefetch('images',
                         queryset=ProductImage.objects.all()[:3])
            ) \
            .annotate(
                review_count=Count('reviews'),
                avg_rating=Avg('reviews__rating')
            ) \
            .only(  # 優化 4：只加載需要的字段
                'id', 'name', 'price', 'category__name'
            )

        # 優化 5：添加分頁
        paginator = ProductPagination()
        page = paginator.paginate_queryset(products, request)

        serializer = ProductSerializer(page, many=True)

        return paginator.get_paginated_response(serializer.data)


class ProductSerializer(serializers.ModelSerializer):
    """優化後的序列化器"""
    category_name = serializers.CharField(source='category.name')
    review_count = serializers.IntegerField()  # 來自 annotate，不再查詢
    avg_rating = serializers.FloatField()      # 來自 annotate
    images = serializers.SerializerMethodField()

    class Meta:
        model = Product
        fields = ['id', 'name', 'price', 'category_name',
                  'review_count', 'avg_rating', 'images']

    def get_images(self, obj):
        # images 已經 prefetch，不會觸發新查詢
        return [img.url for img in obj.images.all()[:3]]
```

**測試優化效果**：

```bash
# 優化前
curl -w "@curl-format.txt" http://localhost:8000/api/products/
# Time: 8.2 seconds
# Queries: 2001

# 優化後
curl -w "@curl-format.txt" http://localhost:8000/api/products/
# Time: 0.15 seconds
# Queries: 3

# 提升：54 倍！
```

**提交**：
```bash
git add apps/products/views.py apps/products/serializers.py
git commit -m "perf(products): optimize product list API with select_related and annotate

- Reduce queries from 2001 to 3
- Add pagination (20 items per page)
- Response time improved from 8.2s to 0.15s (54x faster)

Resolves: #PERF-001"
```

**檢查點**：
- [ ] 優化了查詢
- [ ] 測試了性能提升
- [ ] 提交了代碼

---

#### 步驟 2：優化用戶動態流（P0，20 分鐘）

```python
# apps/social/views.py

from django.db.models import Count, Prefetch

class UserFeedView(APIView):
    """用戶動態流 - 優化後：< 300ms"""

    def get(self, request):
        user = request.user

        # 優化 1：限制關注用戶數量（如果太多）
        following_ids = user.following.values_list('id', flat=True)[:500]

        # 優化 2：使用 select_related 和 annotate
        posts = Post.objects.filter(author_id__in=following_ids) \
            .select_related('author') \
            .annotate(
                comment_count=Count('comments', distinct=True),
                like_count=Count('likes', distinct=True)
            ) \
            .only(
                'id', 'content', 'created_at',
                'author__username', 'author__avatar_url'
            ) \
            .order_by('-created_at')[:100]  # 優化 3：限制返回數量

        # 優化 4：直接使用查詢結果，避免循環
        result = [
            {
                'id': post.id,
                'content': post.content,
                'author': post.author.username,
                'author_avatar': post.author.avatar_url,
                'comment_count': post.comment_count,
                'like_count': post.like_count,
                'created_at': post.created_at
            }
            for post in posts
        ]

        return Response(result)


# 添加索引
# apps/social/models.py

class Post(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)

    class Meta:
        indexes = [
            models.Index(fields=['author', '-created_at']),
        ]
```

**生成 migration**：

```bash
python manage.py makemigrations social
python manage.py migrate social
```

**測試**：

```bash
# 優化前：超時（90 秒）
# 優化後：250ms
# 查詢次數：從 9001 次 → 1 次
```

**檢查點**：
- [ ] 優化了查詢
- [ ] 添加了索引
- [ ] 添加了分頁限制
- [ ] 測試通過

---

#### 步驟 3：實現統計報表緩存（P1，15 分鐘）

```python
# apps/analytics/views.py

from django.core.cache import cache
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

class DashboardStatsView(APIView):
    """管理後台統計 - 優化後：< 50ms（緩存命中）"""

    def get(self, request):
        cache_key = 'dashboard_stats_v1'
        stats = cache.get(cache_key)

        if stats is None:
            # 緩存未命中，計算統計數據
            stats = self.calculate_stats()

            # 緩存 5 分鐘
            cache.set(cache_key, stats, timeout=300)

        return Response(stats)

    def calculate_stats(self):
        """計算統計數據（優化版本）"""
        from django.db.models import Sum, Count, Avg
        from django.db.models.functions import TruncDate

        # 優化 1：合併查詢，減少數據庫往返
        user_stats = User.objects.aggregate(
            total_users=Count('id')
        )

        order_stats = Order.objects.aggregate(
            total_orders=Count('id'),
            total_revenue=Sum('total_amount')
        )

        today = timezone.now().date()
        today_stats = Order.objects.filter(
            created_at__date=today
        ).aggregate(
            today_orders=Count('id')
        )

        # 優化 2：限制返回數量
        popular_products = Product.objects.annotate(
            order_count=Count('orderitem')
        ).select_related('category').order_by('-order_count')[:10]

        # 優化 3：限制日期範圍
        thirty_days_ago = timezone.now() - timezone.timedelta(days=30)
        user_growth = User.objects.filter(
            date_joined__gte=thirty_days_ago
        ).annotate(
            date=TruncDate('date_joined')
        ).values('date').annotate(
            count=Count('id')
        ).order_by('date')

        return {
            'total_users': user_stats['total_users'],
            'total_orders': order_stats['total_orders'],
            'total_revenue': float(order_stats['total_revenue'] or 0),
            'today_orders': today_stats['today_orders'],
            'popular_products': [
                {
                    'id': p.id,
                    'name': p.name,
                    'category': p.category.name,
                    'order_count': p.order_count
                }
                for p in popular_products
            ],
            'user_growth': list(user_growth),
        }
```

**配置 Redis 緩存**：

```python
# settings.py

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
```

**測試**：

```bash
# 第一次請求（緩存未命中）：3 秒
# 後續請求（緩存命中）：20ms
# 提升：150 倍！
```

**檢查點**：
- [ ] 實現了 Redis 緩存
- [ ] 設置了合理的過期時間
- [ ] 測試了緩存效果

---

### 階段三：驗證與監控（20 分鐘）

**目標**：確認優化效果，建立監控

#### 步驟 1：性能測試

```bash
# 使用 locust 進行壓力測試

# locustfile.py
from locust import HttpUser, task, between

class WebsiteUser(HttpUser):
    wait_time = between(1, 3)

    @task(3)
    def load_products(self):
        self.client.get("/api/products/")

    @task(2)
    def load_feed(self):
        self.client.get("/api/social/feed/")

    @task(1)
    def load_stats(self):
        self.client.get("/api/analytics/dashboard/")

# 運行測試
locust -f locustfile.py --host=http://localhost:8000
```

**測試結果**：

```markdown
## 性能測試報告

### 優化前

| API | 平均響應時間 | P95 | 失敗率 |
|-----|-------------|-----|--------|
| 商品列表 | 8.2s | 12s | 5% |
| 用戶動態 | 超時 | - | 95% |
| 統計報表 | 30s | 45s | 30% |

### 優化後

| API | 平均響應時間 | P95 | 失敗率 | 提升倍數 |
|-----|-------------|-----|--------|---------|
| 商品列表 | 150ms | 250ms | 0% | **54x** |
| 用戶動態 | 280ms | 400ms | 0% | **300x** |
| 統計報表 | 25ms | 50ms | 0% | **1200x** |

### 數據庫查詢優化

| 場景 | 優化前查詢次數 | 優化後查詢次數 | 減少比例 |
|------|--------------|--------------|---------|
| 商品列表 | 2001 | 3 | **99.85%** |
| 用戶動態 | 9001 | 1 | **99.99%** |
| 統計報表 | 7 | 4（首次）/0（緩存） | **100%** |
```

#### 步驟 2：建立監控

```python
# 添加性能監控中間件

# apps/core/middleware.py

import time
import logging
from django.db import connection

logger = logging.getLogger(__name__)

class PerformanceMonitoringMiddleware:
    """性能監控中間件"""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # 記錄開始時間
        start_time = time.time()

        # 記錄查詢數量
        num_queries_start = len(connection.queries)

        # 處理請求
        response = self.get_response(request)

        # 計算耗時
        duration = time.time() - start_time
        num_queries = len(connection.queries) - num_queries_start

        # 記錄慢請求
        if duration > 1.0:  # 超過 1 秒
            logger.warning(
                f"Slow request: {request.path} "
                f"took {duration:.2f}s with {num_queries} queries"
            )

        # 記錄 N+1 查詢
        if num_queries > 10:
            logger.warning(
                f"Potential N+1 query: {request.path} "
                f"executed {num_queries} queries"
            )

        # 添加響應頭（開發環境）
        if settings.DEBUG:
            response['X-Query-Count'] = str(num_queries)
            response['X-Response-Time'] = f"{duration:.3f}"

        return response
```

**檢查點**：
- [ ] 完成了壓力測試
- [ ] 驗證了優化效果
- [ ] 建立了性能監控

---

#### 步驟 3：沉澱經驗

```bash
/memory save

主題：Web API 性能優化最佳實踐

關鍵問題模式：
1. N+1 查詢（最常見）
   - SerializerMethodField 中的查詢
   - 循環中的 ORM 查詢
   - 序列化器訪問關聯對象
   - 缺少 select_related/prefetch_related

2. 缺少分頁
   - .all() 無限制加載
   - 大數據集序列化
   - 內存溢出風險

3. 缺少索引
   - WHERE 條件字段
   - ORDER BY 字段
   - JOIN 字段

4. 缺少緩存
   - 重複計算
   - 聚合查詢
   - 統計報表

優化技巧：
1. Django ORM 優化
   - select_related：優化 ForeignKey（JOIN）
   - prefetch_related：優化反向 FK 和 M2M（IN 查詢）
   - annotate：數據庫層聚合（COUNT, AVG, SUM）
   - only/defer：只加載需要的字段
   - 組合使用：.select_related().prefetch_related().annotate()

2. 查找 N+1 模式
   - /grep "\.all\(\)" --type py -C 3
   - /grep "SerializerMethodField" --type py
   - /grep "for.*in.*\.all\(\)" --type py
   - 使用 django-silk 或 django-debug-toolbar 查看查詢

3. 索引策略
   - WHERE 字段：filter() 參數
   - ORDER BY 字段：order_by() 參數
   - 高頻查詢字段
   - 複合索引：多字段查詢

4. 緩存策略
   - 查詢結果緩存（Redis）
   - 過期時間：根據數據更新頻率
   - 緩存鍵設計：包含版本號
   - 主動失效：數據更新時清除緩存

5. 分頁
   - 使用 DRF Pagination
   - 限制 page_size
   - 游標分頁（大數據集）

測試方法：
- django-silk：查看查詢詳情
- django-debug-toolbar：開發環境監控
- locust：壓力測試
- 監控中間件：記錄慢請求

常用命令：
- /grep "\.all\(\)" --type py（查找潛在 N+1）
- /grep "SerializerMethodField" --type py（查找自定義字段）
- /grep "order_by\|filter" --type py（查找需要索引的字段）

性能目標：
- API 響應時間：< 500ms（P95）
- 數據庫查詢：< 10 次/請求
- 緩存命中率：> 80%（統計類 API）

相關工具：django-silk, locust, redis, django-debug-toolbar
相關指令：/grep（查找性能問題模式），/read（理解查詢邏輯）
```

**檢查點**：
- [ ] 沉澱了優化經驗
- [ ] 建立了性能檢查清單
- [ ] 記錄了優化效果

---

## 驗證標準

### 必須達成 ✅

- [ ] 識別了所有 N+1 查詢問題
- [ ] 優化了高優先級 API（P0）
- [ ] 響應時間降低到 < 500ms（P95）
- [ ] 數據庫查詢減少 90% 以上
- [ ] 添加了必要的數據庫索引
- [ ] 實現了統計報表緩存
- [ ] 使用 /memory 沉澱了優化經驗

### 額外成就 🌟

- [ ] 使用 django-silk 或 django-debug-toolbar 分析查詢
- [ ] 完成了壓力測試（locust）
- [ ] 實現了性能監控中間件
- [ ] 建立了性能基準測試
- [ ] 編寫了性能優化文檔
- [ ] 所有 API 響應時間 < 300ms

---

## 學習反思

### 反思問題

1. **問題識別**：
   - 如何快速找出性能瓶頸？
   - /grep 如何幫助識別 N+1 查詢模式？
   - 還有哪些常見的性能問題？

2. **優化技巧**：
   - select_related 和 prefetch_related 的區別？
   - annotate 和 SerializerMethodField 的性能差異？
   - 何時使用緩存？何時優化查詢？

3. **優先級判斷**：
   - 如何評估性能問題的影響？
   - 為什麼先優化高影響低難度的問題？
   - 如何平衡優化效果與開發成本？

4. **持續改進**：
   - 如何預防未來的性能問題？
   - 性能監控的價值是什麼？
   - 如何建立團隊的性能意識？

### 延伸練習

1. **深度優化**：
   - 使用數據庫 EXPLAIN 分析查詢計劃
   - 優化慢 SQL 查詢
   - 實現查詢結果緩存

2. **進階緩存策略**：
   - 實現多級緩存（內存 + Redis）
   - 設計緩存失效策略
   - 實現緩存預熱

3. **性能測試自動化**：
   - 集成 locust 到 CI/CD
   - 設置性能基準測試
   - 性能回歸檢測

---

## 相關資源

### 下一步學習

- **C10**：錯誤處理增強 - 系統化改進
- **模組 4**：數據庫優化深度 - 索引、查詢計劃
- **模組 5**：緩存架構設計 - Redis 高級應用

### 工具參考

- **django-silk**：性能分析工具
- **django-debug-toolbar**：開發環境調試
- **locust**：壓力測試工具
- **redis**：緩存服務
- **pgAdmin**：PostgreSQL 管理（查看查詢計劃）

### 學習資源

- **Django ORM Performance**：官方優化指南
- **《High Performance Django》**
- **Database Indexing Strategies**
- **Caching Best Practices**

---

**建議完成時間**：1.5-2 小時
**難度評估**：4/5
**重要度**：5/5（性能是用戶體驗的基礎）
**可複用性**：5/5（優化方法可應用到任何 Web 項目）
