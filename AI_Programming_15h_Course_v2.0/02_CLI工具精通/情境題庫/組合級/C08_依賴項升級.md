# C08：依賴項升級（組合級）

## 情境資訊

**編號**：C08
**難度**：⭐⭐⭐⭐☆（組合級）
**預計時間**：2 小時
**學習目標**：
- 掌握使用 /grep 查找廢棄 API 使用
- 學會系統化處理 breaking changes
- 練習大規模代碼遷移策略
- 建立依賴升級檢查清單

**適用對象**：
- 完成模組 2 基礎理論
- 熟悉 Python 依賴管理
- 需要處理框架升級問題

---

## 情境描述

### 背景

你負責維護一個電商平台的後端系統，使用 Django 框架開發。系統已經運行了 3 年，目前使用的是 **Django 2.2 LTS**，但這個版本將在下個月停止安全更新支持。

公司安全團隊要求必須升級到 **Django 4.2 LTS**（最新的長期支持版本）。然而，從 2.2 到 4.2 跨越了兩個大版本，包含大量 breaking changes：

- **URL 配置**：`django.conf.urls.url()` 已廢棄，改用 `path()` 和 `re_path()`
- **ORM 查詢**：`QuerySet.count()` 行為變更，`on_delete` 成為必填
- **Middleware**：舊式 middleware 不再支持
- **模板**：某些模板標籤語法變更
- **第三方套件**：多個依賴也需要升級

### 現有問題範圍

```python
# 項目結構
myproject/
├── apps/
│   ├── accounts/      # 用戶系統
│   ├── orders/        # 訂單系統
│   ├── products/      # 商品系統
│   └── payments/      # 支付系統
├── core/
│   ├── middleware.py
│   └── utils.py
├── config/
│   ├── urls.py
│   └── settings.py
└── requirements.txt

統計：
- Python 文件：156 個
- 代碼行數：32,450 行
- URL 配置：87 個路由
- 數據模型：45 個
- 第三方依賴：23 個
```

### 已知的 Breaking Changes

**1. URL 配置廢棄**

```python
# Django 2.2（舊）
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^products/$', views.product_list, name='product-list'),
    url(r'^products/(?P<pk>[0-9]+)/$', views.product_detail),
    url(r'^orders/(?P<order_id>[a-z0-9-]+)/$', views.order_detail),
]

# Django 4.2（新）
from django.urls import path, re_path
from . import views

urlpatterns = [
    path('products/', views.product_list, name='product-list'),
    path('products/<int:pk>/', views.product_detail),
    re_path(r'^orders/(?P<order_id>[a-z0-9-]+)/$', views.order_detail),
]
```

**2. ORM 外鍵 on_delete 必填**

```python
# Django 2.2（可選）
class Order(models.Model):
    user = models.ForeignKey(User)  # on_delete 可以省略
    product = models.ForeignKey('Product')

# Django 4.2（必填）
class Order(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey('Product', on_delete=models.PROTECT)
```

**3. Middleware 舊格式廢棄**

```python
# Django 2.2（舊格式）
class OldStyleMiddleware:
    def process_request(self, request):
        pass

    def process_response(self, request, response):
        return response

# Django 4.2（新格式）
class NewStyleMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # process_request logic
        response = self.get_response(request)
        # process_response logic
        return response
```

**4. 導入路徑變更**

```python
# Django 2.2
from django.utils.encoding import force_text
from django.contrib.postgres.fields import JSONField

# Django 4.2
from django.utils.encoding import force_str  # force_text → force_str
from django.db.models import JSONField      # 移到 models
```

### 你的任務

系統化地完成 Django 升級：

1. **掃描與評估**：找出所有需要修改的地方
2. **制定遷移計劃**：按優先級和依賴關係排序
3. **逐步執行遷移**：確保每一步都可測試
4. **驗證與部署**：完整測試，平滑上線

---

## 學習重點

### 目標 1：使用 /grep 定位所有廢棄 API

學會精準查找需要修改的代碼：
- 正則表達式匹配導入語句
- 查找特定函數調用模式
- 識別廢棄的類和方法
- 統計影響範圍

### 目標 2：理解 Breaking Changes 影響

分析升級對系統的影響：
- 哪些是語法變更（必須改）
- 哪些是行為變更（需要測試）
- 哪些是性能變更（需要監控）
- 第三方依賴的兼容性

### 目標 3：安全的遷移策略

掌握大規模遷移技巧：
- 分階段執行（URL → Models → Middleware）
- 建立測試覆蓋（遷移前補充測試）
- 使用兼容層（新舊代碼共存）
- Feature flag 控制上線

### 目標 4：自動化工具應用

利用工具加速遷移：
- `django-upgrade`：自動重寫代碼
- `codemod`：批量代碼轉換
- 自定義腳本處理特殊情況

---

## 建議解決流程

### 階段一：掃描與影響評估（30 分鐘）

**目標**：完整了解需要修改的範圍

#### 步驟 1：掃描 URL 配置廢棄

```bash
/grep "from django.conf.urls import url" --type py

提示詞：
請找出所有使用舊式 URL 配置的文件：

1. 導入 django.conf.urls.url 的文件
2. 使用 url() 函數的地方
3. 統計總共有多少個路由需要遷移
4. 評估哪些可以直接用 path()，哪些需要 re_path()

對每個 URL 模式分析：
- 簡單路徑（無正則）→ 可用 path()
- 複雜正則 → 需要 re_path()
```

**預期輸出**：

```markdown
## URL 配置掃描報告

### 影響範圍

找到 **18 個文件** 使用舊式 URL 配置：

#### 核心 URL 配置
config/urls.py:3
    from django.conf.urls import url, include

apps/accounts/urls.py:1
    from django.conf.urls import url

apps/orders/urls.py:2
    from django.conf.urls import url

... (共 18 個文件)

### URL 模式分類

#### 類別 A：簡單路徑（可直接改為 path）- 67 個

```python
# 無正則，可直接轉換
url(r'^products/$', views.product_list)
→ path('products/', views.product_list)

url(r'^accounts/login/$', views.login)
→ path('accounts/login/', views.login)

url(r'^orders/create/$', views.create_order)
→ path('orders/create/', views.create_order)
```

總計：67 個（77%）

#### 類別 B：帶參數路徑（需要轉換語法）- 15 個

```python
# 整數 ID
url(r'^products/(?P<pk>[0-9]+)/$', views.product_detail)
→ path('products/<int:pk>/', views.product_detail)

# 字符串 slug
url(r'^categories/(?P<slug>[\w-]+)/$', views.category_detail)
→ path('categories/<slug:slug>/', views.category_detail)

# UUID
url(r'^orders/(?P<uuid>[a-f0-9-]{36})/$', views.order_detail)
→ path('orders/<uuid:uuid>/', views.order_detail)
```

總計：15 個（17%）

#### 類別 C：複雜正則（需要 re_path）- 5 個

```python
# 複雜模式，無法用 path() 表達
url(r'^api/v(?P<version>[12])/products/$', views.api_products)
→ re_path(r'^api/v(?P<version>[12])/products/$', views.api_products)

url(r'^files/(?P<path>.+\.(jpg|png))$', views.serve_image)
→ re_path(r'^files/(?P<path>.+\.(jpg|png))$', views.serve_image)
```

總計：5 個（6%）

### 遷移工作量

| 類別 | 數量 | 難度 | 預計時間 |
|------|------|------|----------|
| 簡單路徑 | 67 | 低 | 30 min（可自動化） |
| 帶參數路徑 | 15 | 中 | 20 min |
| 複雜正則 | 5 | 中 | 15 min |
| **總計** | **87** | - | **65 min** |

### 自動化建議

可以使用 `django-upgrade` 自動處理 90% 的情況：

```bash
pip install django-upgrade
django-upgrade --target-version 4.2 apps/*/urls.py config/urls.py
```

剩餘 10% 需要人工檢查。
```

**檢查點**：
- [ ] 找出所有使用舊 API 的文件
- [ ] 按複雜度分類
- [ ] 評估了工作量
- [ ] 確定了自動化策略

---

#### 步驟 2：掃描 ORM 模型問題

```bash
/grep "ForeignKey\(" --type py -C 3

提示詞：
請找出所有缺少 on_delete 參數的 ForeignKey 定義：

1. 掃描所有 models.py 文件
2. 找出 ForeignKey 和 OneToOneField 定義
3. 檢查是否包含 on_delete 參數
4. 統計需要添加 on_delete 的數量

對每個外鍵分析應該使用哪種 on_delete：
- CASCADE：級聯刪除
- PROTECT：防止刪除
- SET_NULL：設為 NULL
- SET_DEFAULT：設為默認值
```

**預期輸出**：

```markdown
## ORM 模型掃描報告

### 缺少 on_delete 的外鍵（34 處）

#### 高優先（核心業務模型）

apps/orders/models.py:23
```python
class Order(models.Model):
    user = models.ForeignKey(User)  # ❌ 缺少 on_delete
    # 建議：CASCADE（刪除用戶時刪除訂單）
```

apps/orders/models.py:34
```python
class OrderItem(models.Model):
    order = models.ForeignKey(Order)  # ❌ 缺少 on_delete
    product = models.ForeignKey('products.Product')  # ❌
    # 建議：order → CASCADE，product → PROTECT
```

apps/payments/models.py:15
```python
class Payment(models.Model):
    order = models.ForeignKey('orders.Order')  # ❌
    # 建議：PROTECT（有支付記錄的訂單不能刪除）
```

#### 中優先（輔助模型）

apps/products/models.py:45
```python
class ProductImage(models.Model):
    product = models.ForeignKey(Product)  # ❌
    # 建議：CASCADE（刪除商品時刪除圖片）
```

### on_delete 選擇指南

| 場景 | 推薦值 | 原因 |
|------|--------|------|
| OrderItem → Order | CASCADE | 訂單刪除時，訂單項也應刪除 |
| Order → User | CASCADE | 用戶刪除時，訂單也刪除 |
| Payment → Order | PROTECT | 有支付記錄的訂單不能刪除 |
| Product → Category | SET_NULL | 分類刪除時，商品保留但分類清空 |
| OrderItem → Product | PROTECT | 有訂單的商品不能刪除 |

### 遷移計劃

1. **先添加，後測試**（不要直接刪除舊代碼）
2. **按業務優先級**：Orders → Payments → Products → Others
3. **每個 app 一個 migration**
4. **充分測試刪除行為**

### 示例遷移

```python
# apps/orders/models.py

class Order(models.Model):
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,  # 新增
        related_name='orders'
    )

class OrderItem(models.Model):
    order = models.ForeignKey(
        Order,
        on_delete=models.CASCADE,  # 訂單刪除時級聯刪除
        related_name='items'
    )
    product = models.ForeignKey(
        'products.Product',
        on_delete=models.PROTECT,  # 防止刪除有訂單的商品
        related_name='order_items'
    )
```

### 風險提示 ⚠️

**重要**：on_delete 行為會影響數據完整性！

- CASCADE：可能意外刪除大量數據
- PROTECT：可能導致無法刪除（需要業務確認）
- SET_NULL：確保字段允許 NULL

**建議**：在測試環境先執行刪除操作測試。
```

**檢查點**：
- [ ] 找出所有缺少 on_delete 的外鍵
- [ ] 為每個外鍵選擇了合適的 on_delete
- [ ] 理解了各種 on_delete 的影響
- [ ] 評估了數據風險

---

#### 步驟 3：掃描其他廢棄 API

```bash
/grep "force_text\|smart_text\|ugettext" --type py

提示詞：
請找出以下廢棄 API 的使用：

1. django.utils.encoding.force_text → force_str
2. django.utils.encoding.smart_text → smart_str
3. django.utils.translation.ugettext → gettext
4. django.contrib.postgres.fields.JSONField → django.db.models.JSONField

統計每種 API 的使用次數和位置。
```

**預期輸出**：

```markdown
## 廢棄 API 使用統計

### 1. force_text → force_str（23 處）

apps/core/utils.py:12, 34, 56
apps/accounts/views.py:89
apps/products/serializers.py:23, 45
...

**批量替換命令**：
```bash
find . -name "*.py" -exec sed -i 's/force_text/force_str/g' {} \;
find . -name "*.py" -exec sed -i 's/from django.utils.encoding import force_text/from django.utils.encoding import force_str/g' {} \;
```

### 2. JSONField 導入路徑變更（8 處）

apps/products/models.py:3
apps/orders/models.py:5

**修改**：
```python
# 舊
from django.contrib.postgres.fields import JSONField

# 新
from django.db.models import JSONField
```

### 3. ugettext → gettext（34 處）

主要在翻譯字符串：

```python
# 舊
from django.utils.translation import ugettext as _

# 新
from django.utils.translation import gettext as _
```

**批量替換**：
```bash
find . -name "*.py" -exec sed -i 's/ugettext/gettext/g' {} \;
```

### 遷移優先級

🔴 **高優先（阻塞升級）**：
- ForeignKey on_delete（34 處）
- URL 配置（87 處）

🟡 **中優先（有警告）**：
- force_text → force_str（23 處）
- JSONField 導入（8 處）

🟢 **低優先（向後兼容）**：
- ugettext → gettext（34 處）
- 可以升級後再慢慢改
```

**檢查點**：
- [ ] 掃描了所有廢棄 API
- [ ] 統計了使用次數
- [ ] 評估了遷移優先級
- [ ] 準備了批量替換命令

---

### 階段二：制定遷移計劃（20 分鐘）

**目標**：制定安全、可執行的升級計劃

```bash
提示詞：
基於以上掃描結果，請制定詳細的 Django 升級計劃：

1. 分階段執行（每個階段可獨立測試）
2. 處理依賴順序（先解決阻塞問題）
3. 測試策略（單元測試、集成測試、手動測試）
4. 回滾方案（如果升級失敗）
5. 部署策略（藍綠部署？金絲雀？）

時間預算：2-3 天（包含測試）
```

**預期計劃**：

```markdown
## Django 2.2 → 4.2 升級執行計劃

### Phase 0：準備工作（半天）

#### 0.1 備份與環境準備
- [ ] 備份生產數據庫
- [ ] 創建升級分支：`git checkout -b upgrade/django-4.2`
- [ ] 設置 Django 3.2 測試環境（中間版本，減少跨度）

#### 0.2 補充測試
- [ ] 為核心功能添加集成測試
- [ ] 記錄當前測試覆蓋率（基準）
- [ ] 為 ORM 操作添加刪除行為測試

```bash
# 運行測試確保當前版本正常
pytest tests/ -v --cov=apps
```

#### 0.3 依賴檢查
```bash
# 檢查第三方包兼容性
pip list --outdated
# 關鍵包：djangorestframework, celery, channels, etc.
```

---

### Phase 1：代碼遷移（1 天）

#### 1.1 URL 配置遷移（2 小時）

**工具**：使用 `django-upgrade` 自動化

```bash
# 安裝工具
pip install django-upgrade

# 自動升級 URL 配置
django-upgrade --target-version 4.2 \
    config/urls.py \
    apps/*/urls.py

# 手動檢查複雜正則（5 個）
```

**驗證**：
```bash
python manage.py check --deploy
```

**提交**：
```bash
git add -A
git commit -m "refactor(urls): migrate to Django 4.2 path() syntax"
```

#### 1.2 ORM 模型遷移（3 小時）

**執行順序**：
1. Orders app（核心業務）
2. Payments app（依賴 Orders）
3. Products app
4. Accounts app
5. 其他 apps

**示例**：

```python
# apps/orders/models.py

class Order(models.Model):
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='orders'
    )
    # ...

# 生成 migration
python manage.py makemigrations orders

# 檢查 migration SQL
python manage.py sqlmigrate orders 0XXX

# 在測試環境執行
python manage.py migrate --database=test_db
```

**測試刪除行為**：
```python
# tests/test_deletion_behavior.py

def test_delete_user_cascades_to_orders():
    """測試刪除用戶時訂單也被刪除"""
    user = User.objects.create(username='test')
    order = Order.objects.create(user=user)

    user.delete()

    assert Order.objects.filter(id=order.id).count() == 0

def test_cannot_delete_product_with_orders():
    """測試無法刪除有訂單的商品"""
    product = Product.objects.create(name='Test')
    order = Order.objects.create(...)
    OrderItem.objects.create(order=order, product=product)

    with pytest.raises(ProtectedError):
        product.delete()
```

**提交**：每個 app 一個 commit

#### 1.3 廢棄 API 替換（1 小時）

**批量替換**：

```bash
# force_text → force_str
find apps/ -name "*.py" -type f -exec sed -i 's/force_text/force_str/g' {} \;
find apps/ -name "*.py" -type f -exec sed -i 's/smart_text/smart_str/g' {} \;

# JSONField 導入路徑
find apps/ -name "*.py" -type f -exec sed -i \
    's/from django.contrib.postgres.fields import JSONField/from django.db.models import JSONField/g' {} \;

# 翻譯函數
find apps/ -name "*.py" -type f -exec sed -i 's/ugettext/gettext/g' {} \;
```

**驗證**：
```bash
# 檢查語法錯誤
python -m py_compile apps/**/*.py

# 運行測試
pytest tests/ -v
```

**提交**：
```bash
git commit -m "refactor: replace deprecated Django APIs"
```

#### 1.4 Middleware 遷移（1 小時）

如果有自定義 middleware：

```python
# 舊格式
class OldMiddleware:
    def process_request(self, request):
        pass

# 新格式
class NewMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # process_request logic
        response = self.get_response(request)
        # process_response logic
        return response
```

---

### Phase 2：升級 Django 版本（2 小時）

#### 2.1 先升級到 Django 3.2（中間版本）

```bash
# requirements.txt
Django==3.2.20  # LTS 版本

# 安裝
pip install -r requirements.txt

# 運行測試
pytest tests/ -v
```

**為什麼先升級到 3.2？**
- 減少跨度，降低風險
- 3.2 也是 LTS，如果 4.2 有問題可以停留在 3.2

#### 2.2 再升級到 Django 4.2

```bash
# requirements.txt
Django==4.2.5  # 最新 LTS

# 安裝
pip install -r requirements.txt

# 運行 check
python manage.py check --deploy

# 運行測試
pytest tests/ -v --cov=apps

# 手動測試關鍵功能
```

#### 2.3 更新第三方依賴

```bash
# 檢查兼容性
pip install django-rest-framework==3.14.0
pip install celery==5.3.1
pip install channels==4.0.0

# 測試
pytest tests/
```

---

### Phase 3：測試與驗證（半天）

#### 3.1 自動化測試

```bash
# 單元測試
pytest tests/unit/ -v

# 集成測試
pytest tests/integration/ -v

# E2E 測試（關鍵業務流程）
pytest tests/e2e/ -v

# 覆蓋率檢查（不應下降）
pytest --cov=apps --cov-report=html
```

#### 3.2 性能測試

```bash
# 數據庫查詢性能
python manage.py test --debug-sql

# 使用 django-silk 或 django-debug-toolbar 檢查慢查詢
```

#### 3.3 手動測試清單

- [ ] 用戶註冊/登入
- [ ] 創建訂單
- [ ] 支付流程
- [ ] 訂單查詢
- [ ] 管理後台操作
- [ ] API 接口測試

---

### Phase 4：部署上線（半天）

#### 4.1 預發布環境

```bash
# 部署到 staging
git push origin upgrade/django-4.2

# 運行 migration
python manage.py migrate

# 煙霧測試
curl -X GET https://staging.example.com/api/health/
```

#### 4.2 生產環境部署

**策略**：藍綠部署（零停機）

```bash
# 1. 部署新版本到綠色環境
# 2. 運行 migration（數據庫 migration 向後兼容）
# 3. 健康檢查
# 4. 切換流量（10% → 50% → 100%）
# 5. 監控錯誤率
# 6. 如果有問題，立即回滾
```

**監控指標**：
- 錯誤率（< 0.1%）
- 響應時間（< 500ms p95）
- 數據庫連接數（正常範圍）

#### 4.3 回滾預案

如果升級失敗：

```bash
# 1. 切換流量回藍色環境
# 2. 回滾數據庫 migration（如果有）
python manage.py migrate orders 0XXX  # 回到之前的 migration

# 3. 回滾代碼
git revert <commit-hash>
```

---

### 驗證清單

每個 Phase 完成後檢查：

- [ ] 所有自動化測試通過
- [ ] 代碼無語法錯誤
- [ ] `python manage.py check --deploy` 無警告
- [ ] Git commit 歷史清晰
- [ ] 關鍵功能手動測試通過

### 時間預算

| Phase | 預計時間 | 累計時間 |
|-------|----------|----------|
| Phase 0 | 4 小時 | 4 小時 |
| Phase 1 | 7 小時 | 11 小時 |
| Phase 2 | 2 小時 | 13 小時 |
| Phase 3 | 4 小時 | 17 小時 |
| Phase 4 | 4 小時 | 21 小時 |
| **總計** | **21 小時（約 3 天）** | - |

### 風險與對策

| 風險 | 概率 | 影響 | 對策 |
|------|------|------|------|
| 第三方包不兼容 | 中 | 高 | 提前檢查，尋找替代品 |
| on_delete 行為意外 | 中 | 高 | 充分測試刪除操作 |
| 性能下降 | 低 | 中 | 性能測試，優化慢查詢 |
| 部署失敗 | 低 | 高 | 藍綠部署，快速回滾 |
```

**檢查點**：
- [ ] 制定了分階段計劃
- [ ] 評估了時間和風險
- [ ] 準備了測試策略
- [ ] 設計了回滾方案

---

### 階段三：執行遷移（60 分鐘）

**目標**：按計劃執行遷移

**執行要點**：

1. **嚴格按計劃執行**：不要跳步驟
2. **頻繁測試**：每個 Phase 都運行測試
3. **及時提交**：每個邏輯單元 commit 一次
4. **記錄問題**：遇到意外問題記錄到 CLAUDE.md

**使用 Claude 輔助**：

```bash
# 示例：批量修改 ForeignKey

提示詞：
請幫我為 apps/orders/models.py 中的所有 ForeignKey 添加 on_delete 參數：

Order.user → on_delete=models.CASCADE
OrderItem.order → on_delete=models.CASCADE
OrderItem.product → on_delete=models.PROTECT

輸出修改後的完整 models.py 文件。
```

**檢查點**：
- [ ] 完成了所有代碼修改
- [ ] 每步都運行了測試
- [ ] Git 歷史清晰
- [ ] 功能正常工作

---

### 階段四：驗證與記錄（10 分鐘）

**目標**：確認升級成功，沉澱經驗

#### 最終驗證

```bash
# 完整測試套件
pytest tests/ -v --cov=apps

# Django check
python manage.py check --deploy

# 手動測試關鍵流程
# ...
```

#### 生成升級報告

```bash
提示詞：
請生成一份 Django 升級報告，包含：

1. 升級前後版本對比
2. 修改統計（多少文件、多少行）
3. 主要變更列表
4. 遇到的問題與解決方案
5. 性能對比（如果有數據）
6. 後續優化建議
```

#### 沉澱到記憶庫

```bash
/memory save

主題：Django 大版本升級最佳實踐（2.2 → 4.2）

關鍵步驟：
1. 掃描與評估（/grep 批量查找）
   - URL 配置：django.conf.urls.url
   - ORM 外鍵：ForeignKey.*on_delete
   - 廢棄 API：force_text, ugettext, JSONField
   - 統計影響範圍和工作量

2. 制定分階段計劃
   - Phase 0: 準備（備份、測試、依賴檢查）
   - Phase 1: 代碼遷移（URL、Models、API）
   - Phase 2: 升級版本（3.2 → 4.2 分步）
   - Phase 3: 測試驗證
   - Phase 4: 部署上線

3. 安全遷移策略
   - 先中間版本（2.2 → 3.2 → 4.2）降低風險
   - 每個 app 單獨 migration
   - 充分測試刪除行為（on_delete）
   - 藍綠部署，快速回滾

4. 自動化工具
   - django-upgrade：自動重寫代碼
   - sed：批量文本替換
   - pytest：自動化測試
   - coverage：覆蓋率檢查

5. 關鍵 Breaking Changes
   - URL: url() → path() / re_path()
   - ORM: on_delete 成為必填
   - API: force_text → force_str
   - Middleware: 新格式要求

常用查找命令：
- URL 配置：/grep "from django.conf.urls import url" --type py
- 缺少 on_delete：/grep "ForeignKey\(" --type py -C 3
- 廢棄 API：/grep "force_text\|ugettext" --type py

風險控制：
- 備份數據庫（可回滾）
- 分階段執行（可測試）
- 藍綠部署（可切換）
- 監控指標（可觀察）

時間預算：
- 小項目（< 10k 行）：1 天
- 中項目（10k-50k 行）：2-3 天
- 大項目（> 50k 行）：1-2 週

相關工具：django-upgrade, pytest, coverage, django-silk
相關指令：/grep（查找廢棄 API），/read（理解變更）
```

**檢查點**：
- [ ] 所有測試通過
- [ ] Django 4.2 運行正常
- [ ] 生成了升級報告
- [ ] 沉澱了經驗到 /memory

---

## 驗證標準

### 必須達成 ✅

- [ ] 成功將 Django 從 2.2 升級到 4.2
- [ ] 所有 URL 配置遷移到新語法
- [ ] 所有 ForeignKey 添加了 on_delete
- [ ] 所有廢棄 API 已替換
- [ ] 所有測試通過，覆蓋率未下降
- [ ] 關鍵功能手動測試通過
- [ ] 使用 /memory 沉澱了升級經驗

### 額外成就 🌟

- [ ] 使用自動化工具（django-upgrade）
- [ ] 為 on_delete 行為補充了測試
- [ ] 升級了所有第三方依賴到最新兼容版本
- [ ] 實現了藍綠部署
- [ ] 編寫了升級文檔供團隊參考
- [ ] 設置了依賴版本監控（定期檢查更新）

---

## 學習反思

### 反思問題

1. **規劃的重要性**：
   - 為什麼大版本升級需要詳細計劃？
   - 如何評估 breaking changes 的影響範圍？
   - 分階段執行的好處是什麼？

2. **風險控制**：
   - on_delete 參數為什麼是高風險變更？
   - 如何在不影響生產的前提下測試刪除行為？
   - 藍綠部署相比直接升級有什麼優勢？

3. **自動化工具**：
   - django-upgrade 能處理多少比例的遷移？
   - 哪些情況必須人工判斷？
   - 如何驗證自動化工具的正確性？

4. **技術債務**：
   - 為什麼要及時升級框架版本？
   - 如何平衡新功能開發與技術升級？
   - 如何說服管理層投入時間做升級？

### 延伸練習

1. **編寫自動化升級腳本**：
   - 自動檢測廢棄 API
   - 生成升級報告
   - 提供修復建議

2. **建立依賴管理流程**：
   - 定期檢查依賴更新（dependabot）
   - 自動運行安全掃描（safety, bandit）
   - 設置 CI 測試多版本兼容性

3. **處理更複雜的升級**：
   - Python 2 → Python 3
   - PostgreSQL 大版本升級
   - Redis 集群升級

---

## 相關資源

### 下一步學習

- **C09**：性能瓶頸優化 - 使用 /grep 找慢查詢
- **C10**：錯誤處理增強 - 系統化改進
- **模組 4**：CI/CD 集成 - 自動化測試與部署

### 工具參考

- **django-upgrade**：自動升級 Django 代碼
- **pip-tools**：依賴管理
- **safety**：安全漏洞掃描
- **dependabot**：自動依賴更新
- **django-silk**：性能分析

### 學習資源

- **Django Release Notes**：官方升級指南
- **Django Deprecation Timeline**：廢棄時間表
- **Django Best Practices**
- **《Two Scoops of Django》**

---

**建議完成時間**：2-2.5 小時（實際項目需 2-3 天）
**難度評估**：4/5
**重要度**：5/5（框架升級是必須的維護工作）
**可複用性**：5/5（方法適用於任何框架升級）
