# S1.5：批量檔案重命名

## 📋 情境資訊

- **難度**：⭐
- **預估時間**：30 分鐘
- **核心學習**：bash 整合、批量檔案操作、模式匹配和替換
- **前置知識**：Claude Code 基本操作、檔案系統概念

---

## 🎯 情境背景

你負責整理公司的設計資源庫，發現有一批檔案的命名非常混亂。這些檔案是從不同設計師那裡收集來的，命名方式五花八門：有些包含空格，有些用了不規範的字元，還有些檔案名稱對專案歸屬不明確。為了建立統一的命名規範，你需要批量重新命名這些檔案。

**檔案現況**:
- 設計檔案：200+ 個檔案（PSD, AI, SVG, PNG 等）
- 命名問題：包含空格、特殊字元、中英混雜、缺乏版本資訊
- 需求：統一命名為 `project_name_file_type_version.ext` 格式
- 專案分類：mobile-app, website, branding, marketing
- 需要保留原始檔案作為備份

**具體命名範例**:
```
混亂的現況：
- "首頁設計 最終版.psd"
- "logo_v2 (1).ai"
- "button-design final.svg"
- "app界面@2x.png"

期望的結果：
- "website_homepage_design_v3.psd"
- "branding_logo_vector_v2.ai"
- "mobile-app_button_component_v1.svg"
- "mobile-app_interface_mockup_2x.png"
```

**你的任務**:
1. 分析現有檔案命名模式
2. 設計統一的命名規則
3. 分類檔案到對應專案
4. 批量執行重命名操作
5. 建立操作記錄和備份

---

## 🎓 學習目標

完成本情境後，你將能夠：

- ✅ 結合 Claude Code 與 bash 指令進行檔案操作
- ✅ 設計和應用檔案命名規範
- ✅ 使用模式匹配進行批量處理
- ✅ 安全地執行大量檔案重命名
- ✅ 建立操作記錄和回復機制
- ✅ 處理檔案名稱中的特殊字元和編碼問題

---

## 📝 任務描述

### 階段 1: 現況分析與規則設計 (10 分鐘)

#### 任務 1.1: 檔案現況分析

**Linux 類比**: 像使用 `ls -la` 和 `grep` 分析檔案，但 Claude Code 提供智能分析。

假設檔案位於 `~/design-assets/messy-files/`：

```bash
# 1. 進入目錄
cd ~/design-assets/messy-files/

# 2. 啟動 Claude Code
claude
```

**分析對話**:
```
我需要整理這個設計資源目錄的檔案命名。

請先幫我分析現況：

/bash ls -la

然後分析檔案命名問題：

/glob "**/*"

請整理出：
1. 檔案類型分布（.psd, .ai, .svg, .png 等）
2. 常見命名問題（空格、特殊字元、不規範格式）
3. 可能的專案分類
4. 需要標準化的命名元素
```

#### 任務 1.2: 設計命名規範

```
基於分析結果，請幫我設計一個統一的檔案命名規範：

目標格式：project_category_description_version.extension

考慮因素：
- 專案類型：mobile-app, website, branding, marketing
- 檔案用途：design, mockup, icon, logo, component
- 版本控制：v1, v2, v3 或 final, draft
- 特殊標記：2x (高解析度), dark/light (主題)

請提供：
1. 詳細命名規則說明
2. 各專案類型的範例
3. 特殊情況處理方法
```

#### 任務 1.3: 分類策略制定

```
請幫我制定檔案分類策略：

/bash ls | head -20

根據檔案名稱內容，如何判斷檔案屬於哪個專案類型？

設計判斷邏輯：
- 包含 "app", "mobile" → mobile-app
- 包含 "logo", "brand" → branding
- 包含 "web", "site", "homepage" → website
- 包含 "ad", "poster", "campaign" → marketing

請提供更完整的分類規則。
```

**檢查點 1**:
- [ ] 完成檔案現況分析
- [ ] 設計出統一命名規範
- [ ] 制定檔案分類策略

---

### 階段 2: 批量重命名腳本生成 (10 分鐘)

#### 任務 2.1: 生成重命名指令

```
現在請幫我生成批量重命名的 bash 指令。

首先建立安全的工作環境：

請提供指令來：
1. 建立備份目錄
2. 複製所有檔案到備份
3. 建立操作日誌檔案
4. 設定安全檢查機制
```

**預期輸出範例**:
```bash
# 建立備份和工作目錄
mkdir -p backup/$(date +%Y%m%d_%H%M%S)
mkdir -p logs

# 備份所有檔案
cp -r . backup/$(date +%Y%m%d_%H%M%S)/
echo "Backup created at: backup/$(date +%Y%m%d_%H%M%S)/" > logs/rename_log.txt
```

#### 任務 2.2: 分類別處理指令

```
請為每個檔案類型生成具體的重命名指令：

1. **PSD 檔案處理**（設計原始檔）
2. **AI 檔案處理**（向量圖形）
3. **SVG 檔案處理**（網頁圖示）
4. **PNG/JPG 檔案處理**（點陣圖）

每類檔案請提供：
- 檔案查找指令
- 命名轉換邏輯
- mv 重命名指令
- 錯誤處理機制

範例格式：
```bash
# 處理 PSD 檔案
for file in *.psd; do
    # 分析檔案名稱並轉換
    new_name="..."
    mv "$file" "$new_name"
    echo "Renamed: $file -> $new_name" >> logs/rename_log.txt
done
```
```

#### 任務 2.3: 特殊字元處理

```
請幫我處理檔案名稱中的特殊字元：

/bash ls | grep -E "[ ()\[\]@#$%^&*+]"

對於這些包含特殊字元的檔案，請提供：
1. 空格替換為底線
2. 移除或替換特殊符號
3. 處理中文字元
4. 統一大小寫規則

生成對應的處理指令。
```

**檢查點 2**:
- [ ] 生成安全的批量操作環境
- [ ] 建立分類別的重命名指令
- [ ] 處理特殊字元和編碼問題

---

### 階段 3: 執行重命名操作 (8 分鐘)

#### 任務 3.1: 測試運行

```
在執行大批量操作前，讓我們先測試幾個檔案：

請選擇 5 個代表性檔案進行測試重命名：

/bash ls | head -5

為這些檔案生成重命名指令，但先用 echo 來顯示而不執行：

```bash
# 測試模式：只顯示不執行
for file in [測試檔案]; do
    new_name="[新名稱]"
    echo "Would rename: $file -> $new_name"
done
```

請確認命名結果符合預期。
```

#### 任務 3.2: 執行重命名

確認測試結果後：

```
請生成完整的批量重命名腳本，包含：

1. **安全檢查**：確認備份完成
2. **進度顯示**：顯示處理進度
3. **錯誤處理**：記錄失敗的操作
4. **統計報告**：成功/失敗數量

腳本格式：

```bash
#!/bin/bash
# 設計檔案批量重命名腳本

set -e  # 遇錯停止

# 初始化
total_files=0
success_count=0
error_count=0

echo "開始批量重命名操作..."

# 處理每種檔案類型
# ...

echo "重命名完成！成功: $success_count, 失敗: $error_count"
```

然後執行這個腳本。
```

#### 任務 3.3: 驗證結果

```
重命名完成後，請幫我驗證結果：

/bash ls -la | head -20

檢查：
1. 新檔案名是否符合命名規範
2. 檔案數量是否正確（無遺失）
3. 檔案完整性（大小和修改時間）
4. 是否有命名衝突

生成驗證報告。
```

**檢查點 3**:
- [ ] 成功執行測試重命名
- [ ] 完成批量重命名操作
- [ ] 驗證結果正確無誤

---

### 階段 4: 後續整理與優化 (2 分鐘)

#### 任務 4.1: 生成操作報告

```
請根據操作日誌生成完整報告：

/bash cat logs/rename_log.txt

生成報告包含：
1. **操作摘要**：處理檔案數量、成功率
2. **命名統計**：各專案類型檔案數量
3. **問題記錄**：遇到的困難和解決方法
4. **改進建議**：未來命名規範維護建議

格式化為易讀的 Markdown 格式。
```

#### 任務 4.2: 建立維護指南

```
請為未來的檔案命名維護建立指南：

內容包括：
1. **命名規範文檔**：標準格式和範例
2. **檢查腳本**：定期檢查命名規範遵循
3. **新檔案指引**：設計師上傳檔案的命名要求
4. **自動化建議**：如何設置檔案命名自動檢查

這個指南要讓其他同事也能輕鬆維護檔案命名規範。
```

**最終檢查點**:
- [ ] 生成完整操作報告
- [ ] 建立檔案命名維護指南
- [ ] 所有檔案成功重命名並符合規範

---

## ✅ 檢查點

### 基礎檢查點 (必須完成)

- [ ] **批量操作**: 成功重命名大部分檔案
- [ ] **命名規範**: 新檔案名符合統一標準
- [ ] **備份安全**: 建立完整備份，可以回復
- [ ] **bash 整合**: 熟練使用 `/bash` 指令執行操作
- [ ] **錯誤處理**: 處理特殊字元和命名衝突

### 進階檢查點 (建議完成)

- [ ] **自動化腳本**: 建立可重複使用的重命名腳本
- [ ] **智能分類**: 根據內容自動判斷檔案類型
- [ ] **品質控制**: 建立命名規範檢查機制
- [ ] **團隊協作**: 制定團隊檔案命名標準
- [ ] **維護計劃**: 建立長期維護和監控機制

---

## 🎯 自然學到的指令

通過本情境，你應該自然學會以下指令組合：

### 檔案操作基礎

| 指令 | 用途 | 何時使用 |
|------|------|----------|
| `/bash ls -la` | 詳細檔案清單 | 分析檔案資訊 |
| `/bash mv "old" "new"` | 重命名檔案 | 單個檔案重命名 |
| `/bash cp -r source dest` | 遞迴複製 | 建立備份 |
| `/bash mkdir -p path` | 建立目錄結構 | 準備工作環境 |

### 批量處理模式

| 模式 | 語法範例 | 應用場景 |
|------|----------|----------|
| **for 迴圈** | `for file in *.ext; do ... done` | 同類型檔案處理 |
| **條件判斷** | `if [[ "$file" =~ pattern ]]; then` | 智能分類處理 |
| **字串替換** | `${filename// /_}` | 清理檔案名稱 |
| **模式匹配** | `case "$file" in pattern)` | 多條件分類 |

### 安全操作原則

**原則 1: 備份優先**
```bash
# 永遠先備份
cp -r original backup_$(date +%Y%m%d)
```

**原則 2: 測試先行**
```bash
# 先用 echo 測試
echo "Would rename: $old -> $new"
# 確認無誤再執行
mv "$old" "$new"
```

**原則 3: 記錄操作**
```bash
# 記錄每個操作
echo "$(date): $old -> $new" >> rename_log.txt
```

---

## ❓ 常見問題

### Q1: 檔案名稱包含空格導致指令失敗

**原因**: Bash 將空格視為參數分隔符

**解決方法**:
```bash
# 錯誤方式
mv file name.txt new_name.txt  # 失敗

# 正確方式
mv "file name.txt" "new_name.txt"  # 成功

# 或在 for 迴圈中
for file in *; do
    mv "$file" "${file// /_}"  # 空格替換為底線
done
```

---

### Q2: 重命名後出現檔案名稱衝突

**解決策略**: 檢查重複並添加序號

**解決方法**:
```bash
# 檢查重複並處理
new_name="desired_name.ext"
counter=1

while [[ -f "$new_name" ]]; do
    name_part="${new_name%.*}"
    ext="${new_name##*.}"
    new_name="${name_part}_${counter}.${ext}"
    ((counter++))
done

mv "$old_file" "$new_name"
```

---

### Q3: 批量操作中途失敗如何處理

**回復策略**: 使用操作日誌回復

**解決方法**:
```bash
# 從日誌回復操作
while IFS= read -r line; do
    if [[ $line =~ "Renamed: (.+) -> (.+)" ]]; then
        old_name="${BASH_REMATCH[2]}"
        original_name="${BASH_REMATCH[1]}"
        mv "$old_name" "$original_name"
        echo "Reverted: $old_name -> $original_name"
    fi
done < rename_log.txt
```

---

### Q4: 如何處理不同語言和特殊字元

**處理策略**: 標準化字元轉換

**解決方法**:
```
請幫我建立字元轉換規則：

1. 中文字元：轉為拼音或移除
2. 特殊符號：替換為底線或移除
3. 大小寫：統一為小寫
4. 連續符號：合併為單一底線

請生成對應的 bash 替換指令：

# 範例處理
filename="設計稿@最終版(1).psd"
# 處理後: "sheji_final_v1.psd"
```

---

## 🚀 延伸挑戰

### 挑戰 1: 智能檔案分類系統

**任務**: 基於檔案內容和metadata進行智能分類

**技術要點**:
- 使用 `file` 指令分析檔案類型
- 讀取圖檔的 EXIF 資訊
- 分析檔案大小和尺寸
- 機器學習輔助分類

**實作範例**:
```bash
# 分析圖檔尺寸決定用途
identify_usage() {
    local file="$1"
    local size=$(identify -format "%wx%h" "$file" 2>/dev/null)

    case "$size" in
        "1920x1080"|"1366x768") echo "wallpaper" ;;
        *"x32"|*"x64") echo "icon" ;;
        *) echo "general" ;;
    esac
}
```

---

### 挑戰 2: 版本控制整合

**任務**: 將檔案重命名與版本控制結合

**目標**:
- 自動檢測檔案版本號
- 整合 Git 提交歷史
- 建立檔案變更追蹤

**實作思路**:
```bash
# 基於 Git 歷史決定版本號
get_version_from_git() {
    local file="$1"
    local commit_count=$(git log --oneline -- "$file" | wc -l)
    echo "v$commit_count"
}

# 重命名時更新 Git
rename_with_git() {
    local old="$1"
    local new="$2"

    git mv "$old" "$new"
    git commit -m "Rename: $old -> $new (standardization)"
}
```

---

### 挑戰 3: 自動化工作流程

**任務**: 建立檔案上傳時的自動命名系統

**特色**:
- 監控檔案夾變化
- 自動應用命名規則
- 整合設計工具輸出

**系統設計**:
```bash
# 使用 inotify 監控檔案變化
inotifywait -m ~/design-uploads -e create --format '%w%f' |
while read file; do
    # 自動重命名新檔案
    auto_rename "$file"

    # 移動到正確目錄
    categorize_and_move "$file"

    # 通知設計師
    notify_designer "$file"
done
```

---

## 📚 相關資源

### Bash 檔案操作參考

| 操作類型 | 常用指令 | 進階用法 |
|----------|----------|----------|
| **重命名** | `mv old new` | `rename 's/old/new/' files` |
| **批量處理** | `for file in *` | `find . -exec {}` |
| **字串處理** | `${var//pattern/replace}` | `sed`, `awk` |
| **檔案檢查** | `[ -f file ]` | `stat`, `file` |

### 課程資源

- **理論**: `2.5_Bash_整合與自動化.md`
- **下一步**: `S1.6_程式碼註解增強.md`

### 命名規範最佳實踐

```bash
# 好的命名規範範例
project_component_type_version.ext

# 具體範例
mobile-app_button_component_v2.svg
website_header_layout_final.psd
branding_logo_vector_v3.ai
marketing_poster_design_draft.png

# 避免的命名方式
"最終版本 (1).psd"           # 中文 + 空格 + 括號
"logo.final.FINAL.ai"        # 不清楚的版本號
"untitled-1-copy-2.svg"      # 無意義的命名
```

---

## 📝 反思問題

完成情境後，思考以下問題：

1. **效率提升**: 批量重命名相比手動操作節省了多少時間？

2. **規範化價值**: 統一命名規範對團隊協作有什麼幫助？

3. **自動化思維**: 還有哪些重複性檔案操作可以自動化？

4. **錯誤預防**: 如何設計更安全的批量操作機制？

5. **標準推廣**: 如何讓團隊成員養成良好的檔案命名習慣？

---

**情境版本**: v1.0
**最後更新**: 2025-01-30
**預估完成率**: 85% 學員能在 30 分鐘內完成基本批量重命名
**常見卡點**: 特殊字元處理 (20%), bash 語法錯誤 (15%)