# 9.1 三大工具核心差異

## 本節目標

**學習成果**：理解 Claude Code、GitHub Copilot、Cursor 三大工具的本質差異，建立正確的心智模型。

**閱讀時間**：20 分鐘

**檢查點**：讀完後能用 Linux 編輯器類比解釋三大工具的定位。

---

## 引言：工具選擇的困惑

### 開發者的真實困境

```
早上 9:00 - 新任務
任務：為電商系統重構支付模組（涉及 50+ 檔案）

內心 OS：
"開 Claude Code？會不會太慢？"
"用 Copilot？但它能理解整個架構嗎？"
"Cursor？好像很多人推薦..."

結果：花了 15 分鐘猶豫，還是隨便選了一個
```

**問題根源**：我們把這三個工具當作"類似的 AI 助手"，實際上它們有本質差異。

### Linux 編輯器類比

在 Linux 世界，沒有人問"vim 好還是 nano 好"，因為老手知道：

```bash
# 快速修改配置文件
nano /etc/nginx/nginx.conf     # 選 nano - 快速簡單

# 寫複雜 shell 腳本
vim deployment_script.sh       # 選 vim - 強大高效

# 需要 IDE 功能（程式開發）
emacs project.el               # 選 emacs - 全功能環境
```

**核心原則**：不同工具為不同場景優化，沒有絕對的"最好"。

AI 工具也是如此：

```
Claude Code = vim      # 強大但需學習，適合複雜任務
Copilot = nano         # 簡單快速，適合日常編輯
Cursor = gedit/Kate    # 視覺化友善，適合中等任務
```

---

## Section 1: Claude Code 深度分析

### 1.1 核心定位：深度思考夥伴

Claude Code 不是"更強的 Copilot"，而是**完全不同的工作模式**。

#### 類比：Git vs Alias

```bash
# Git - 需要理解概念，但能做複雜事情
git rebase -i HEAD~10          # 重整 10 個 commits
git bisect start               # 二分搜尋 bug
git cherry-pick <commit>       # 精準移植

# Alias - 即時高效，但功能單一
alias gs='git status'
alias gc='git commit'
```

Claude Code 就是 Git 級別的工具：

- 學習曲線陡峭，但掌握後威力驚人
- 需要理解概念（EPCV 工作流、Context 管理）
- 適合需要"深度思考"的任務

### 1.2 關鍵特性：200K Token Context

#### 這意味著什麼？

**量化對比**：

| 工具 | Context Window | 相當於 | 能理解的範圍 |
|------|----------------|--------|-------------|
| Copilot | ~8K tokens | 5-10 個檔案 | 當前檔案 + 相關檔案 |
| Cursor | ~32K tokens | 20-40 個檔案 | 小型模組 |
| Claude Code | ~200K tokens | 200-400 個檔案 | 整個專案 |

**實際案例**：

```
場景：重構一個 Express.js 電商後端

檔案結構：
/src
  /routes (15 files)
  /controllers (20 files)
  /models (12 files)
  /services (18 files)
  /middleware (8 files)
  /utils (10 files)
總計：83 個檔案，約 25,000 行代碼

Copilot 的視野：
├─ 能看到當前檔案
├─ 能猜測相關檔案（基於 imports）
└─ 無法理解整體架構
→ 重構時可能產生 breaking changes

Claude Code 的視野：
├─ 能看到整個 /src 目錄
├─ 理解所有模組的依賴關係
├─ 知道修改 A 會影響 B, C, D
└─ 能給出全局安全的重構方案
→ 重構時保證向後兼容
```

#### 技術實現：為什麼 Claude Code 能做到？

```
Copilot 架構（推測）：
IDE Extension
  ↓
Codex Model (小模型，快速)
  ↓
基於當前檔案和最近編輯的 context

Claude Code 架構：
CLI Tool
  ↓
Claude 3.5 Sonnet (大模型，深度)
  ↓
主動索引整個 codebase + Git history
```

**Trade-off**：
- Claude Code: 慢但深刻（生成一次需 10-30 秒）
- Copilot: 快但淺層（即時補全 < 1 秒）

### 1.3 EPCV 工作流：系統性思考

#### 什麼是 EPCV？

```
E - Explore: 探索代碼庫
P - Plan: 制定計劃
C - Create: 實作代碼
V - Verify: 驗證結果
```

**為什麼重要？**

```
傳統 AI 工具（如 Copilot）：
你："幫我寫一個登入 API"
AI："好的" → [直接生成代碼]
→ 沒有探索、沒有計劃、難以驗證

Claude Code + EPCV：
你："幫我重構登入模組"
AI：
  [E] "讓我先看看現有的登入邏輯..."
  [P] "我發現 3 個問題，建議分 4 步重構..."
  [C] "開始實作第 1 步：抽取驗證邏輯..."
  [V] "執行測試...修正 2 個邊界情況..."
→ 系統性、可追蹤、高品質
```

#### 實際案例：用 EPCV 重構支付模組

```bash
# Traditional approach with Copilot
你："重構支付模組"
Copilot：[給一段重構後的代碼]
你："咦，這樣會不會影響訂單模組？" ← 不確定

# EPCV approach with Claude Code
你：claude /refactor payment-module --strategy=epcv

[Explore Phase]
AI: "正在分析支付模組..."
    - payment-service.js (核心邏輯)
    - payment-controller.js (API endpoints)
    - order-service.js (依賴方)
    - webhook-handler.js (外部整合)

    發現 3 個風險點：
    1. order-service 依賴 payment-service.processPayment()
    2. webhook-handler 假設特定的回傳格式
    3. 沒有測試覆蓋 refund 流程

[Plan Phase]
AI: "建議的重構計劃（4 步）："
    Step 1: 為現有 API 增加測試（確保不破壞）
    Step 2: 抽取核心邏輯到 domain layer
    Step 3: 更新 payment-service，保持 API 兼容
    Step 4: 重構 webhook-handler 使用新接口

    確認繼續？[Y/n]

[Create Phase]
AI: "Step 1: 正在創建測試..."
    [生成 payment-service.test.js]

    "Step 2: 正在抽取 domain logic..."
    [生成 payment-domain.js]

    ...

[Verify Phase]
AI: "執行測試套件..."
    ✓ payment-service.test.js (15 tests passed)
    ✓ order-integration.test.js (8 tests passed)
    ✗ webhook-handler.test.js (1 test failed)

    發現問題：webhook 預期回傳 `status` 欄位
    已修正，重新測試...
    ✓ 所有測試通過
```

**結論**：EPCV 讓重構變成**可控制的系統工程**，而不是"希望不要出錯"的祈禱。

### 1.4 Agent 協作：專家模式

Claude Code 可以切換到不同的"專家模式"：

```bash
# 切換到安全審計專家
claude /agents:security-auditor

# 現在 AI 會從安全角度分析代碼
你："審查這個 API"
AI：[從 OWASP Top 10 角度分析]
    - SQL injection 風險
    - XSS 漏洞
    - 不安全的密碼存儲
    ...

# 切換到效能優化專家
claude /agents:performance-optimizer

# 現在 AI 會從效能角度分析
你："優化這個查詢"
AI：[從效能角度分析]
    - N+1 query 問題
    - 缺少索引
    - 可以用 eager loading
    ...
```

**類比**：就像 Git 有不同的工作流程（Git Flow, GitHub Flow），Claude Code 有不同的思考模式。

### 1.5 最適合的場景

Claude Code 在以下情況下無可取代：

#### ✅ 場景 1：大型代碼庫重構

```
專案：10 萬行 Python Django 專案
任務：從 Django 2.x 升級到 4.x

為什麼選 Claude Code？
- 需要理解 100+ models 的關係
- 需要識別所有 deprecated API 使用
- 需要確保 migration 的安全性
→ 只有 200K context 能做到
```

#### ✅ 場景 2：架構設計與技術決策

```
專案：設計一個新的微服務架構
任務：選擇技術棧、設計 API、規劃資料庫

為什麼選 Claude Code？
- 需要深度思考 trade-offs
- 需要基於現有系統做決策
- 需要生成完整的設計文檔
→ EPCV 工作流提供系統性思考
```

#### ✅ 場景 3：複雜 Bug 排查

```
問題：生產環境偶發性錯誤，難以重現
線索：錯誤日誌、用戶回報、系統監控數據

為什麼選 Claude Code？
- 需要分析多個模組的交互
- 需要理解並發競爭條件
- 需要追溯 Git history 找引入點
→ 深度分析能力 + Git 整合
```

#### ✅ 場景 4：學習新技術棧

```
任務：學習 Rust 並實作一個 CLI 工具

為什麼選 Claude Code？
- 需要深度解釋概念（ownership, lifetime）
- 需要理解整個專案結構
- 需要互動式的問答學習
→ 教學模式 + 深度對話
```

### 1.6 不適合的場景

Claude Code **不是萬能**，以下場景不建議使用：

#### ❌ 反場景 1：快速編寫簡單代碼

```
任務：寫一個 API endpoint 回傳用戶列表

問題：
- Claude Code 啟動需 5-10 秒
- 生成代碼需 10-20 秒
- 總時間：20-30 秒

Copilot：
- 即時補全
- 總時間：< 5 秒

結論：殺雞不用牛刀
```

#### ❌ 反場景 2：高頻率的自動補全

```
任務：寫一系列類似的測試案例

問題：
- Claude Code 需要每次發送請求
- 網路延遲 + 生成時間累積
- 10 個測試案例可能需 5 分鐘

Copilot：
- IDE 內即時補全
- 學習你的模式後更快
- 10 個測試案例可能需 1 分鐘

結論：高頻任務選低延遲工具
```

#### ❌ 反場景 3：網路不穩定環境

```
環境：咖啡廳、火車上、網路不穩定

問題：
- Claude Code 需要穩定網路連線
- API 請求可能超時或失敗
- 工作流程被打斷

Copilot：
- 有本地 cache 機制
- 網路斷線仍可基本工作

結論：穩定性要求高時選本地優先工具
```

### 1.7 學習曲線與成本

#### 時間投資

```
Copilot：
├─ 學習成本：1-2 小時
├─ 熟練時間：1 週
└─ 掌握程度：80% 功能

Claude Code：
├─ 學習成本：10-20 小時
├─ 熟練時間：1 個月
└─ 掌握程度：60% 功能（但威力大）
```

#### 經濟成本

```
Copilot：
├─ 個人版：$10/月
├─ 企業版：$19/月/人
└─ 使用限制：基本無限制

Claude Code（Claude API）：
├─ Pay-as-you-go
├─ 大約：$3-15/天（取決於使用頻率）
└─ 需注意 token 消耗
```

**建議**：
- 日常開發用 Copilot（成本可控）
- 重要任務用 Claude Code（價值高於成本）

---

## Section 2: GitHub Copilot 特點

### 2.1 核心定位：快速編碼助手

Copilot 的設計哲學：**最小化打斷，最大化流暢**。

#### 類比：Shell Alias

```bash
# 沒有 alias 的世界
git status
git add .
git commit -m "update"
git push origin main
# 每次都要打完整指令

# 有 alias 的世界
gs      # git status
ga      # git add
gc      # git commit
gp      # git push
# 思考→行動的延遲最小化
```

Copilot 就是"編碼的 alias"：

```python
# 你的思考流程
"我需要一個函數來驗證 email"

# 傳統流程
1. 想清楚邏輯
2. 打開瀏覽器搜尋 regex
3. 複製貼上
4. 調整代碼
5. 測試
→ 總時間：3-5 分鐘

# Copilot 流程
你打：def validate_email(
AI：[立即補全完整函數]
你：[Tab 接受，繼續下一個]
→ 總時間：10 秒
```

### 2.2 關鍵特性：Inline 即時補全

#### 技術原理

```
工作原理：
你正在打字
  ↓
IDE 捕捉按鍵
  ↓
送到 Copilot Server（背景處理）
  ↓
AI 預測下一段代碼
  ↓
灰色文字顯示在游標後
  ↓
你按 Tab 接受或繼續打字忽略
```

**關鍵優勢**：全程無阻塞，流暢如行雲流水。

#### 實際體驗

```javascript
// 你打：function fetchUser
// AI 立即建議：
function fetchUserById(id) {
  return fetch(`/api/users/${id}`)
    .then(response => response.json())
    .then(data => data.user)
    .catch(error => {
      console.error('Error fetching user:', error);
      throw error;
    });
}

// 你只需按 Tab 接受
```

**感受**：就像有個助手在你旁邊，你剛想到什麼，他就準備好了。

### 2.3 Context 理解機制

Copilot 雖然 context window 小（~8K tokens），但它很聰明：

#### 智慧 Context 選擇

```
你的專案結構：
/src
  /components
    - UserList.jsx
    - UserCard.jsx  ← 你正在編輯
    - Header.jsx
  /services
    - userService.js
  /utils
    - formatters.js

Copilot 的選擇策略：
1. 當前檔案（UserCard.jsx）
2. 同目錄相關檔案（UserList.jsx）
3. Import 的檔案（userService.js）
4. 最近編輯的檔案（formatters.js）

→ 雖然只有 8K，但選得很精準
```

#### 實際案例

```jsx
// 在 UserCard.jsx 中
import { formatDate } from '../utils/formatters';
import { fetchUserById } from '../services/userService';

function UserCard({ userId }) {
  // 你打：const [user
  // AI 知道你用了 fetchUserById，建議：
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUserById(userId).then(setUser);
  }, [userId]);

  // AI 知道你 import 了 formatDate，在顯示時建議：
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>Joined: {formatDate(user?.createdAt)}</p>
    </div>
  );
}
```

**結論**：雖然 context 小，但 Copilot 會"猜"你最可能需要什麼。

### 2.4 最適合的場景

#### ✅ 場景 1：CRUD 開發

```
任務：為一個 REST API 寫 5 個 CRUD endpoints

Copilot 優勢：
- 模式重複（Create, Read, Update, Delete）
- AI 學習你的第一個後，後面 4 個幾乎全自動
- 10 分鐘完成，節省 80% 時間
```

#### ✅ 場景 2：測試案例撰寫

```
任務：為每個函數寫單元測試

Copilot 優勢：
- 測試結構高度重複
- 看到你的函數簽名，立即生成對應測試
- 特別擅長生成 edge cases

範例：
你寫了：function divide(a, b) { return a / b; }

你打：describe('divide'
AI 自動建議：
describe('divide', () => {
  it('should divide two numbers', () => {
    expect(divide(10, 2)).toBe(5);
  });

  it('should handle division by zero', () => {
    expect(divide(10, 0)).toBe(Infinity);
  });

  it('should handle negative numbers', () => {
    expect(divide(-10, 2)).toBe(-5);
  });
});
```

#### ✅ 場景 3：Boilerplate 代碼

```
任務：設置 Express.js 專案結構

你打：const express = require('express');
      const app = express();

AI 自動補全：
const bodyParser = require('body-parser');
const cors = require('cors');

app.use(bodyParser.json());
app.use(cors());

app.get('/', (req, res) => {
  res.json({ message: 'API is running' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

// 這些"範本代碼" Copilot 最拿手
```

#### ✅ 場景 4：學習新語言/框架

```
情境：你熟悉 Python，正在學 Go

你打註解：// Create a HTTP server that listens on port 8080
AI 立即生成：
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}

// 你不用查文檔，AI 教你語法
```

### 2.5 侷限性

#### ❌ 限制 1：缺乏全局視野

```
問題情境：
你在寫 payment-service.js
AI 建議使用 processPayment() 函數
但這個函數在別的分支被重構了，API 改變了

結果：
- AI 不知道其他檔案的最新狀態
- 生成的代碼可能無法運行
- 需要你手動檢查和修正
```

#### ❌ 限制 2：無法做架構決策

```
你問："我應該用 MongoDB 還是 PostgreSQL？"
Copilot：[沒反應，它只能補全代碼]

你需要：
- Claude Code（深度分析 trade-offs）
- 或者自己研究
```

#### ❌ 限制 3：過度依賴會降低學習

```
危險情境：
新手開發者完全依賴 Copilot
→ AI 生成所有代碼
→ 開發者不理解原理
→ 遇到 bug 無法 debug

建議：
- 初學時少用 Copilot，先理解基礎
- 有一定基礎後，用 Copilot 加速
- 永遠要讀懂 AI 生成的代碼
```

### 2.6 最佳實踐

#### 技巧 1：寫好註解引導 AI

```python
# ❌ 模糊的註解
# calculate something

# ✅ 清晰的註解
# Calculate the total price including tax (8.5%) and shipping ($5)
def calculate_total(subtotal):
    # AI 會生成更準確的代碼
```

#### 技巧 2：建立代碼模式

```javascript
// 第一個 API endpoint 手動寫清楚
app.get('/users', async (req, res) => {
  try {
    const users = await User.findAll();
    res.json({ success: true, data: users });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// 後面的 Copilot 會學習這個模式
app.get('/posts', async (req, res) => {
  // AI 會建議完全相同的結構
});
```

#### 技巧 3：分段接受建議

```python
# 不要盲目接受整段代碼
# AI 建議：
def process_data(data):
    # [50 行複雜邏輯]

# 建議做法：
# 1. 先接受函數簽名
def process_data(data):
# 2. 手動寫第一步
    validated_data = validate(data)
# 3. 讓 AI 補全後續（它會更準確）
```

---

## Section 3: Cursor 定位

### 3.1 核心定位：平衡開發工具

Cursor 試圖在"深度"和"速度"之間找到平衡點。

#### 類比：Nano vs Vim 的中間地帶

```bash
# 編輯器光譜
nano ------------ Cursor ------------ vim
 ↑                   ↑                 ↑
簡單易學           平衡實用         強大複雜
```

Cursor 的設計哲學：

```
問題：
- Copilot 太淺（看不到多檔案）
- Claude Code 太深（學習曲線陡）

Cursor 的答案：
- Context window: 32K tokens（夠用）
- UI: VS Code fork（熟悉）
- 速度：比 Claude Code 快，比 Copilot 慢一點
→ 適合大多數日常任務
```

### 3.2 關鍵特性：多檔案編輯

#### Cursor 的獨特能力

```
你："把所有的 API endpoints 從 Express 遷移到 Fastify"

Cursor 的做法：
1. 分析所有 routes/*.js 檔案
2. 同時在多個檔案中進行替換
3. 確保語法一致性
4. 生成 diff 讓你檢視

Claude Code 的做法：
1. 深度分析整個專案（慢）
2. 制定詳細計劃（EPCV）
3. 一步步執行

Copilot 的做法：
1. 在當前檔案補全（無法跨檔案）
2. 需要你手動切換到每個檔案

→ Cursor 在"批量操作"上找到平衡
```

#### 實際案例

```
任務：重命名一個函數（被 20 個檔案使用）

Copilot：
- 需要手動在每個檔案用 Find & Replace
- 風險：可能漏掉某些使用處

Cursor：
- Cmd+K → "rename calculateTotal to computeTotal"
- AI 自動找到所有 20 個檔案並修改
- 顯示 diff 讓你確認

Claude Code：
- 會先分析依賴關係
- 確認沒有同名函數衝突
- 生成完整的重構報告
- 但時間更長（可能不必要）

→ 這種場景 Cursor 最適合
```

### 3.3 最適合的場景

#### ✅ 場景 1：中型專案開發

```
專案規模：
- 10-50 個檔案
- 5,000-20,000 行代碼
- 2-5 個開發者

為什麼選 Cursor：
- Context 夠理解整個專案
- 速度比 Claude Code 快
- 多檔案編輯功能實用

範例：
開發一個內部管理後台
├─ 前端：React (20 components)
├─ 後端：Express API (15 endpoints)
└─ 資料庫：Prisma models (10 tables)
→ Cursor 可以同時理解前後端
```

#### ✅ 場景 2：快速原型開發

```
任務：48 小時內做出 MVP

Cursor 優勢：
- 不需要深入學習（VS Code 使用者無痛切換）
- 速度夠快（不像 Claude Code 每次等 20 秒）
- Context 足夠（能理解專案全貌）

實際流程：
Day 1：搭建架構（Cursor 生成 boilerplate）
Day 2：實作功能（Cursor 跨檔案編輯）
→ 快速迭代
```

#### ✅ 場景 3：代碼遷移

```
任務：從 JavaScript 遷移到 TypeScript

Cursor 優勢：
- 一次處理多個檔案
- 保持一致性（型別定義）
- 即時預覽變更

步驟：
1. Cursor: "Convert all .js files to .ts"
2. AI 分析專案，生成遷移計劃
3. 你確認後，AI 批量轉換
4. 顯示 diff，你檢視修正
```

### 3.4 與其他工具的對比

#### vs Copilot

```
Cursor 比 Copilot 強的地方：
✓ 多檔案理解與編輯
✓ 專案級別的上下文
✓ 可以做重構任務

Copilot 比 Cursor 強的地方：
✓ 即時補全速度更快
✓ IDE 整合更深（支援更多編輯器）
✓ 成本更低（月費 vs API 計費）
```

#### vs Claude Code

```
Cursor 比 Claude Code 強的地方：
✓ 學習曲線平緩（VS Code 使用者熟悉）
✓ 速度更快（適合日常開發）
✓ UI 更直觀（視覺化操作）

Claude Code 比 Cursor 強的地方：
✓ Context 更大（200K vs 32K）
✓ 深度分析能力（EPCV 工作流）
✓ 專家模式（security-auditor, performance-optimizer）
```

### 3.5 最佳使用建議

#### 策略 1：作為日常主力工具

```
適合人群：
- VS Code 使用者
- 中小型專案開發者
- 追求平衡的開發者

工作流程：
├─ 日常開發：Cursor（主力）
├─ 重大重構：切換到 Claude Code
└─ 快速補全：搭配 Copilot（如果預算夠）
```

#### 策略 2：與 Copilot 組合使用

```
組合策略：
├─ Cursor：專案導航、多檔案編輯、重構
└─ Copilot：函數內的快速補全

實際使用：
1. 用 Cursor 打開專案，理解架構
2. 進入具體開發時，Copilot 提供即時補全
3. 需要跨檔案修改時，切回 Cursor 模式
```

---

## Section 4: 決策樹設計

### 4.1 核心問題框架

在選擇工具前，先問自己 5 個問題：

```
Question 1: 代碼規模有多大？
├─ < 1,000 行 → Copilot 優先
├─ 1,000-10,000 行 → Cursor 考慮
└─ > 10,000 行 → Claude Code 傾向

Question 2: 任務複雜度如何？
├─ 簡單重複（CRUD, 測試） → Copilot
├─ 中等邏輯（功能開發） → Cursor
└─ 高複雜度（架構, 重構） → Claude Code

Question 3: 時間有多緊迫？
├─ 緊急（< 1 小時） → Copilot（最快）
├─ 正常（1-4 小時） → Cursor（平衡）
└─ 充裕（> 4 小時） → Claude Code（深度）

Question 4: 需要多深的理解？
├─ 只需完成任務 → Copilot
├─ 理解實作細節 → Cursor
└─ 深度學習原理 → Claude Code

Question 5: 預算考量？
├─ 成本敏感 → Copilot（固定月費）
├─ 平衡 → Cursor（適中）
└─ 品質優先 → Claude Code（按用量）
```

### 4.2 決策樹（文字版）

```
START: 我有一個任務
  ↓
問題 1: 是否需要理解 > 10 個檔案？
  ├─ YES → 問題 1A: 是否需要深度分析？
  │         ├─ YES → [Claude Code]
  │         └─ NO → [Cursor]
  │
  └─ NO → 問題 2: 是否是重複性工作？
            ├─ YES → [Copilot]
            └─ NO → 問題 3: 時間是否緊迫？
                      ├─ YES → [Copilot]
                      └─ NO → [Cursor]
```

### 4.3 實際案例應用

#### 案例 1：新功能開發

```
任務：為電商網站添加"願望清單"功能

決策過程：
Q1: 代碼規模？
A1: 需要修改 5-8 個檔案（前端 + 後端）

Q2: 複雜度？
A2: 中等（需要資料庫、API、UI）

Q3: 時間？
A3: 2 天（不緊急）

Q4: 理解深度？
A4: 需要理解現有購物車邏輯

Q5: 預算？
A5: 正常專案預算

決策：[Cursor]
理由：
- 規模適中（5-8 檔案，Cursor 的 32K context 夠用）
- 需要跨檔案編輯（前端+後端）
- 時間不緊迫，不需要 Copilot 的極速
- 不需要 Claude Code 的深度分析（非重構）
```

#### 案例 2：緊急 Bug 修復

```
情境：生產環境報錯，需立即修復

決策過程：
Q1: 代碼規模？
A1: Bug 在單一函數（payment-service.js）

Q2: 複雜度？
A2: 中等（邏輯錯誤）

Q3: 時間？
A3: 緊急！30 分鐘內要上線

決策：[Copilot]
理由：
- 單檔案修改（不需要大 context）
- 時間緊迫（要最快的工具）
- 已經定位問題，只需修改邏輯

如果：
- Bug 原因不明，需要分析多個模組
→ 切換到 [Claude Code] 進行深度分析
```

#### 案例 3：大型重構專案

```
任務：重構 5 年老專案，從 Callback Hell 改成 Async/Await

決策過程：
Q1: 代碼規模？
A1: 整個專案 50+ 檔案，10 萬行代碼

Q2: 複雜度？
A2: 極高（需要確保不破壞現有功能）

Q3: 時間？
A3: 2 週（有充分時間）

Q4: 理解深度？
A4: 需要完全理解專案架構

決策：[Claude Code]
理由：
- 規模巨大（只有 200K context 能全面理解）
- 需要 EPCV 工作流（系統性重構）
- 風險高（需要深度分析避免破壞）
- 時間充裕（可以接受 Claude Code 的慢速度）
```

### 4.4 常見決策反模式

#### ❌ 反模式 1：用 Claude Code 寫簡單 CRUD

```
錯誤：
任務：寫一個 GET /users API
選擇：Claude Code

問題：
- 啟動 Claude Code 需 10 秒
- 生成代碼需 15 秒
- 總時間 25 秒

正確：
用 Copilot
- 即時補全
- 總時間 < 5 秒

結論：不要高射炮打蚊子
```

#### ❌ 反模式 2：用 Copilot 做大型重構

```
錯誤：
任務：重構 10 萬行專案的認證系統
選擇：Copilot

問題：
- Copilot 只看到當前檔案
- 可能產生 breaking changes
- 需要手動檢查 100+ 個使用點

正確：
用 Claude Code
- 理解整個認證流程
- 確保所有依賴都更新
- 生成測試覆蓋所有場景

結論：不要用小工具做大工程
```

#### ❌ 反模式 3：完全依賴單一工具

```
錯誤：
"我只用 Claude Code，所有任務都用它"

問題：
- 簡單任務浪費時間和金錢
- 沒有發揮各工具優勢

正確：
建立工具組合策略
├─ 日常開發 → Copilot
├─ 中型任務 → Cursor
└─ 重大決策 → Claude Code

結論：工具是用來搭配的，不是互斥的
```

### 4.5 工具組合策略

#### 策略 1：專案生命週期組合

```
專案階段決策圖：
├─ 架構設計 → [Claude Code]
│   "設計微服務架構"
│   需要：深度思考、trade-offs 分析
│
├─ 骨架搭建 → [Cursor]
│   "生成專案結構、boilerplate"
│   需要：多檔案生成、保持一致性
│
├─ 功能開發 → [Copilot]
│   "實作各個 API endpoints"
│   需要：快速編碼、高頻補全
│
├─ 重構優化 → [Claude Code]
│   "優化效能、改善架構"
│   需要：全局分析、深度理解
│
└─ 維護修 Bug → [Cursor]
    "定位並修復問題"
    需要：多檔案理解、適中速度
```

#### 策略 2：任務類型組合

```
按任務類型選工具：
├─ CRUD 開發 → [Copilot]
├─ API 整合 → [Cursor]
├─ 架構設計 → [Claude Code]
├─ 測試撰寫 → [Copilot]
├─ 代碼遷移 → [Cursor]
├─ 效能優化 → [Claude Code]
├─ Bug 修復 → [Cursor] 或 [Copilot]（取決於複雜度）
└─ 學習新技術 → [Claude Code]
```

#### 策略 3：預算導向組合

```
如果預算有限：
主力：Copilot ($10/月固定)
輔助：Claude Code（僅在關鍵任務使用）

策略：
├─ 80% 任務用 Copilot（日常開發）
└─ 20% 任務用 Claude Code（重要決策）

如果預算充裕：
主力：Cursor（日常開發）
輔助1：Copilot（快速補全）
輔助2：Claude Code（深度任務）

策略：
├─ 60% 任務用 Cursor（平衡工具）
├─ 30% 任務用 Copilot（快速補全）
└─ 10% 任務用 Claude Code（關鍵任務）
```

---

## 總結

### 三大工具本質對比表

| 維度 | Claude Code | Copilot | Cursor |
|------|-------------|---------|--------|
| **核心定位** | 深度思考夥伴 | 快速編碼助手 | 平衡開發工具 |
| **Context 大小** | 200K tokens | 8K tokens | 32K tokens |
| **速度** | 慢（10-30s） | 快（< 1s） | 中（2-5s） |
| **最佳場景** | 複雜重構、架構設計 | CRUD、測試、補全 | 中型專案、原型開發 |
| **學習曲線** | 陡峭（10-20h） | 平緩（1-2h） | 中等（3-5h） |
| **成本** | 按用量（高） | 月費（低） | 月費/用量（中） |
| **Linux 類比** | vim/git | alias | nano/gedit |

### 選擇工具的黃金法則

```
1. 上下文優先原則
   需要理解的檔案數 > 10 → Claude Code
   需要理解的檔案數 < 5 → Copilot
   介於中間 → Cursor

2. 速度與深度權衡
   時間緊迫 → 選速度（Copilot）
   品質關鍵 → 選深度（Claude Code）
   平衡 → 選中間（Cursor）

3. 工具組合思維
   不要只用一個工具
   根據任務階段動態切換
   發揮各工具的長處

4. 成本效益分析
   簡單任務不要用昂貴工具
   關鍵任務不要省成本
   建立合理的工具組合預算
```

### 下一步

- 閱讀 `9.2_情境驅動選擇策略.md` 深入理解 8 種典型場景
- 嘗試在真實專案中應用決策矩陣
- 建立你自己的工具選擇清單

---

**練習檢查點**

完成閱讀後，回答以下問題：

1. 用 Linux 編輯器類比解釋三大工具的定位
2. 說明 Claude Code 的 200K context 在什麼場景下是必需的
3. 描述一個 Copilot 比 Claude Code 更適合的場景
4. 設計一個你日常工作的工具組合策略

---

**檔案資訊**
- 字數：~9,800 字
- 閱讀時間：20 分鐘
- 最後更新：2025-10-30
