# C02: 混合場景下的工具切換

## 情境描述

你是一家中型 SaaS 公司的全端工程師，接到一個新需求：為現有的用戶管理系統添加「多因素認證（MFA）」功能。

### 專案背景

- **代碼規模**：主應用 ~30,000 行 Python (Django)
- **時間限制**：2 週 Sprint
- **團隊規模**：你是主要開發者，有 1 位 code reviewer
- **技術棧**：Django REST + React + PostgreSQL

### 完整開發流程

你需要完成以下階段：

```
Week 1:
├─ Day 1-2: 需求分析與架構設計
│   ├─ 理解現有認證系統
│   ├─ 設計 MFA 資料模型
│   ├─ 規劃 API 介面
│   └─ 撰寫技術設計文件
│
├─ Day 3-4: 後端開發
│   ├─ 實作 MFA 模型 (Django ORM)
│   ├─ 實作 TOTP 驗證邏輯
│   ├─ 開發 REST API endpoints
│   └─ 撰寫單元測試
│
└─ Day 5: 前端開發
    ├─ 設計 MFA 設定 UI
    ├─ 實作 QR code 掃描流程
    └─ 整合後端 API

Week 2:
├─ Day 6-7: 整合測試與調試
│   ├─ E2E 測試
│   ├─ 修復 bugs
│   └─ 跨瀏覽器測試
│
├─ Day 8-9: 重構與優化
│   ├─ 代碼審查反饋
│   ├─ 效能優化
│   └─ 安全性加固
│
└─ Day 10: 文檔與部署準備
    ├─ 撰寫 API 文檔
    ├─ 更新用戶指南
    └─ 準備 migration scripts
```

---

## 任務說明

為這個完整的開發流程設計**工具切換策略**：

1. **規劃工具使用**：
   - 每個階段應該用哪個 AI 工具？
   - 為什麼在這個階段選擇這個工具？

2. **定義切換時機**：
   - 何時從 A 工具切換到 B 工具？
   - 切換的觸發條件是什麼？

3. **考慮 trade-offs**：
   - 某些階段是否可以混合使用多個工具？
   - 如何平衡速度與深度？

---

## 考察重點

- ✅ 理解不同開發階段的特徵
- ✅ 根據任務特性動態選擇工具
- ✅ 掌握工具切換的時機判斷
- ✅ 平衡效率與代碼質量

---

## 思考時間 ⏱️

請花 **5-10 分鐘** 思考：

```
你的工具切換策略：

Day 1-2 (架構設計): _______________
理由: _______________

Day 3-4 (後端開發): _______________
理由: _______________

Day 5 (前端開發): _______________
理由: _______________

Day 6-7 (測試調試): _______________
理由: _______________

Day 8-9 (重構優化): _______________
理由: _______________

Day 10 (文檔準備): _______________
理由: _______________
```

---

## 參考解答

### 完整工具切換策略

#### 🔍 Phase 1: 需求分析與架構設計 (Day 1-2)

**推薦工具**: **Claude Code** 🥇

**決策理由**：

1. **需要全局視野**：
   - 必須理解現有的 30,000 行代碼
   - 需要找到現有認證系統的實作位置
   - 要分析與 MFA 相關的所有依賴

2. **深度思考任務**：
   - 設計資料模型需要考慮兼容性
   - API 介面設計需要符合現有風格
   - 需要評估對現有系統的影響

3. **關鍵命令**：
   ```bash
   # 探索現有認證系統
   /glob **/auth*.py
   /read path/to/auth/views.py

   # 分析資料庫模型
   /grep "class.*User.*Model" --type python

   # 規劃架構
   /ask "如何設計 MFA 模型才能與現有 User 模型解耦？"
   ```

**為什麼不選其他工具？**
- ❌ Copilot：看不到全局，可能設計出與現有架構衝突的方案
- ❌ Cursor：雖然能看多檔案，但上下文深度不足以理解複雜架構

---

#### 💻 Phase 2: 後端開發 - 模型實作 (Day 3, 上午)

**推薦工具**: **Claude Code** 🥇

**決策理由**：

1. **需要理解 ORM 關係**：
   - MFA 模型需要與 User 建立關聯
   - 要考慮 migration 對現有資料的影響

2. **業務邏輯複雜**：
   - TOTP 驗證邏輯需要正確實作
   - 備用碼生成需要安全考量

3. **關鍵操作**：
   ```python
   # Claude Code 可以幫助設計
   # 考慮了現有架構的模型

   class MFADevice(models.Model):
       user = models.ForeignKey(
           settings.AUTH_USER_MODEL,
           on_delete=models.CASCADE,
           related_name='mfa_devices'
       )
       device_type = models.CharField(...)
       secret_key = models.CharField(...)  # 加密存儲
       is_verified = models.BooleanField(default=False)
       created_at = models.DateTimeField(auto_now_add=True)
   ```

**工具切換時機**：模型設計完成後 → 切換到 Copilot

---

#### ⚡ Phase 2: 後端開發 - API 實作 (Day 3 下午 - Day 4)

**推薦工具**: **GitHub Copilot** 🥇

**決策理由**：

1. **重複性工作**：
   - REST API endpoints 遵循固定模式
   - 序列化器（Serializers）結構標準化
   - 視圖（Views）代碼相對固定

2. **速度優先**：
   - 大量 CRUD 操作需要快速完成
   - Copilot 的 inline 補全最高效

3. **典型代碼示例**：
   ```python
   # Copilot 擅長補全這類標準化代碼

   class MFADeviceViewSet(viewsets.ModelViewSet):
       """
       API endpoint for MFA device management.
       """
       serializer_class = MFADeviceSerializer
       permission_classes = [IsAuthenticated]

       def get_queryset(self):
           # Copilot 會自動補全
           return MFADevice.objects.filter(user=self.request.user)

       def create(self, request, *args, **kwargs):
           # Copilot 會根據 Django REST 模式補全
           ...
   ```

4. **單元測試撰寫**：
   ```python
   # Copilot 極擅長生成測試代碼

   class MFADeviceTestCase(TestCase):
       def setUp(self):
           self.user = User.objects.create_user(...)

       def test_create_mfa_device(self):
           # Copilot 自動補全測試邏輯
           ...
   ```

**為什麼此時不用 Claude Code？**
- API 實作已經確定架構，不需要深度思考
- Copilot 的速度優勢在此階段最明顯

---

#### 🎨 Phase 3: 前端開發 (Day 5)

**推薦工具**: **Cursor** 🥇（或 Copilot）

**決策理由**：

1. **前端開發特性**：
   - 需要頻繁在多個檔案間切換（組件、樣式、邏輯）
   - 視覺化即時預覽重要
   - Cursor 的 IDE 整合更友善

2. **混合使用策略**：
   ```
   Cursor: 用於組件架構和複雜邏輯
   Copilot: 用於樣式和簡單補全
   ```

3. **典型工作流**：
   ```jsx
   // MFASetupModal.jsx - 使用 Cursor
   import React, { useState } from 'react';
   import { QRCodeSVG } from 'qrcode.react';

   const MFASetupModal = ({ onClose }) => {
     const [secret, setSecret] = useState('');

     // Cursor 可以幫助快速搭建組件結構
     // Copilot 補全具體實作細節

     return (
       <Modal>
         <QRCodeSVG value={secret} />
         {/* ... */}
       </Modal>
     );
   };
   ```

**為什麼不用 Claude Code？**
- 前端組件通常獨立性較高，不需要大量全局上下文
- Cursor/Copilot 的即時反饋更適合快速開發

---

#### 🐛 Phase 4: 整合測試與調試 (Day 6-7)

**推薦工具**: **Cursor** 🥇

**決策理由**：

1. **需要靈活性**：
   - Bug 可能出現在前後端任何地方
   - 需要快速在多個檔案間跳轉
   - Cursor 的多檔案編輯能力強

2. **調試場景**：
   ```
   發現問題：前端呼叫 API 失敗
   ├─ 檢查前端請求代碼 (React)
   ├─ 檢查後端 API 邏輯 (Django)
   ├─ 檢查序列化器驗證邏輯
   └─ 檢查資料庫查詢

   Cursor 可以同時開啟這些檔案並快速定位問題
   ```

3. **E2E 測試撰寫**：
   - Copilot 在 Cursor 中運作
   - 利用兩者的優勢

**切換時機**：
- 如果發現架構性問題 → 切換到 Claude Code
- 如果只是簡單 bug 修復 → 繼續用 Cursor

---

#### 🔧 Phase 5: 重構與優化 (Day 8-9)

**推薦工具**: **Claude Code** 🥇

**決策理由**：

1. **需要全局視野**：
   - Code review 反饋可能涉及多個模組
   - 效能優化需要理解請求鏈路
   - 安全性加固需要全面審查

2. **深度分析任務**：
   ```bash
   # 使用 Claude Code 進行深度審查

   /ask "分析 MFA 驗證流程是否存在 timing attack 風險"
   /ask "這段 TOTP 驗證邏輯有沒有安全漏洞？"
   /ask "如何優化資料庫查詢減少 N+1 問題？"
   ```

3. **重構場景**：
   - 提取重複邏輯到 utility functions
   - 優化資料庫查詢
   - 加入快取機制

**關鍵優勢**：
- Claude Code 能看到所有相關代碼
- 能提供全面的安全性建議
- 重構建議考慮整體架構

---

#### 📝 Phase 6: 文檔與部署準備 (Day 10)

**推薦工具**: **Copilot** 🥇（或 Cursor）

**決策理由**：

1. **文檔撰寫快速**：
   - API 文檔格式固定
   - Copilot 擅長生成文檔

2. **示例代碼生成**：
   ```markdown
   ## MFA 啟用 API

   **Endpoint**: `POST /api/v1/mfa/devices/`

   **Request**:
   ```json
   {
     "device_type": "totp",
     "device_name": "My Phone"
   }
   ```

   **Response**:
   ```json
   {
     "id": 1,
     "secret_key": "BASE32SECRET",
     "qr_code_url": "otpauth://..."
   }
   ```
   ```

3. **Migration scripts**：
   - 通常是標準化的 Django 操作
   - Copilot 可以快速生成

---

### 工具切換總結表

| 階段 | 工具 | 核心原因 | 時長佔比 |
|------|------|---------|---------|
| 架構設計 | Claude Code | 全局視野 + 深度思考 | 20% |
| 模型實作 | Claude Code | 業務邏輯複雜 | 10% |
| API 實作 | Copilot | 重複性工作 + 速度優先 | 25% |
| 前端開發 | Cursor | 多檔案編輯 + 視覺化 | 20% |
| 測試調試 | Cursor | 靈活性 + 跨檔案 | 15% |
| 重構優化 | Claude Code | 全局審查 + 安全性 | 8% |
| 文檔準備 | Copilot | 文檔生成快速 | 2% |

---

## 關鍵學習點

### 1. 工具切換的觸發條件

```
何時切換到 Claude Code？
├─ 需要理解 > 5 個相關檔案
├─ 遇到架構性問題
├─ 需要安全性審查
└─ 進行全局重構

何時切換到 Copilot？
├─ 重複性代碼（CRUD, 測試）
├─ 標準化實作（序列化器、API）
├─ 文檔撰寫
└─ 時間壓力大

何時切換到 Cursor？
├─ 跨多個檔案調試
├─ 前端開發
├─ 快速原型
└─ 日常功能開發
```

### 2. 混合使用策略

不是每個階段只能用一個工具：

```
前端開發階段：
├─ Cursor: 主要開發環境
└─ Copilot (在 Cursor 中): 代碼補全

測試階段：
├─ Cursor: 快速修復簡單 bug
└─ 備用 Claude Code: 遇到複雜問題時切換
```

### 3. 時間管理

```
總時間: 10 天

Claude Code 使用時間: ~3 天 (30%)
├─ 前期設計: 2 天
└─ 後期優化: 1 天

Copilot 使用時間: ~3 天 (30%)
├─ 後端開發: 2 天
└─ 文檔撰寫: 0.5 天
└─ 測試撰寫: 0.5 天

Cursor 使用時間: ~4 天 (40%)
├─ 前端開發: 1 天
├─ 測試調試: 1.5 天
└─ 雜項開發: 1.5 天
```

---

## 延伸思考

### 問題 1：如果只能選一個工具？

**情境**：你的公司只允許使用一個 AI 工具

**分析**：
```
選擇 Claude Code：
✅ 能完成所有任務
❌ 簡單任務效率較低
→ 總開發時間: +20%

選擇 Copilot：
✅ 日常開發極快
❌ 架構設計吃力
❌ 全局重構困難
→ 總開發時間: +35%

選擇 Cursor：
✅ 平衡各方面
❌ 沒有明顯優勢
→ 總開發時間: +25%

結論：如果只能選一個 → Claude Code
但效率不如混合使用
```

### 問題 2：如果時間減半？

**情境**：Sprint 從 2 週縮短為 1 週

**調整策略**：
```
原策略（2 週）：
├─ Claude Code (前期 + 後期)
├─ Copilot (中期)
└─ Cursor (測試)

緊急策略（1 週）：
├─ Day 1: Claude Code（快速架構設計）
├─ Day 2-4: 全部用 Copilot（犧牲深度換速度）
├─ Day 5: Cursor（快速測試）
└─ 跳過深度重構（技術債）

Trade-offs：
✅ 能按時交付
❌ 代碼質量下降
❌ 可能埋下安全隱患
```

### 問題 3：團隊協作場景

**情境**：3 位工程師並行開發

**工具分配**：
```
工程師 A（架構負責人）:
└─ 全程使用 Claude Code（負責架構和 code review）

工程師 B（後端開發）:
├─ Day 1-2: Claude Code（理解架構）
└─ Day 3-7: Copilot（快速實作）

工程師 C（前端開發）:
└─ 全程使用 Cursor（前端開發最佳選擇）

關鍵：工具選擇與角色職責匹配
```

---

## 自我檢核

完成這個情境後，檢查你是否能夠：

- [ ] 根據開發階段特性選擇工具
- [ ] 識別工具切換的觸發條件
- [ ] 理解混合使用多個工具的策略
- [ ] 根據時間壓力調整工具組合
- [ ] 在團隊協作中合理分配工具

---

## 實戰建議

### 建立你的切換清單

```
我的專案：_______________

架構設計階段 → [工具]
理由：_______________

快速開發階段 → [工具]
理由：_______________

測試調試階段 → [工具]
理由：_______________

重構優化階段 → [工具]
理由：_______________
```

### 記憶卡建議

**正面**：
```
場景：完整功能開發（2 週 Sprint）
階段：架構設計 → 開發 → 測試 → 重構
```

**背面**：
```
Claude Code（前後期深度）
├─ 架構設計（全局視野）
└─ 重構優化（安全審查）

Copilot（中期速度）
└─ API/測試實作（重複性工作）

Cursor（測試期靈活）
└─ 調試與前端（多檔案編輯）

關鍵：根據任務特性動態切換
```

---

**難度**: ★★☆ 組合級
**預估思考時間**: 10-15 分鐘
**關鍵能力**: 動態工具切換決策
