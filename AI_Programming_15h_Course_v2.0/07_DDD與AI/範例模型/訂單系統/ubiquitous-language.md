# 訂單系統 - 通用語言詞彙表

## 📋 文件說明

本文件定義訂單系統領域的通用語言（Ubiquitous Language），是開發團隊與業務專家溝通的共同語言。

**重要原則**：
- 使用業務術語，而非技術術語
- 所有團隊成員（業務、開發、測試）都使用相同詞彙
- 程式碼中的類名、方法名應與此詞彙表一致

---

## 🎯 限界上下文（Bounded Context）

### 訂單上下文（Order Context）

負責處理訂單的完整生命週期，從訂單創建到訂單完成或取消。

**職責範圍**：
- 訂單創建與驗證
- 訂單項目管理
- 訂單狀態變更
- 訂單金額計算

**與其他上下文的關係**：
- 依賴「庫存上下文」檢查商品可用性
- 依賴「支付上下文」處理支付
- 依賴「配送上下文」安排物流
- 依賴「用戶上下文」獲取用戶信息

---

## 📦 核心概念

### 1. 聚合根（Aggregate Root）

#### Order（訂單）
**定義**：客戶購買商品的意願記錄，包含購買的商品、數量、金額等信息。

**唯一標識**：OrderId（訂單編號）

**生命週期狀態**：
- `PENDING` - 待支付：訂單已創建，等待支付
- `PAID` - 已支付：支付完成，等待發貨
- `SHIPPED` - 已發貨：商品已發出
- `DELIVERED` - 已送達：商品已送達客戶
- `COMPLETED` - 已完成：訂單交易完成
- `CANCELLED` - 已取消：訂單已取消
- `REFUNDED` - 已退款：訂單已退款

**業務規則**：
- 訂單一旦支付成功，不可直接刪除（只能取消/退款）
- 訂單總金額 = Σ(訂單項單價 × 數量) - 折扣 + 運費
- 訂單只能由「待支付」狀態變更為「已支付」或「已取消」
- 已發貨的訂單不能取消，只能退貨

**不變式（Invariants）**：
- 訂單至少包含一個訂單項
- 訂單總金額必須 > 0
- 訂單狀態變更必須遵循狀態機規則

---

### 2. 實體（Entity）

#### OrderItem（訂單項）
**定義**：訂單中的單個商品項目，記錄商品ID、數量、單價等。

**唯一標識**：OrderItemId

**屬性**：
- `productId`：商品ID（引用商品上下文）
- `productName`：商品名稱（快照，避免跨上下文查詢）
- `quantity`：購買數量
- `unitPrice`：單價（下單時的價格快照）
- `subtotal`：小計（quantity × unitPrice）

**業務規則**：
- 數量必須 > 0
- 單價必須 > 0
- 小計 = 數量 × 單價

**為什麼是實體而非值對象？**
- 訂單項有唯一標識（OrderItemId）
- 即使兩個訂單項的商品、數量、單價都相同，它們仍是不同的訂單項
- 訂單項可以單獨修改數量或刪除

---

### 3. 值對象（Value Object）

#### Money（金額）
**定義**：表示貨幣金額，包含數值和幣種。

**屬性**：
- `amount`：金額數值（Decimal）
- `currency`：幣種（如 USD, TWD, CNY）

**業務規則**：
- 金額必須 >= 0
- 相同幣種才能進行加減運算
- 金額計算保留小數點後2位

**為什麼是值對象？**
- 100 TWD 就是 100 TWD，沒有唯一標識
- 兩個屬性完全相同的 Money 是可互換的
- 值對象是不可變的（immutable）

#### Address（地址）
**定義**：配送地址信息。

**屬性**：
- `country`：國家
- `province`：省份/州
- `city`：城市
- `district`：區域
- `street`：街道地址
- `postalCode`：郵政編碼
- `recipientName`：收件人姓名
- `recipientPhone`：收件人電話

**業務規則**：
- 所有字段都必填
- 電話號碼格式需驗證

**為什麼是值對象？**
- 兩個完全相同的地址沒有區別
- 地址是不可變的（修改地址 = 創建新地址）

#### OrderId（訂單編號）
**定義**：訂單的唯一標識符。

**格式**：`ORD-{年月日}-{隨機碼}`
- 例如：`ORD-20251101-A3F7B2`

**業務規則**：
- 全局唯一
- 不可變
- 可讀性高（方便客戶服務查詢）

---

### 4. 領域事件（Domain Event）

#### OrderCreated（訂單已創建）
**觸發時機**：新訂單創建成功時

**事件數據**：
- `orderId`：訂單ID
- `customerId`：客戶ID
- `totalAmount`：訂單總金額
- `orderItems`：訂單項列表
- `createdAt`：創建時間

**訂閱者**：
- 庫存上下文：預留庫存
- 通知上下文：發送訂單創建通知給客戶

---

#### OrderPaid（訂單已支付）
**觸發時機**：訂單支付成功時

**事件數據**：
- `orderId`：訂單ID
- `paymentId`：支付ID
- `paidAmount`：支付金額
- `paidAt`：支付時間

**訂閱者**：
- 庫存上下文：確認扣減庫存
- 配送上下文：創建配送任務
- 通知上下文：發送支付成功通知

---

#### OrderCancelled（訂單已取消）
**觸發時機**：訂單被取消時

**事件數據**：
- `orderId`：訂單ID
- `cancellationReason`：取消原因
- `cancelledBy`：取消操作人（客戶/客服）
- `cancelledAt`：取消時間

**訂閱者**：
- 庫存上下文：釋放預留庫存
- 支付上下文：觸發退款流程（如已支付）
- 通知上下文：發送取消通知

---

#### OrderShipped（訂單已發貨）
**觸發時機**：訂單發貨時

**事件數據**：
- `orderId`：訂單ID
- `trackingNumber`：物流追蹤號
- `carrier`：物流公司
- `shippedAt`：發貨時間

**訂閱者**：
- 通知上下文：發送發貨通知給客戶

---

#### OrderCompleted（訂單已完成）
**觸發時機**：訂單交易完成時（客戶確認收貨或超過確認期限）

**事件數據**：
- `orderId`：訂單ID
- `completedAt`：完成時間

**訂閱者**：
- 用戶上下文：增加用戶積分
- 評價上下文：觸發評價提醒

---

### 5. 命令（Command）

#### CreateOrder（創建訂單）
**場景**：客戶下單時

**輸入參數**：
- `customerId`：客戶ID
- `items`：商品項列表（productId, quantity）
- `shippingAddress`：配送地址
- `paymentMethod`：支付方式

**前置條件**：
- 客戶必須已登入
- 所有商品必須有庫存
- 配送地址必須有效

**結果**：
- 成功：返回 OrderId，發送 OrderCreated 事件
- 失敗：拋出異常（庫存不足、地址無效等）

---

#### PayOrder（支付訂單）
**場景**：客戶支付訂單時

**輸入參數**：
- `orderId`：訂單ID
- `paymentId`：支付ID（來自支付上下文）

**前置條件**：
- 訂單狀態必須是「待支付」
- 支付金額必須與訂單總金額一致

**結果**：
- 成功：訂單狀態變更為「已支付」，發送 OrderPaid 事件
- 失敗：拋出異常

---

#### CancelOrder（取消訂單）
**場景**：客戶或客服取消訂單時

**輸入參數**：
- `orderId`：訂單ID
- `reason`：取消原因
- `cancelledBy`：取消操作人

**前置條件**：
- 訂單狀態必須是「待支付」或「已支付」
- 如果已支付，必須尚未發貨

**結果**：
- 成功：訂單狀態變更為「已取消」，發送 OrderCancelled 事件
- 失敗：拋出異常（訂單已發貨無法取消）

---

#### ShipOrder（發貨訂單）
**場景**：倉庫發貨時

**輸入參數**：
- `orderId`：訂單ID
- `trackingNumber`：物流追蹤號
- `carrier`：物流公司

**前置條件**：
- 訂單狀態必須是「已支付」

**結果**：
- 成功：訂單狀態變更為「已發貨」，發送 OrderShipped 事件
- 失敗：拋出異常

---

#### CompleteOrder（完成訂單）
**場景**：客戶確認收貨或系統自動確認時

**輸入參數**：
- `orderId`：訂單ID

**前置條件**：
- 訂單狀態必須是「已送達」

**結果**：
- 成功：訂單狀態變更為「已完成」，發送 OrderCompleted 事件
- 失敗：拋出異常

---

### 6. 領域服務（Domain Service）

#### OrderPricingService（訂單定價服務）
**職責**：計算訂單總金額（含折扣、運費等複雜邏輯）

**為什麼需要領域服務？**
- 定價邏輯可能涉及多個聚合（訂單、促銷、會員等級）
- 定價規則複雜，不適合放在訂單聚合內

**方法**：
- `calculateOrderTotal(order, promotions, memberLevel)`：計算訂單總金額

---

#### OrderValidationService（訂單驗證服務）
**職責**：驗證訂單創建的各項規則

**為什麼需要領域服務？**
- 需要調用庫存上下文驗證庫存
- 需要調用商品上下文驗證商品狀態
- 驗證邏輯跨越多個上下文

**方法**：
- `validateOrderCreation(items, address)`：驗證訂單創建
- `checkInventoryAvailability(items)`：檢查庫存可用性

---

## 📊 業務規則與約束

### 訂單狀態機

```
PENDING (待支付)
    ├─> PAID (已支付) [PayOrder]
    └─> CANCELLED (已取消) [CancelOrder]

PAID (已支付)
    ├─> SHIPPED (已發貨) [ShipOrder]
    ├─> CANCELLED (已取消) [CancelOrder, 僅在未發貨前]
    └─> REFUNDED (已退款) [RefundOrder]

SHIPPED (已發貨)
    └─> DELIVERED (已送達) [系統自動或物流回調]

DELIVERED (已送達)
    ├─> COMPLETED (已完成) [CompleteOrder 或自動確認]
    └─> REFUNDED (已退款) [客戶申請退貨]

COMPLETED (已完成) [終態]
CANCELLED (已取消) [終態]
REFUNDED (已退款) [終態]
```

### 重要業務約束

1. **訂單一致性**
   - 訂單項的總和必須等於訂單總金額
   - 訂單一旦創建，訂單項不可修改（只能取消重新下單）

2. **庫存一致性**
   - 訂單創建時預留庫存
   - 訂單支付時確認扣減庫存
   - 訂單取消時釋放預留庫存

3. **支付一致性**
   - 訂單支付金額必須與訂單總金額一致
   - 一個訂單只能有一個成功的支付記錄

4. **時間約束**
   - 待支付訂單超過 30 分鐘自動取消
   - 已送達訂單 7 天後自動確認收貨

---

## 🔗 與其他上下文的集成

### 庫存上下文（Inventory Context）

**依賴關係**：訂單上下文 → 庫存上下文（下游）

**集成點**：
- 訂單創建時：調用庫存上下文的 `ReserveInventory` 命令
- 訂單支付時：發送 `OrderPaid` 事件，庫存上下文監聽並扣減庫存
- 訂單取消時：發送 `OrderCancelled` 事件，庫存上下文監聽並釋放庫存

---

### 支付上下文（Payment Context）

**依賴關係**：訂單上下文 → 支付上下文（下游）

**集成點**：
- 訂單支付時：等待支付上下文的 `PaymentCompleted` 事件
- 訂單退款時：調用支付上下文的 `RefundPayment` 命令

---

### 配送上下文（Shipping Context）

**依賴關係**：訂單上下文 → 配送上下文（上游）

**集成點**：
- 訂單支付後：發送 `OrderPaid` 事件，配送上下文監聽並創建配送任務
- 接收配送上下文的 `ShipmentDispatched` 事件，更新訂單為「已發貨」

---

### 用戶上下文（User Context）

**依賴關係**：訂單上下文 → 用戶上下文（下游）

**集成點**：
- 訂單創建時：獲取用戶信息（姓名、會員等級等）
- 訂單完成時：發送 `OrderCompleted` 事件，用戶上下文監聽並增加積分

---

## 💡 常見問題

### Q1：為什麼訂單項是實體而不是值對象？

**A**：雖然訂單項的屬性簡單，但它有以下特徵：
- 有唯一標識（OrderItemId）
- 可以單獨修改數量
- 刪除某個訂單項時，需要精確定位

這些特徵符合實體的定義。

---

### Q2：為什麼要在訂單中保存商品名稱快照？

**A**：避免跨上下文查詢。

**不好的設計**：
```python
# 每次顯示訂單都要查商品服務
order.items[0].product_name  # 需要從商品上下文查詢
```

**好的設計**：
```python
# 下單時保存商品名稱快照
order.items[0].product_name  # 直接從訂單獲取，不依賴商品上下文
```

**原因**：
- 商品可能下架或改名，但訂單應該保持歷史記錄
- 減少跨上下文依賴
- 提升查詢性能

---

### Q3：訂單總金額應該存儲還是計算？

**A**：**應該存儲**，而不是每次計算。

**原因**：
- 價格可能變動（促銷結束、會員等級變化）
- 訂單總金額是下單時的快照，不應受後續變化影響
- 避免計算錯誤導致對帳問題

**實現方式**：
```python
class Order:
    def __init__(self, items, pricing_service):
        self.items = items
        # 在創建時計算並存儲
        self.total_amount = pricing_service.calculate_total(items)

    # 不提供重新計算方法，保持不變性
```

---

### Q4：訂單應該包含客戶信息嗎？

**A**：只保存客戶ID（引用），不保存完整客戶信息。

**原因**：
- 客戶屬於「用戶上下文」，不屬於「訂單上下文」
- 避免數據冗餘和一致性問題
- 如果需要客戶詳細信息，通過客戶ID查詢用戶上下文

**例外**：可以保存部分快照信息（如收貨人姓名、電話）方便訂單處理。

---

## 📚 參考資料

- Eric Evans《領域驅動設計》第 2-4 章（通用語言、限界上下文、聚合）
- Vaughn Vernon《實作領域驅動設計》第 5-7 章（實體、值對象、領域事件）
- Martin Fowler 的 Ubiquitous Language 文章

---

**版本**：v1.0
**最後更新**：2025-11-01
**適用範圍**：訂單上下文（Order Context）
