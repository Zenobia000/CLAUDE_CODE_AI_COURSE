# 7.1 DDD 核心概念速覽

## 📋 本章概述

**學習時長**：20 分鐘

**學習目標**：
- 理解 DDD 是什麼，解決什麼問題
- 掌握 5 個核心概念
- 知道 DDD 的適用場景
- 建立領域建模的思維方式

**核心理念**：
> DDD 不是技術框架，而是一種思維方式。
> 它讓程式碼與業務語言保持一致，降低溝通成本，提升維護性。

---

## 🎯 DDD 是什麼？一個比喻說清楚

### 比喻：建造城市 vs 建造軟體

**傳統軟體開發（像臨時搭建的帳篷城）**：
```
產品經理：「我們需要一個訂單功能」
工程師：     建了一個 Order 類
產品經理：「需要支援取消訂單」
工程師：     加了一個 cancel() 方法
產品經理：「取消後要退款」
工程師：     再加一個 refund() 方法
產品經理：「部分退款怎麼辦？」
工程師：     改 refund(amount) ...

結果：程式碼變成補丁堆疊，沒人敢改
```

**DDD 軟體開發（像規劃的現代城市）**：
```
第 1 步：建立通用語言（城市規劃）
├─ 訂單有哪些狀態？（待支付、已支付、已發貨...）
├─ 什麼叫「取消」？（不同狀態下取消的意義不同）
└─ 退款規則是什麼？（全額、部分、手續費...）

第 2 步：劃分限界上下文（城市分區）
├─ 訂單上下文（Order Context）
├─ 支付上下文（Payment Context）
└─ 物流上下文（Shipping Context）

第 3 步：設計聚合（社區管理）
└─ 訂單聚合（Order Aggregate）
    ├─ 訂單根（Order Root）
    ├─ 訂單項（Order Items）
    └─ 業務規則封裝

結果：程式碼結構清晰，業務邏輯集中，易於維護
```

**關鍵差異**：
| 傳統開發 | DDD 開發 |
|---------|---------|
| 技術驅動（先想資料表） | 業務驅動（先理解領域）|
| 程式碼與業務語言脫節 | 程式碼就是通用語言 |
| 貧血模型（只有 getter/setter） | 充血模型（封裝業務邏輯）|
| 修改牽一髮動全身 | 變更隔離在限界上下文內 |

---

## 🧩 核心概念 1：通用語言（Ubiquitous Language）

### 問題：業務與技術的語言鴻溝

**常見場景**：
```
產品經理：「用戶下單後，如果 30 分鐘內未支付，訂單要自動關閉」

工程師（心裡）：
- 「下單」= insert into orders
- 「未支付」= status = 0
- 「自動關閉」= 寫個定時任務，把 status 改成 -1

程式碼：
def close_expired_orders():
    expired = db.query("SELECT * FROM orders WHERE status=0 AND created_at < NOW() - INTERVAL 30 MINUTE")
    for order in expired:
        order.status = -1
        db.save(order)
```

**問題**：
- 業務說「關閉訂單」，程式碼是 `status = -1`
- 業務說「未支付」，程式碼是 `status = 0`
- **3 個月後，沒人記得 -1 和 0 是什麼意思**

### 解決方案：通用語言

**DDD 版本**：
```python
# 通用語言：程式碼與業務術語一致
class OrderStatus(Enum):
    PENDING_PAYMENT = "pending_payment"  # 待支付
    PAID = "paid"                        # 已支付
    CLOSED = "closed"                    # 已關閉
    CANCELLED = "cancelled"              # 已取消

class Order:
    def close_if_payment_timeout(self, timeout_minutes: int = 30):
        """關閉超時未支付的訂單（業務語言）"""
        if self.status == OrderStatus.PENDING_PAYMENT:
            if self.is_payment_timeout(timeout_minutes):
                self.close(reason="payment_timeout")

    def close(self, reason: str):
        """關閉訂單（封裝業務邏輯）"""
        if self.status not in [OrderStatus.PENDING_PAYMENT, OrderStatus.PAID]:
            raise InvalidOrderStateError(f"無法關閉 {self.status} 狀態的訂單")

        self.status = OrderStatus.CLOSED
        self.closed_at = datetime.now()
        self.close_reason = reason
        self.emit_event(OrderClosedEvent(self.id, reason))
```

**關鍵要點**：
1. **程式碼即文檔**：看程式碼就知道業務規則
2. **一致性**：業務討論的術語 = 程式碼的命名
3. **避免翻譯**：不需要在業務語言與技術語言之間轉換

### Linux 類比

**通用語言就像 Linux 命令約定**：
```bash
# 好的命名（通用語言）
ls          # list（列出）
cp          # copy（複製）
rm          # remove（移除）

# 糟糕的命名（如果沒有通用語言）
sc          # show contents？search？
dp          # delete permanently？duplicate？
```

每個人都知道 `ls` 是列出檔案，因為這是整個 Unix/Linux 世界的**通用語言**。

---

## 🏛️ 核心概念 2：限界上下文（Bounded Context）

### 問題：同一個詞，不同的意義

**例子：「用戶」在不同上下文的意義**

```
在「身份認證上下文」：
用戶 = {
    用戶名，密碼，郵箱，手機號
    登入狀態，JWT Token
}

在「訂單上下文」：
用戶 = {
    用戶 ID，收貨地址，訂單歷史
    會員等級，積分
}

在「客服上下文」：
用戶 = {
    用戶 ID，聯絡方式，服務記錄
    投訴歷史，滿意度評分
}
```

**如果全部混在一起**：
```python
# 上帝類別（God Class）- 災難的開始
class User:
    # 身份認證相關
    username: str
    password_hash: str
    jwt_token: str

    # 訂單相關
    shipping_addresses: List[Address]
    member_level: str
    points: int

    # 客服相關
    service_records: List[ServiceRecord]
    complaint_history: List[Complaint]
    satisfaction_score: float

    # ... 還有 50 個屬性

# 結果：任何修改都可能影響所有功能
```

### 解決方案：限界上下文

**劃分上下文邊界**：

```python
# 身份認證上下文（Authentication Context）
class AuthUser:
    user_id: UUID
    username: str
    password_hash: str
    email: Email
    phone: PhoneNumber

    def authenticate(self, password: str) -> bool: ...
    def change_password(self, old: str, new: str): ...

# 訂單上下文（Order Context）
class Customer:  # 注意：這裡叫 Customer，不叫 User
    customer_id: UUID  # 對應 AuthUser.user_id
    shipping_addresses: List[Address]
    member_level: MemberLevel

    def place_order(self, items: List[OrderItem]): ...
    def get_discount_rate(self) -> Decimal: ...

# 客服上下文（Customer Service Context）
class ServiceClient:  # 又是不同的命名
    client_id: UUID
    contact_info: ContactInfo
    service_history: List[ServiceRecord]

    def create_ticket(self, issue: str): ...
    def rate_service(self, score: int): ...
```

**關鍵要點**：
1. **邊界清晰**：每個上下文獨立演化
2. **術語隔離**：同一個概念在不同上下文有不同表達
3. **降低耦合**：修改一個上下文不影響其他

### 限界上下文與微服務

**限界上下文是邏輯邊界，微服務是物理邊界**：

```
限界上下文（設計階段）:
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│ 身份認證上下文   │  │  訂單上下文      │  │  客服上下文      │
│                 │  │                 │  │                 │
│ - AuthUser      │  │ - Customer      │  │ - ServiceClient │
│ - authenticate  │  │ - place_order   │  │ - create_ticket │
└─────────────────┘  └─────────────────┘  └─────────────────┘

微服務（部署階段）:
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│ Auth Service    │  │ Order Service   │  │ Support Service │
│   :8001         │  │   :8002         │  │   :8003         │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

**DDD 幫助你正確劃分微服務邊界**，而不是隨意拆分導致分散式單體。

---

## 🎲 核心概念 3：聚合（Aggregate）

### 問題：資料一致性的邊界

**場景：訂單與訂單項**

```python
# 錯誤做法：直接修改訂單項
order = db.get_order(order_id)
order_item = db.get_order_item(item_id)

# 危險：繞過訂單邏輯直接改訂單項
order_item.quantity = 10
order_item.price = 999.99
db.save(order_item)

# 問題：訂單總金額沒更新！資料不一致！
```

**根本問題**：
- 訂單與訂單項是一個整體
- 修改訂單項必須經過訂單驗證
- 需要有「守門員」保護資料一致性

### 解決方案：聚合根（Aggregate Root）

```python
class Order:  # 聚合根（Aggregate Root）
    """訂單是聚合根，外部只能通過它操作訂單項"""

    def __init__(self, order_id: UUID):
        self.id = order_id
        self.items: List[OrderItem] = []  # 聚合內部實體
        self.total_amount: Decimal = Decimal(0)
        self.status = OrderStatus.DRAFT

    # 唯一入口：通過聚合根操作
    def add_item(self, product_id: UUID, quantity: int, price: Decimal):
        """新增訂單項（封裝業務規則）"""
        # 業務規則檢查
        if self.status != OrderStatus.DRAFT:
            raise InvalidOrderStateError("只有草稿狀態才能新增商品")

        if quantity <= 0:
            raise ValueError("數量必須大於 0")

        # 檢查是否已存在
        existing_item = self._find_item(product_id)
        if existing_item:
            existing_item.quantity += quantity
        else:
            item = OrderItem(product_id, quantity, price)
            self.items.append(item)

        # 自動更新總金額（保持一致性）
        self._recalculate_total()

    def remove_item(self, product_id: UUID):
        """移除訂單項"""
        self.items = [i for i in self.items if i.product_id != product_id]
        self._recalculate_total()

    def _recalculate_total(self):
        """私有方法：重新計算總金額"""
        self.total_amount = sum(item.subtotal for item in self.items)

    def _find_item(self, product_id: UUID) -> Optional[OrderItem]:
        """私有方法：查找訂單項"""
        return next((i for i in self.items if i.product_id == product_id), None)

class OrderItem:  # 聚合內部實體（不能直接訪問）
    """訂單項（只能通過 Order 操作）"""

    def __init__(self, product_id: UUID, quantity: int, price: Decimal):
        self.product_id = product_id
        self.quantity = quantity
        self.price = price

    @property
    def subtotal(self) -> Decimal:
        return self.price * self.quantity

# 正確用法
order = Order(order_id)
order.add_item(product_id="P001", quantity=2, price=Decimal("99.99"))
order.add_item(product_id="P002", quantity=1, price=Decimal("199.99"))

# order.total_amount 自動計算為 399.97
# 資料一致性由聚合根保證
```

**聚合設計原則**：
1. **聚合根是唯一入口**：外部只能通過聚合根操作內部實體
2. **保證一致性邊界**：聚合內的資料必須保持一致
3. **聚合之間用 ID 引用**：不直接持有其他聚合的物件
4. **聚合儘量小**：只包含必須保持一致性的實體

### Linux 類比

**聚合根就像檔案系統的 inode**：
```bash
# inode 是檔案的「聚合根」
# 你不能直接修改資料區塊（data blocks）
# 必須通過 inode 的介面（系統調用）

# 正確方式（通過聚合根）
echo "data" > file.txt     # 系統調用 write() -> inode -> 資料區塊

# 錯誤方式（繞過聚合根）- 系統不允許
直接修改 /dev/sda1 的某個區塊  # 會破壞檔案系統一致性
```

---

## 🏷️ 核心概念 4：實體與值對象

### 實體（Entity）：有身份的對象

**定義**：有唯一識別碼，生命週期內可變，關注身份而非屬性。

**例子**：
```python
class User:  # 實體（Entity）
    """用戶是實體，有唯一 ID"""

    def __init__(self, user_id: UUID, name: str, email: Email):
        self.id = user_id  # 唯一識別碼
        self.name = name
        self.email = email

    def __eq__(self, other):
        """兩個用戶相等，當且僅當 ID 相同"""
        if not isinstance(other, User):
            return False
        return self.id == other.id

# 示例
user1 = User(UUID("123"), "Alice", "alice@example.com")
user2 = User(UUID("123"), "Bob", "bob@example.com")  # 改了名字和郵箱

print(user1 == user2)  # True - 因為 ID 相同，就是同一個人
```

**實體特徵**：
- ✅ 有唯一識別碼（ID）
- ✅ 可變（屬性會改變）
- ✅ 關注「是誰」而非「是什麼」
- ✅ 有生命週期（創建、修改、刪除）

### 值對象（Value Object）：沒有身份的對象

**定義**：無識別碼，不可變，關注屬性而非身份。

**例子**：
```python
from dataclasses import dataclass
from decimal import Decimal

@dataclass(frozen=True)  # frozen=True 表示不可變
class Money:  # 值對象（Value Object）
    """金額是值對象，只關注數值本身"""

    amount: Decimal
    currency: str = "USD"

    def __add__(self, other: 'Money') -> 'Money':
        """金額相加"""
        if self.currency != other.currency:
            raise ValueError("不同幣種無法直接相加")
        return Money(self.amount + other.amount, self.currency)

    def __eq__(self, other):
        """兩個金額相等，當且僅當數值和幣種都相同"""
        if not isinstance(other, Money):
            return False
        return self.amount == other.amount and self.currency == other.currency

# 示例
price1 = Money(Decimal("99.99"), "USD")
price2 = Money(Decimal("99.99"), "USD")

print(price1 == price2)  # True - 值相同就相等
print(price1 is price2)  # False - 但不是同一個物件

# 不可變性
# price1.amount = Decimal("100")  # 錯誤！frozen=True 不允許修改
new_price = price1 + Money(Decimal("10"), "USD")  # 只能創建新物件
```

**值對象特徵**：
- ✅ 無識別碼
- ✅ 不可變（immutable）
- ✅ 關注「是什麼」而非「是誰」
- ✅ 可以自由替換（因為只看值）

### 實體 vs 值對象：如何選擇？

**判斷標準**：

| 問題 | 答案是「是」→ 實體 | 答案是「否」→ 值對象 |
|------|------------------|-------------------|
| 需要追蹤其變化歷史嗎？ | User（需要知道誰改了名字） | Money（不需要） |
| 兩個屬性完全相同的物件，是同一個嗎？ | 不是（兩個人恰好同名） | 是（100 元就是 100 元） |
| 需要持久化到資料庫嗎？ | 需要（有獨立的表） | 不需要（嵌入到實體） |

**常見例子**：

| 實體（Entity） | 值對象（Value Object） |
|---------------|----------------------|
| 用戶（User） | 郵箱地址（Email） |
| 訂單（Order） | 金額（Money） |
| 產品（Product） | 地址（Address） |
| 帳戶（Account） | 日期範圍（DateRange） |

---

## 📡 核心概念 5：領域事件（Domain Event）

### 問題：系統之間如何通訊？

**場景：訂單已支付，需要通知多個系統**

```python
# 錯誤做法：緊耦合
class Order:
    def mark_as_paid(self):
        self.status = OrderStatus.PAID

        # 直接調用其他系統（緊耦合）
        inventory_service.reserve_stock(self.items)
        shipping_service.create_shipment(self.id)
        notification_service.send_email(self.customer_id, "訂單已支付")
        points_service.add_points(self.customer_id, self.total_amount)

# 問題：
# 1. Order 要知道所有下游系統
# 2. 任何一個系統失敗，訂單支付就失敗
# 3. 新增功能要修改 Order 類（違反開閉原則）
```

### 解決方案：領域事件

```python
from dataclasses import dataclass
from datetime import datetime
from typing import List

@dataclass
class OrderPaidEvent:  # 領域事件（Domain Event）
    """訂單已支付事件"""

    order_id: UUID
    customer_id: UUID
    total_amount: Decimal
    items: List[dict]
    paid_at: datetime

    def __post_init__(self):
        self.event_id = uuid4()
        self.event_type = "order.paid"
        self.occurred_at = datetime.now()

class Order:
    def __init__(self):
        self._events: List[DomainEvent] = []  # 事件列表

    def mark_as_paid(self):
        """標記為已支付（只關注自己的邏輯）"""
        if self.status != OrderStatus.PENDING_PAYMENT:
            raise InvalidOrderStateError("只有待支付訂單才能標記為已支付")

        self.status = OrderStatus.PAID
        self.paid_at = datetime.now()

        # 發布事件（不關心誰訂閱）
        self._events.append(OrderPaidEvent(
            order_id=self.id,
            customer_id=self.customer_id,
            total_amount=self.total_amount,
            items=[item.to_dict() for item in self.items],
            paid_at=self.paid_at
        ))

    def get_events(self) -> List[DomainEvent]:
        """獲取領域事件"""
        events = self._events.copy()
        self._events.clear()
        return events

# 事件處理器（Event Handlers）- 解耦
class InventoryEventHandler:
    """庫存服務的事件處理器"""

    def handle_order_paid(self, event: OrderPaidEvent):
        """處理訂單已支付事件"""
        inventory_service.reserve_stock(event.items)

class ShippingEventHandler:
    """物流服務的事件處理器"""

    def handle_order_paid(self, event: OrderPaidEvent):
        """處理訂單已支付事件"""
        shipping_service.create_shipment(event.order_id)

class NotificationEventHandler:
    """通知服務的事件處理器"""

    def handle_order_paid(self, event: OrderPaidEvent):
        """處理訂單已支付事件"""
        notification_service.send_email(event.customer_id, "訂單已支付")

# 事件總線（Event Bus）
class EventBus:
    def __init__(self):
        self.handlers = {
            "order.paid": [
                InventoryEventHandler().handle_order_paid,
                ShippingEventHandler().handle_order_paid,
                NotificationEventHandler().handle_order_paid,
            ]
        }

    def publish(self, event: DomainEvent):
        """發布事件"""
        handlers = self.handlers.get(event.event_type, [])
        for handler in handlers:
            try:
                handler(event)
            except Exception as e:
                logger.error(f"事件處理失敗: {e}")
                # 失敗不影響其他處理器

# 使用
order = Order(...)
order.mark_as_paid()

# 發布事件
events = order.get_events()
for event in events:
    event_bus.publish(event)
```

**領域事件的好處**：
1. **解耦**：Order 不需要知道誰訂閱了事件
2. **可擴展**：新增功能只需新增事件處理器
3. **容錯**：某個處理器失敗不影響其他
4. **追蹤**：事件是歷史記錄，可用於審計

### Linux 類比

**領域事件就像 Linux 信號（Signals）**：
```bash
# 程序不關心誰會處理 SIGTERM
kill -TERM 1234

# 不同的處理器可以訂閱同一個信號
trap 'cleanup' SIGTERM  # 處理器 1：清理資源
trap 'save_state' SIGTERM  # 處理器 2：保存狀態
```

---

## 🎯 DDD 解決什麼問題？

### 問題 1：業務複雜度管理

**沒有 DDD**：
```
需求變更 → 改程式碼 → 影響不明 → 測試困難 → 引入 Bug → 技術債累積
```

**有 DDD**：
```
需求變更 → 修改通用語言 → 定位到限界上下文 → 修改聚合 → 測試聚合 → 發布事件
```

### 問題 2：團隊溝通成本

**沒有 DDD**：
```
產品：「用戶取消訂單後要退款」
後端：「好的，我把 order_status 改成 -1，然後調用 refund_api」
前端：「-1 是取消還是關閉？我這裡顯示什麼？」
測試：「退款失敗了怎麼辦？狀態要改回去嗎？」
```

**有 DDD**：
```
產品、後端、前端、測試都使用通用語言：
- cancel_order()：取消訂單
- OrderStatus.CANCELLED：已取消狀態
- refund()：退款
- OrderCancelledEvent：訂單取消事件

所有人說的是同一個語言，程式碼就是文檔
```

### 問題 3：系統可維護性

**沒有 DDD**：
```
訂單邏輯散落在：
- OrderController（50% 邏輯）
- OrderService（30% 邏輯）
- OrderValidator（10% 邏輯）
- OrderHelper（10% 邏輯）

結果：要改一個規則，要找到所有相關程式碼
```

**有 DDD**：
```
訂單邏輯集中在：
- Order 聚合（100% 核心邏輯）

結果：所有業務規則都在聚合內，一目了然
```

---

## ⚠️ DDD 不是銀彈

### 適合 DDD 的場景

**✅ 業務邏輯複雜**
- 例子：金融系統、保險理賠、訂單流程
- 特徵：大量業務規則、頻繁變更、複雜流程

**✅ 長期維護的系統**
- 例子：企業級 ERP、SaaS 平台
- 特徵：需要 5-10 年維護週期

**✅ 需要團隊協作**
- 例子：多團隊開發的大型專案
- 特徵：需要統一語言，降低溝通成本

**✅ 業務規則頻繁變更**
- 例子：電商促銷規則、稅務計算
- 特徵：規則變動頻繁，需要靈活應對

### 不適合 DDD 的場景

**❌ CRUD 為主的簡單系統**
- 例子：內容管理系統、部落格
- 原因：沒有複雜業務邏輯，DDD 是過度設計

**❌ 一次性專案或原型**
- 例子：PoC 驗證、hackathon 專案
- 原因：投入產出比不划算

**❌ 技術複雜但業務簡單**
- 例子：高效能快取系統、訊息佇列
- 原因：DDD 關注業務複雜度，不是技術複雜度

**❌ 團隊規模太小**
- 例子：1-2 人的小團隊
- 原因：通用語言的價值體現在團隊協作

### 判斷標準

**用這個決策樹**：
```
你的專案是否有複雜業務邏輯？
├─ 否 → 不需要 DDD（用簡單的 MVC 或 CRUD）
└─ 是
    └─ 需要長期維護嗎（> 2 年）？
        ├─ 否 → 不需要 DDD（快速開發優先）
        └─ 是
            └─ 團隊規模 > 3 人嗎？
                ├─ 否 → 考慮輕量級 DDD（不要教條）
                └─ 是 → 適合完整 DDD
```

---

## 🌟 情境示範：用 DDD 重新設計訂單系統

### 傳統設計（貧血模型）

```python
# 資料模型（只有 getter/setter）
class Order:
    def __init__(self):
        self.id = None
        self.user_id = None
        self.status = 0  # 0=待支付, 1=已支付, -1=已取消
        self.total = 0.0
        self.items = []

# 業務邏輯在 Service 層
class OrderService:
    def create_order(self, user_id, items):
        order = Order()
        order.user_id = user_id
        order.status = 0
        order.items = items
        order.total = sum(item.price * item.qty for item in items)
        db.save(order)
        return order

    def cancel_order(self, order_id):
        order = db.get_order(order_id)
        if order.status != 0:
            raise Exception("只能取消待支付訂單")
        order.status = -1
        db.save(order)
        # 退款邏輯...
        # 庫存邏輯...
        # 通知邏輯...

# 問題：
# 1. Order 只是資料容器，沒有行為
# 2. 業務邏輯散落在 Service 層
# 3. 狀態用魔術數字（0, 1, -1）
```

### DDD 設計（充血模型）

```python
from enum import Enum
from decimal import Decimal
from typing import List
from dataclasses import dataclass
from datetime import datetime

# 1. 通用語言：定義清晰的狀態
class OrderStatus(Enum):
    DRAFT = "draft"                    # 草稿
    PENDING_PAYMENT = "pending_payment"  # 待支付
    PAID = "paid"                      # 已支付
    SHIPPED = "shipped"                # 已發貨
    COMPLETED = "completed"            # 已完成
    CANCELLED = "cancelled"            # 已取消

# 2. 值對象：金額
@dataclass(frozen=True)
class Money:
    amount: Decimal
    currency: str = "USD"

    def __add__(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("幣種不一致")
        return Money(self.amount + other.amount, self.currency)

    def __mul__(self, multiplier: int) -> 'Money':
        return Money(self.amount * multiplier, self.currency)

# 3. 聚合內部實體：訂單項
class OrderItem:
    def __init__(self, product_id: str, quantity: int, unit_price: Money):
        if quantity <= 0:
            raise ValueError("數量必須大於 0")

        self.product_id = product_id
        self.quantity = quantity
        self.unit_price = unit_price

    @property
    def subtotal(self) -> Money:
        return self.unit_price * self.quantity

# 4. 領域事件
@dataclass
class OrderCancelledEvent:
    order_id: str
    cancelled_at: datetime
    reason: str

# 5. 聚合根：訂單
class Order:
    """訂單聚合根（封裝所有業務邏輯）"""

    def __init__(self, order_id: str, customer_id: str):
        self.id = order_id
        self.customer_id = customer_id
        self.status = OrderStatus.DRAFT
        self.items: List[OrderItem] = []
        self._events: List = []
        self.created_at = datetime.now()

    # 業務方法（使用通用語言命名）
    def add_item(self, product_id: str, quantity: int, unit_price: Money):
        """新增訂單項"""
        if self.status != OrderStatus.DRAFT:
            raise InvalidOrderStateError("只有草稿狀態才能新增商品")

        item = OrderItem(product_id, quantity, unit_price)
        self.items.append(item)

    def submit(self):
        """提交訂單（進入待支付）"""
        if self.status != OrderStatus.DRAFT:
            raise InvalidOrderStateError("只有草稿狀態才能提交")

        if not self.items:
            raise ValueError("訂單必須包含至少一個商品")

        self.status = OrderStatus.PENDING_PAYMENT

    def mark_as_paid(self):
        """標記為已支付"""
        if self.status != OrderStatus.PENDING_PAYMENT:
            raise InvalidOrderStateError("只有待支付訂單才能標記為已支付")

        self.status = OrderStatus.PAID
        self.paid_at = datetime.now()
        # 發布事件...

    def cancel(self, reason: str):
        """取消訂單（封裝取消邏輯）"""
        if self.status in [OrderStatus.SHIPPED, OrderStatus.COMPLETED]:
            raise InvalidOrderStateError("已發貨或已完成的訂單無法取消")

        old_status = self.status
        self.status = OrderStatus.CANCELLED
        self.cancelled_at = datetime.now()
        self.cancel_reason = reason

        # 發布領域事件（通知其他系統）
        self._events.append(OrderCancelledEvent(
            order_id=self.id,
            cancelled_at=self.cancelled_at,
            reason=reason
        ))

    def can_be_cancelled(self) -> bool:
        """判斷是否可以取消"""
        return self.status not in [OrderStatus.SHIPPED, OrderStatus.COMPLETED]

    @property
    def total_amount(self) -> Money:
        """計算總金額"""
        if not self.items:
            return Money(Decimal(0))

        total = self.items[0].subtotal
        for item in self.items[1:]:
            total = total + item.subtotal
        return total

    def get_events(self):
        """獲取領域事件"""
        events = self._events.copy()
        self._events.clear()
        return events

# 使用（對比傳統方式）
order = Order("ORD001", "USER123")
order.add_item("PROD001", 2, Money(Decimal("99.99")))
order.add_item("PROD002", 1, Money(Decimal("199.99")))
order.submit()

# 業務邏輯清晰可見
print(order.total_amount)  # Money(amount=Decimal('399.97'), currency='USD')
print(order.can_be_cancelled())  # True

# 取消訂單
order.cancel(reason="用戶要求取消")

# 發布事件
for event in order.get_events():
    event_bus.publish(event)
```

**關鍵改進**：
1. **通用語言**：`OrderStatus.PENDING_PAYMENT` 取代魔術數字 `0`
2. **聚合根**：所有業務邏輯封裝在 `Order` 類
3. **值對象**：`Money` 封裝金額邏輯
4. **領域事件**：`OrderCancelledEvent` 解耦系統
5. **業務方法**：`cancel()`、`submit()`、`can_be_cancelled()` 表達業務意圖

---

## 🔗 Linux 類比：DDD 就像模組化設計

**Linux 內核設計與 DDD 驚人相似**：

| DDD 概念 | Linux 類比 |
|---------|-----------|
| 限界上下文 | 內核子系統（檔案系統、網路、記憶體管理）|
| 聚合根 | 核心資料結構（inode、socket、mm_struct）|
| 通用語言 | 系統調用介面（open, read, write）|
| 領域事件 | 信號（Signals）與 Netlink |
| 值對象 | 不可變結構（如 path 結構）|

**例子：檔案系統子系統**
```
限界上下文：VFS（虛擬檔案系統）
├─ 聚合根：inode（檔案的聚合根）
│   ├─ 實體：dentry（目錄項）
│   └─ 值對象：file_operations（操作集合）
├─ 通用語言：open(), read(), write()（所有檔案系統都實作）
└─ 領域事件：inotify（檔案變更事件）

不同檔案系統（ext4, xfs, btrfs）實作同一套通用語言（VFS 介面）
```

**關鍵啟發**：
> DDD 不是新概念，而是軟體工程的最佳實踐。
> Linux 在 30 年前就用這些原則構建了世界上最成功的軟體之一。

---

## 📝 本章總結

### 5 大核心概念速記

```
1. 通用語言（Ubiquitous Language）
   └─ 程式碼與業務語言一致，消除翻譯成本

2. 限界上下文（Bounded Context）
   └─ 劃分邊界，同一概念在不同上下文有不同含義

3. 聚合（Aggregate）
   └─ 聚合根是守門員，保護資料一致性

4. 實體與值對象（Entity & Value Object）
   └─ 實體有身份（ID），值對象只看值

5. 領域事件（Domain Event）
   └─ 解耦系統，用事件通訊
```

### DDD 的本質

**一句話總結**：
> DDD 讓程式碼說業務的語言，而不是讓業務說技術的語言。

**核心價值**：
1. **降低溝通成本**：團隊使用統一語言
2. **提升可維護性**：業務邏輯集中，易於理解
3. **應對複雜度**：用限界上下文分而治之
4. **支援演化**：領域模型隨業務演進

### 關鍵檢查點

- [ ] 能用一個比喻說明 DDD 是什麼
- [ ] 理解通用語言的價值（程式碼即業務語言）
- [ ] 能劃分限界上下文（識別邊界）
- [ ] 理解聚合根的作用（保護一致性）
- [ ] 能區分實體與值對象
- [ ] 理解領域事件的解耦作用
- [ ] 知道 DDD 適用與不適用的場景

---

## 🚀 下一步

你已經理解了 DDD 的核心概念！

**接下來**：
- 前往 `7.2_AI輔助領域建模.md`
- 學習如何用 AI 加速 DDD 流程
- 體驗從需求到程式碼的完整工作流程

**預告**：
在下一章，你將學會：
- 用 AI 從業務文檔提取通用語言（5 分鐘）
- 用 AI 自動化事件風暴（15 分鐘）
- 用 AI 設計領域模型並生成程式碼（30 分鐘）

傳統 DDD 需要數天的工作，AI 輔助後 1-2 小時即可完成！

---

**文件版本**：v1.0
**最後更新**：2025-10-30
**預估閱讀時間**：20 分鐘
