# 2.5.2 指令整合思維模型：從單點到系統的編排藝術

## 核心問題：為什麼需要指令整合

### 單指令思維的侷限

**新手常見模式**：
```bash
# 任務：為專案添加新功能

# 步驟 1
claude
提示詞：幫我寫一個用戶註冊函數
[得到程式碼]

# 步驟 2（重新開始）
claude
提示詞：幫我寫測試
[得到測試]

# 步驟 3（又重新開始）
claude
提示詞：幫我寫文檔
[得到文檔]

# 問題：
# ❌ 每次都是新對話，沒有上下文
# ❌ Claude 不記得前面的決策
# ❌ 無法確保一致性
# ❌ 重複勞動，效率低
```

### 整合思維的威力

**高手模式**：
```bash
claude --add-dir ./src

提示詞：
請執行完整的功能開發流程：

[階段 1：架構設計]
1. 分析現有的用戶模組架構
2. 設計註冊功能的接口（符合現有模式）

[階段 2：測試驅動]
3. 切換到 test-generator agent
4. 生成完整的測試案例（包含邊界情況）

[階段 3：實作]
5. 實作註冊函數，讓測試通過
6. 確保遵循專案的編碼規範

[階段 4：審查]
7. 切換到 code-reviewer agent
8. 審查程式碼品質
9. 切換到 security-auditor agent
10. 審查安全性（密碼處理、SQL 注入等）

[階段 5：文檔]
11. 使用 api-documentation 輸出風格
12. 生成 API 文檔

[階段 6：記錄]
13. 更新 CLAUDE.md，記錄重要決策

請開始執行，每個階段完成後等待我確認。

# 優勢：
# ✅ 一個會話，完整上下文
# ✅ 自動切換 agents，專業化
# ✅ 確保一致性
# ✅ 知識累積
```

---

## 指令整合的三個層次

### Level 1：線性組合（Sequential Composition）

**特徵**：步驟依序執行，後面依賴前面

**模式範本**：
```
指令 A → 產出 X → 指令 B → 產出 Y → 指令 C → 產出 Z
```

**實戰範例：程式碼重構工作流程**

```bash
# 目標：重構一個混亂的舊專案

# 步驟 1：理解現狀
提示詞：請分析 ./src/legacy_code.py 的程式碼結構和問題

# Claude 產出：
# - 發現 5 個函數，每個超過 100 行
# - 嵌套深度達到 7 層
# - 沒有測試覆蓋
# - 全域變數濫用

# 步驟 2：生成測試（基於現有行為）
提示詞：
基於剛才的分析，請先為現有程式碼生成測試，
確保我們理解它的行為。使用 pytest。

# Claude 產出：test_legacy_code.py（characterization tests）

# 步驟 3：執行測試，確保通過
提示詞：請執行測試，確保所有測試都是綠燈

# 步驟 4：重構（有測試保護）
提示詞：
現在請重構 legacy_code.py：
1. 提取函數（每個函數不超過 20 行）
2. 消除全域變數
3. 降低嵌套深度（最多 3 層）
4. 添加型別提示

確保測試持續通過。

# 步驟 5：審查
claude /agents:code-reviewer
提示詞：請審查重構後的程式碼，確認是否符合最佳實踐

# 步驟 6：記錄
提示詞：請更新 CLAUDE.md，記錄：
- 重構的主要改動
- 重構前後的複雜度對比
- 學到的教訓
```

**記憶技巧**：
> 就像 Linux 的 pipe（|），資料從一個階段流向下一個階段。
> `cat file | grep "error" | wc -l`

---

### Level 2：平行組合（Parallel Composition）

**特徵**：多個任務同時執行，彼此獨立

**模式範本**：
```
        ┌→ 任務 A → 結果 A
主任務 ─┼→ 任務 B → 結果 B
        └→ 任務 C → 結果 C
           ↓
        整合結果
```

**實戰範例：專案快速評估**

```bash
# 目標：快速評估一個新專案的狀態

claude --add-dir ./project

提示詞：
請平行分析這個專案的以下面向，然後整合成一份報告：

[任務 1：程式碼品質]
- 程式碼複雜度
- 測試覆蓋率
- 依賴關係
- 技術債務

[任務 2：安全性]
- 已知漏洞
- 依賴套件安全性
- 敏感資訊洩漏
- 權限設計

[任務 3：效能]
- 潛在效能瓶頸
- 資料庫查詢效率
- 記憶體使用
- 併發處理

[任務 4：可維護性]
- 文檔完整性
- 程式碼註解
- 命名規範
- 架構清晰度

請同時執行這 4 個分析，最後整合成一份評估報告。

# Claude 會：
# 1. 同時分析四個面向
# 2. 為每個面向打分（1-10）
# 3. 列出具體問題
# 4. 提供改進建議
# 5. 整合成結構化報告
```

**使用 `/bashes` 實現真正的平行**：

```bash
claude /bashes

# 背景任務 1：監控日誌
提示詞：在背景執行：tail -f ./logs/app.log | grep "ERROR"

# 背景任務 2：執行測試
提示詞：在背景執行：pytest --cov=src tests/

# 背景任務 3：效能分析
提示詞：在背景執行：python -m cProfile -o profile.stats ./src/main.py

# 然後你可以繼續做其他事情，定期檢查背景任務狀態
```

**記憶技巧**：
> 就像 Linux 的 background jobs（&），多個任務同時進行。
> `command1 & command2 & command3 & wait`

---

### Level 3：條件組合（Conditional Composition）

**特徵**：根據前一步的結果，動態決定下一步

**模式範本**：
```
步驟 1 → 結果評估
         ├─ 如果 A：執行路徑 X
         ├─ 如果 B：執行路徑 Y
         └─ 如果 C：執行路徑 Z
```

**實戰範例：智能程式碼審查**

```bash
claude /agents:code-reviewer

提示詞：
請審查 ./src/payment_handler.py，並根據審查結果執行不同流程：

[審查維度]
1. 程式碼品質（命名、結構、複雜度）
2. 安全性（注入、權限、加密）
3. 效能（查詢、快取、併發）
4. 測試覆蓋

[條件流程]
- 如果程式碼品質 < 7/10：
  → 切換到 refactoring-specialist
  → 提供重構方案
  → 執行重構

- 如果發現安全漏洞：
  → 切換到 security-auditor
  → 評估嚴重性（Critical/High/Medium/Low）
  → 如果 Critical/High：
    → 立即生成修復方案
    → 生成安全公告
  → 如果 Medium/Low：
    → 記錄到 issue tracker

- 如果效能問題明顯：
  → 切換到 performance-analyzer
  → 提供優化方案
  → 評估優化收益

- 如果測試覆蓋 < 80%：
  → 切換到 test-generator
  → 生成缺失的測試

[最終輸出]
- 審查報告（使用 code-review-report 風格）
- 修復/優化建議
- 優先級排序

請開始審查，並根據結果自動執行對應流程。

# Claude 會：
# 1. 先執行完整審查
# 2. 根據發現的問題，決定執行哪些流程
# 3. 自動切換 agents
# 4. 生成對應的產出
# 5. 整合成最終報告
```

**記憶技巧**：
> 就像 Shell 腳本的 if-else，根據條件執行不同邏輯。
> `if [ $? -eq 0 ]; then ... else ... fi`

---

## 常見指令組合模式

### 模式 1：分析 → 計畫 → 執行 → 驗證（APEV Pattern）

**適用場景**：任何重要的程式碼變更

```bash
# Analyze
提示詞：分析 ./src 的架構和依賴關係

# Plan
提示詞：基於分析結果，規劃如何添加 [新功能]

# Execute
提示詞：執行計畫，實作功能

# Verify
提示詞：
1. 執行所有測試
2. 進行程式碼審查
3. 檢查安全性
4. 確認效能影響
```

**記憶點**：就像軍事行動的 OODA Loop（Observe-Orient-Decide-Act）

---

### 模式 2：探索 → 聚焦 → 深入（EFD Pattern）

**適用場景**：理解大型專案

```bash
# Explore（探索階段）
claude --add-dir .
提示詞：請給我這個專案的概覽：
- 主要功能
- 技術棧
- 目錄結構

# Focus（聚焦階段）
提示詞：我要理解用戶認證模組，請列出相關檔案

# Deep-dive（深入階段）
提示詞：請詳細解釋 ./src/auth/jwt_handler.py 的工作原理
```

**記憶點**：就像地圖導航，從全景 → 區域 → 街道

---

### 模式 3：紅 → 綠 → 重構（TDD Pattern）

**適用場景**：測試驅動開發

```bash
# Red（紅燈 - 寫失敗的測試）
claude /agents:test-generator
提示詞：為尚未實作的 [功能] 生成測試

# Green（綠燈 - 讓測試通過）
claude /agents:off
提示詞：實作 [功能]，讓測試通過（允許簡陋實作）

# Refactor（重構 - 改善程式碼）
claude /agents:refactoring-specialist
提示詞：在保持測試通過的前提下，重構程式碼
```

**記憶點**：就像紅綠燈，紅燈停（寫測試）→ 綠燈行（實作）→ 黃燈慢（重構）

---

### 模式 4：本地 → 整合 → 全域（LIG Pattern）

**適用場景**：大規模程式碼變更

```bash
# Local（本地變更）
提示詞：修改 ./src/user_service.py 中的 [功能]

# Integration（整合測試）
提示詞：
1. 執行 user_service 的單元測試
2. 執行相關的整合測試
3. 檢查是否影響其他模組

# Global（全域檢查）
提示詞：
1. 執行整個專案的測試套件
2. 檢查 CI/CD 是否通過
3. 生成變更影響報告
```

**記憶點**：就像 Git 的工作流程：local → staging → remote

---

### 模式 5：草稿 → 精煉 → 完成（DRP Pattern）

**適用場景**：文檔撰寫、文章創作

```bash
# Draft（草稿）
提示詞：快速寫一份 [主題] 的技術文章大綱

# Refine（精煉）
claude /agents:technical-writer
提示詞：
基於大綱，撰寫完整文章，包含：
- 引人入勝的開頭
- 清晰的技術解釋
- 實用的程式碼範例
- 引導性的結論

# Polish（完成）
提示詞：
1. 檢查文法和拼寫
2. 優化 SEO（標題、meta、關鍵字）
3. 添加圖表建議
4. 生成社群媒體宣傳文案
```

**記憶點**：就像寫作流程：初稿 → 修改 → 定稿

---

## 決策樹：何時用什麼組合

```
遇到任務時的思考流程：

1. 這是單一任務還是複雜任務？
   ├─ 單一 → 直接執行
   └─ 複雜 → 繼續判斷

2. 步驟之間有依賴關係嗎？
   ├─ 有 → 使用線性組合（Level 1）
   └─ 無 → 使用平行組合（Level 2）

3. 需要根據結果動態調整嗎？
   ├─ 需要 → 使用條件組合（Level 3）
   └─ 不需要 → 使用固定流程

4. 有現成的模式可以套用嗎？
   ├─ 有 → 套用模式（APEV/EFD/TDD...）
   └─ 無 → 設計新流程

5. 需要多個 Agents 嗎？
   ├─ 需要 → 規劃 Agent 切換順序
   └─ 不需要 → 使用通用模式

6. 需要 MCP 整合嗎？
   ├─ 需要 → 確認 MCP 可用性
   └─ 不需要 → 純 CLI 流程

7. 輸出格式有要求嗎？
   ├─ 有 → 使用 /output-style
   └─ 無 → 預設格式
```

---

## 實戰案例：複雜任務的指令編排

### 案例：為開源專案做重大貢獻

**任務分解**：

```bash
# ===== 階段 0：準備 =====
claude /init
提示詞：初始化專案記憶

# ===== 階段 1：專案理解（EFD 模式）=====
# Explore
claude --add-dir ./opensource-project
提示詞：
請分析這個開源專案：
1. 專案目標與功能
2. 架構設計
3. 技術棧
4. 貢獻指南

將關鍵資訊記錄到 CLAUDE.md

# Focus
提示詞：
我想貢獻「添加 WebSocket 支援」功能。
請：
1. 找出相關模組
2. 分析現有的網路層設計
3. 識別需要修改的檔案

# Deep-dive
提示詞：
詳細解釋 ./src/network/connection.py 的工作原理，
特別是連接管理和協議處理。

# ===== 階段 2：Issue 分析（平行組合）=====
提示詞：
請同時分析 Issue #456「Add WebSocket support」的：
1. 技術可行性
2. 設計選項（長輪詢 vs WebSocket vs SSE）
3. 影響範圍
4. 實作複雜度評估
5. 需要的外部依賴

整合成一份技術評估報告。

# ===== 階段 3：設計方案（條件組合）=====
claude /agents:architect
提示詞：
基於剛才的分析，設計 WebSocket 支援方案。

如果設計複雜度 > 7/10：
- 拆分成多個 PR
- 提供漸進式實作計畫

如果需要 Breaking Changes：
- 提供向後相容方案
- 設計遷移指南

如果影響效能：
- 提供效能評估
- 設計降級方案

輸出完整的技術設計文檔。

# ===== 階段 4：TDD 實作（TDD 模式）=====
# Red
claude /agents:test-generator
提示詞：
根據技術設計，生成完整的測試案例：
1. WebSocket 連接建立
2. 訊息發送與接收
3. 連接斷開與重連
4. 錯誤處理
5. 併發場景

# Green
claude /agents:off
提示詞：
實作 WebSocket 支援，讓所有測試通過。
遵循專案的編碼規範（參考 CLAUDE.md）。

# Refactor
claude /agents:refactoring-specialist
提示詞：
重構實作，優化：
1. 程式碼結構
2. 錯誤處理
3. 效能
確保測試持續通過。

# ===== 階段 5：審查（APEV 模式）=====
# 程式碼審查
claude /agents:code-reviewer
提示詞：審查 WebSocket 實作，對照專案的 Contributing Guidelines

# 安全審查
claude /agents:security-auditor
提示詞：
審查安全性：
1. WebSocket 握手驗證
2. 訊息內容驗證
3. DoS 防護
4. 資源洩漏

# 效能審查
claude /agents:performance-analyzer
提示詞：
分析效能影響：
1. 記憶體使用
2. CPU 使用
3. 併發處理能力
4. 與 HTTP 的效能對比

# ===== 階段 6：文檔（DRP 模式）=====
# Draft
提示詞：列出需要更新的文檔：
- README（新增 WebSocket 範例）
- API 文檔
- 架構文檔
- 遷移指南（如果有 Breaking Changes）

# Refine
claude /agents:documentation-writer
claude /output-style:api-documentation
提示詞：撰寫完整的 WebSocket API 文檔

# Polish
提示詞：
1. 檢查文檔一致性
2. 添加圖表（架構圖、時序圖）
3. 提供完整範例

# ===== 階段 7：PR 準備（線性組合）=====
# 生成 CHANGELOG
提示詞：根據變更，生成 CHANGELOG 條目（遵循 Keep a Changelog 格式）

# 生成 PR 描述
claude /output-style:pr-description
提示詞：
生成 Pull Request 描述，包含：
- 功能摘要
- 技術實作細節
- 測試覆蓋
- Breaking Changes（如果有）
- 截圖/範例
- 檢查清單

# 生成 Commit Message
提示詞：
生成 Git commit messages（遵循 Conventional Commits）：
1. 主 commit：feat(network): add WebSocket support
2. 文檔 commit：docs: add WebSocket API documentation
3. 測試 commit：test: add WebSocket integration tests

# ===== 階段 8：知識記錄 =====
claude /memory
提示詞：
更新 CLAUDE.md，記錄：
1. WebSocket 實作的關鍵決策
2. 遇到的技術挑戰與解決方案
3. 專案維護者的反饋要點
4. 學到的專案特有知識
```

**統計這個流程**：
- 使用了 5 種 Agents
- 使用了 3 個組合模式（EFD + TDD + APEV）
- 使用了 2 個條件邏輯
- 使用了 2 個輸出風格
- 整個流程自動化，只需要人工確認關鍵節點

---

## 進階技巧：流程模板化

### 創建可重用的工作流程

**範例：創建「安全發布檢查清單」流程**

```bash
# 步驟 1：設計流程模板
# .claude/workflows/security-release-checklist.md

---
name: security-release-checklist
description: 產品發布前的安全檢查流程
---

## 階段 1：程式碼審查
- [ ] 靜態分析（SAST）
- [ ] 依賴套件掃描
- [ ] 秘密洩漏檢查
- [ ] 程式碼審查

## 階段 2：動態測試
- [ ] 滲透測試
- [ ] 模糊測試（Fuzzing）
- [ ] 負載測試

## 階段 3：設定審查
- [ ] 伺服器強化檢查
- [ ] TLS/SSL 設定
- [ ] 防火牆規則
- [ ] 日誌設定

## 階段 4：文檔檢查
- [ ] 安全公告準備
- [ ] 更新日誌（CHANGELOG）
- [ ] 遷移指南

## 階段 5：備份與回滾
- [ ] 資料備份驗證
- [ ] 回滾計畫測試
- [ ] 監控告警設置

# 步驟 2：使用流程模板
claude

提示詞：
請執行 security-release-checklist 流程，
針對即將發布的 v2.0 版本。

# Claude 會：
# 1. 載入流程模板
# 2. 逐項執行檢查
# 3. 記錄結果
# 4. 生成完整的安全報告
# 5. 標記未通過的項目
```

---

## 效率提升清單

使用指令整合後，你應該能達到：

**時間節省**：
- [ ] 程式碼審查：從 1 小時 → 10 分鐘
- [ ] 寫測試：從 2 小時 → 30 分鐘
- [ ] 重構：從 1 天 → 2 小時
- [ ] 文檔撰寫：從 3 小時 → 30 分鐘

**品質提升**：
- [ ] 測試覆蓋率：從 60% → 90%
- [ ] 安全漏洞：減少 80%
- [ ] 程式碼一致性：100%
- [ ] 文檔完整性：100%

**知識累積**：
- [ ] 專案記憶（CLAUDE.md）：自動更新
- [ ] 團隊知識：結構化記錄
- [ ] 決策歷史：可追溯

---

## 學習路徑

### 第 1 天：理解組合
- [ ] 完成一個線性組合（APEV）
- [ ] 理解為什麼比單指令高效

### 第 2-3 天：嘗試模式
- [ ] 練習 TDD 模式
- [ ] 練習 EFD 模式
- [ ] 練習 DRP 模式

### 第 4-5 天：設計流程
- [ ] 分析自己的工作流程
- [ ] 設計自動化流程
- [ ] 實際應用到工作中

### 第 2 週：進階整合
- [ ] 使用條件組合
- [ ] 整合 MCP
- [ ] 創建流程模板

---

## 關鍵頓悟時刻

在學習過程中，你應該經歷：

1. **"原來可以一次完成整個流程！"**
   - 觸發點：第一次用 APEV 模式

2. **"原來不需要每次都重新描述上下文！"**
   - 觸發點：使用 CLAUDE.md 和 /memory

3. **"原來可以自動切換專家模式！"**
   - 觸發點：條件組合自動切換 agents

4. **"原來我的工作流程可以標準化！"**
   - 觸發點：創建第一個流程模板

5. **"原來我可以設計自己的開發方法論！"**
   - 觸發點：整合多個模式成為個人系統

---

## 下一步

現在你已經掌握指令整合思維，接下來：

1. **實作**：完成「練習1_多Agent協作流程」
2. **探索**：閱讀 2.5.3_跨領域應用場景.md
3. **應用**：將學到的模式應用到實際工作

**記住**：
> 指令整合不是「記住固定流程」，
> 而是「學會組合思維」。
> 就像 Unix 哲學：組合簡單工具，完成複雜任務。

## 高級整合模式：專家級工作流程

### 模式 6：狀態機組合（State Machine Pattern）

**適用場景**：複雜的多狀態任務，需要根據不同狀態執行不同邏輯

```bash
# 範例：智能 PR 處理機器人
claude

提示詞：
創建 PR 處理狀態機：

[狀態定義]
- SUBMITTED: PR 剛提交
- IN_REVIEW: 正在審查中
- CHANGES_REQUESTED: 需要修改
- APPROVED: 已批准
- MERGED: 已合併
- REJECTED: 已拒絕

[狀態轉換邏輯]
SUBMITTED → IN_REVIEW:
- 自動分配審查者
- 執行自動化檢查（CI/CD、安全掃描）
- 生成審查檢查清單

IN_REVIEW → APPROVED:
- 如果所有檢查通過 + 審查者批准
- 準備合併流程

IN_REVIEW → CHANGES_REQUESTED:
- 如果檢查失敗或審查者要求修改
- 生成修改建議
- 通知作者

CHANGES_REQUESTED → IN_REVIEW:
- 檢測到新 commits
- 重新觸發檢查流程

APPROVED → MERGED:
- 自動合併（如果設定允許）
- 更新相關 issues
- 發送完成通知

任何狀態 → REJECTED:
- 如果違反重大政策
- 記錄拒絕原因
- 提供改進建議

請實作這個狀態機。
```

**記憶技巧**：就像交通燈系統，每個狀態有特定的行為和轉換條件。

---

### 模式 7：事件驅動組合（Event-Driven Pattern）

**適用場景**：需要響應外部事件的自動化

```bash
# 範例：DevOps 事件響應系統
claude

提示詞：
設計事件驅動的運維響應系統：

[事件類型與響應]
GitHub Event: Push to main branch
→ 觸發 CI/CD 流程
→ 通知團隊
→ 更新部署狀態

Monitoring Alert: CPU > 80%
→ 分析日誌找原因
→ 如果是已知問題：自動處理
→ 如果是未知問題：升級告警

Security Alert: 異常登入
→ 立即鎖定帳戶
→ 通知安全團隊
→ 記錄事件詳情

Customer Support: 新 ticket
→ 分類緊急程度
→ 分配給對應團隊
→ 設置 SLA 提醒

Database Alert: 查詢過慢
→ 分析慢查詢
→ 建議索引優化
→ 如果是緊急問題：通知 DBA

請實作事件監聽和響應邏輯。
```

---

### 模式 8：管道組合（Pipeline Pattern）

**適用場景**：資料處理、部署流程等需要多階段處理的任務

```bash
# 範例：內容發布管道
claude

提示詞：
創建內容發布管道：

[Stage 1: 內容準備]
輸入：草稿文章
處理：
- 語法檢查
- 事實查核
- 圖片優化
- SEO 優化
輸出：準備好的內容

[Stage 2: 多平台調整]
輸入：準備好的內容
處理：
- 轉換為各平台格式
- 調整字數限制
- 添加平台特定標籤
輸出：多平台版本

[Stage 3: 排程發布]
輸入：多平台版本
處理：
- 選擇最佳發布時間
- 排程到各平台
- 設置追蹤
輸出：發布計畫

[Stage 4: 監控分析]
輸入：發布計畫
處理：
- 監控互動數據
- 分析效果
- 生成報告
輸出：效果分析

[容錯機制]
- 任何階段失敗：暫停管道，記錄錯誤
- 提供重試機制
- 支援從任意階段重新開始

請實作這個管道系統。
```

---

## 決策支援系統：智能選擇最佳模式

### 決策樹 2.0：更精確的模式選擇

```bash
# 智能模式選擇器
claude

提示詞：
分析我的任務，推薦最佳組合模式：

[任務描述]
我需要：[詳細描述你的任務]

[分析維度]
1. 複雜度分析：
   - 步驟數量（1-3 → 簡單，4-7 → 中等，8+ → 複雜）
   - 依賴關係（線性、並行、條件、混合）
   - 外部整合數量

2. 時間特性：
   - 一次性任務 vs 重複性任務
   - 即時處理 vs 批量處理
   - 同步 vs 異步

3. 資源需求：
   - CPU 密集 vs I/O 密集
   - 記憶體需求
   - 網路頻寬需求

4. 錯誤容忍度：
   - 高容錯（可以重試）
   - 中容錯（需要檢查點）
   - 低容錯（需要嚴格驗證）

[輸出]
- 推薦模式：[主要模式 + 輔助模式]
- 推薦理由：[為什麼適合]
- 注意事項：[可能的陷阱]
- 實作建議：[具體步驟]

請開始分析。
```

---

### 模式組合矩陣

| 任務特徵 | 主要模式 | 輔助模式 | 適用情境 |
|---------|---------|---------|---------|
| 線性依賴 + 簡單 | APEV | - | 功能開發 |
| 線性依賴 + 複雜 | APEV | Pipeline | 大型重構 |
| 無依賴 + 多任務 | 平行組合 | 狀態機 | 資料分析 |
| 事件驅動 | Event-Driven | 條件組合 | 監控系統 |
| 內容創作 | DRP | Pipeline | 部落格撰寫 |
| 學習探索 | EFD | 線性組合 | 新專案理解 |
| 測試開發 | TDD | 狀態機 | 功能實作 |
| 部署上線 | Pipeline | Event-Driven | CI/CD |

---

## 進階技巧：元編程思維

### 技巧 1：動態模式生成

```bash
# 讓 AI 設計工作流程
claude

提示詞：
我有一個新類型的任務，沒有現成的模式可以套用。
請分析任務特徵，設計專用的組合模式：

[任務]
[描述你的獨特任務]

[設計要求]
1. 分析任務的核心特徵
2. 識別關鍵步驟和依賴關係
3. 設計新的組合模式
4. 命名這個模式
5. 提供可重用的範本
6. 給出使用時機

讓 AI 成為你的工作流程設計師。
```

### 技巧 2：模式優化迭代

```bash
# 優化現有工作流程
claude

提示詞：
優化我的工作流程：

[現有流程]
[描述你當前的工作流程]

[問題點]
[列出遇到的問題]

[優化目標]
- 減少時間：目標 X%
- 提高品質：具體指標
- 降低錯誤：目標錯誤率

[優化分析]
1. 瓶頸識別
2. 重複操作合併
3. 平行化機會
4. 自動化機會
5. 工具整合機會

請提供優化方案。
```

---

## 團隊協作：組合模式的標準化

### 團隊工作流程庫

```bash
# 建立團隊共用的工作流程庫
claude

提示詞：
為我們團隊建立標準化的工作流程庫：

[團隊角色]
- 前端工程師
- 後端工程師
- DevOps 工程師
- QA 工程師
- 產品經理
- 設計師

[常見任務]
- 新功能開發
- Bug 修復
- 效能優化
- 安全更新
- 版本發布
- 文檔更新

[要求]
1. 為每種任務設計標準流程
2. 定義角色職責
3. 設置檢查點
4. 建立溝通機制
5. 提供範本和檢查清單

輸出格式：
- 流程文檔（Markdown）
- 檢查清單（Checkbox）
- 範本檔案
- 工具配置

請開始設計。
```

### 知識傳承機制

```bash
# 建立組織記憶
claude

提示詞：
建立團隊的工作流程知識庫：

[知識記錄]
1. 成功案例：
   - 專案背景
   - 使用的模式
   - 關鍵決策
   - 最終成果

2. 失敗教訓：
   - 問題描述
   - 原因分析
   - 改進方案
   - 預防措施

3. 最佳實踐：
   - 場景描述
   - 推薦模式
   - 注意事項
   - 相關工具

[系統設計]
- 使用 Notion 作為知識庫
- 標籤系統分類
- 搜尋功能
- 定期更新機制
- 新人入職指南

請設計這個知識管理系統。
```

---

## 實戰演練：綜合案例

### 案例：構建個人 AI 助手生態系統

```bash
claude

提示詞：
設計一個完整的個人 AI 助手生態系統：

[目標]
建立一個能自動化我 80% 日常工作的 AI 系統

[涵蓋領域]
1. 程式開發（coding, review, deploy）
2. 知識管理（note, research, learning）
3. 內容創作（blog, social, documentation）
4. 專案管理（planning, tracking, reporting）
5. 生活管理（schedule, finance, health）

[技術架構]
- 核心：Claude Code + 自訂 agents
- 整合：10+ MCP servers
- 儲存：Notion + Obsidian + Git
- 通訊：Slack + Email + Calendar
- 監控：自訂 dashboard

[實作計畫]
使用多種組合模式：
- 核心工作流程：APEV + Pipeline
- 監控系統：Event-Driven + 狀態機
- 學習系統：EFD + DRP
- 內容系統：DRP + Pipeline

[要求]
1. 設計系統架構圖
2. 定義各組件的職責
3. 設計 API 接口
4. 制定實作時程表
5. 建立測試計畫

這是一個 2-3 週的專案，請詳細設計。
```

---

## 測量與優化：組合效果評估

### 效果評估框架

```bash
# 評估工作流程效果
claude

提示詞：
評估我的指令組合使用效果：

[評估維度]
1. 時間效率：
   - 任務完成時間（before/after）
   - 等待時間
   - 上下文切換時間

2. 品質指標：
   - 錯誤率
   - 完整性
   - 一致性

3. 學習曲線：
   - 上手難度
   - 熟練程度
   - 知識遷移

4. 維護成本：
   - 更新頻率
   - 故障率
   - 文檔維護

[測量方法]
- 時間記錄：使用工具追蹤
- 品質檢查：建立檢查清單
- 滿意度調查：定期自評
- 同儕比較：團隊基準

[優化建議]
基於數據提供具體的改進方案

請設計評估體系。
```

---

## 未來展望：AI 組合的進化

### 新興模式探索

**模式 9：自適應組合（Adaptive Pattern）**
```bash
# AI 自動調整工作流程
claude

提示詞：
設計自適應工作流程：

根據以下因素自動調整組合模式：
- 任務類型和複雜度
- 當前系統負載
- 用戶偏好設定
- 歷史成功率
- 時間限制

讓 AI 學習並優化自己的工作流程。
```

**模式 10：協作組合（Collaborative Pattern）**
```bash
# 多人協作的 AI 輔助
claude

提示詞：
設計團隊協作模式：

多個 AI agents 協作處理複雜任務：
- 任務分解與分配
- 進度同步與協調
- 衝突解決機制
- 成果整合

實現真正的 AI 團隊協作。
```

---

**文檔版本**：v1.1
**最後更新**：2025年1月
**預計學習時間**：120 分鐘
**前置知識**：完成 2.5.1 AI Agent 平台本質
