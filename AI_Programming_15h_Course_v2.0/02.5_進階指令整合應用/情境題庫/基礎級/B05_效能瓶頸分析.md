# B05：效能瓶頸分析 - Performance Agent 的專業診斷

## 🎯 學習目標

**知識目標**：
- [ ] 理解 `performance-analyzer` agent 的分析能力
- [ ] 掌握常見的效能問題類型
- [ ] 了解效能優化的系統化方法

**技能目標**：
- [ ] 能使用效能分析 agent 識別瓶頸
- [ ] 能理解不同類型的效能指標
- [ ] 能獲得具體的優化建議

**時間估計**：25-30 分鐘

---

## 📋 情境描述

### 背景故事
你的電商網站最近用戶抱怨頁面載入緩慢，特別是商品搜尋功能。老闆要求你在一週內找出並解決效能問題。你需要快速識別瓶頸，並提出優化方案。

### 問題陳述
以下是商品搜尋系統的程式碼，存在明顯的效能問題：

```python
# product_search.py
import time
import random
from typing import List, Dict

class ProductDatabase:
    def __init__(self):
        # 模擬 10,000 個商品
        self.products = []
        for i in range(10000):
            self.products.append({
                'id': i,
                'name': f'Product {i}',
                'category': random.choice(['electronics', 'books', 'clothing', 'home']),
                'price': random.randint(10, 1000),
                'description': f'This is a detailed description for product {i}' * 5,
                'tags': [f'tag{j}' for j in range(random.randint(1, 10))]
            })

    def search_products(self, query: str, category: str = None) -> List[Dict]:
        """搜尋商品 - 有效能問題的版本"""
        results = []

        # 問題1：沒有使用索引，線性搜尋
        for product in self.products:
            # 模擬資料庫查詢延遲
            time.sleep(0.001)  # 每個商品1ms

            # 問題2：複雜的字符串比較
            if query.lower() in product['name'].lower() or \
               query.lower() in product['description'].lower():

                # 問題3：重複的類別檢查
                if category:
                    if product['category'] == category:
                        results.append(product)
                else:
                    results.append(product)

        # 問題4：不必要的排序
        results.sort(key=lambda x: x['price'])

        return results

    def get_related_products(self, product_id: int) -> List[Dict]:
        """獲取相關商品 - N+1 查詢問題"""
        product = None

        # 問題5：重複查詢
        for p in self.products:
            if p['id'] == product_id:
                product = p
                break

        if not product:
            return []

        related = []
        # 問題6：為每個標籤都查詢一次
        for tag in product['tags']:
            for p in self.products:
                if tag in p['tags'] and p['id'] != product_id:
                    related.append(p)

        return related[:5]

class ProductController:
    def __init__(self):
        self.db = ProductDatabase()

    def search_page(self, query: str, page: int = 1, per_page: int = 20):
        """搜尋頁面 - 多重效能問題"""

        # 問題7：每次都重新搜尋所有結果
        all_results = self.db.search_products(query)

        # 問題8：記憶體中排序大數據
        all_results.sort(key=lambda x: (-x['price'], x['name']))

        # 問題9：手動分頁邏輯
        start = (page - 1) * per_page
        end = start + per_page
        page_results = all_results[start:end]

        # 問題10：為每個商品獲取相關商品
        for product in page_results:
            product['related'] = self.db.get_related_products(product['id'])

        return {
            'products': page_results,
            'total': len(all_results),
            'page': page,
            'per_page': per_page
        }

# 使用範例
def main():
    controller = ProductController()

    # 模擬搜尋請求
    print("開始搜尋...")
    start_time = time.time()

    results = controller.search_page("Product", page=1, per_page=10)

    end_time = time.time()
    print(f"搜尋完成，耗時: {end_time - start_time:.2f} 秒")
    print(f"找到 {results['total']} 個結果")

if __name__ == "__main__":
    main()
```

### 任務要求
1. 使用 `performance-analyzer` agent 分析效能瓶頸
2. 識別各種類型的效能問題
3. 理解問題的嚴重程度和影響
4. 獲得具體的優化建議

---

## 🛠️ 實作步驟

### 步驟 1：準備效能分析環境
```bash
# 1. 創建效能分析專案
mkdir performance_analysis
cd performance_analysis

# 2. 保存程式碼
# 將上述程式碼保存為 product_search.py
```

### 步驟 2：一般模式分析（基線）
```bash
claude --add-file product_search.py
```

**提示詞**：
```
這個商品搜尋系統很慢，請幫我找出問題。
```

**觀察重點**：一般模式能發現什麼問題？

### 步驟 3：專業效能分析
```bash
# 切換到效能分析專家
/agents:performance-analyzer
```

**提示詞**：
```
請對這個商品搜尋系統進行全面的效能分析，重點關注：

1. 時間複雜度問題
2. 空間複雜度問題
3. 資料庫查詢效率
4. 記憶體使用模式
5. I/O 操作瓶頸
6. 演算法效率問題

請：
- 按影響程度排序問題（Critical/High/Medium/Low）
- 估算每個問題的效能影響
- 提供量化的改進預期
- 給出具體的優化代碼
```

### 步驟 4：深入分析特定問題
**提示詞**：
```
針對線性搜尋問題，請詳細分析：

1. 當前實作的時間複雜度
2. 在不同資料量下的效能表現預測
3. 建議的優化方案（索引、快取等）
4. 每種方案的實作複雜度和效能收益
5. 提供具體的優化代碼範例

請像技術主管一樣進行深度分析。
```

### 步驟 5：獲得優化版本
**提示詞**：
```
請提供這個搜尋系統的高效能版本，解決所有發現的瓶頸：

1. 使用適當的資料結構和索引
2. 優化查詢邏輯
3. 實施快取機制
4. 改善記憶體使用
5. 減少不必要的計算

請在每個優化處說明：
- 解決了什麼問題
- 預期的效能提升
- 權衡考量（如記憶體 vs 速度）
```

---

## ✅ 成功檢查點

完成此情境後，你應該能夠：

**理解檢查點**：
- [ ] 我理解常見的效能瓶頸類型
- [ ] 我知道如何評估效能問題的嚴重程度
- [ ] 我明白優化的權衡考量

**技能檢查點**：
- [ ] 我能使用 `performance-analyzer` 進行專業分析
- [ ] 我能理解時間和空間複雜度分析
- [ ] 我能評估優化方案的可行性

**實戰檢查點**：
- [ ] 我能識別 O(n²) 複雜度問題
- [ ] 我理解索引和快取的作用
- [ ] 我知道如何測量效能改進

---

## 🔍 預期發現的效能問題

### 🔴 Critical 級別
1. **線性搜尋**：O(n) 複雜度，每次搜尋10,000個商品
2. **N+1 查詢問題**：相關商品查詢導致指數級複雜度

### 🟠 High 級別
3. **重複計算**：每次搜尋都重新排序所有結果
4. **記憶體浪費**：載入所有商品到記憶體再分頁

### 🟡 Medium 級別
5. **字符串操作**：大量的字符串比較和轉換
6. **無謂的排序**：對不需要的結果進行排序

### 效能影響估算
```
目前效能：
- 10,000 商品搜尋：約 10-15 秒
- 記憶體使用：約 50-100MB
- CPU 使用：持續高負載

優化後預期：
- 同樣搜尋：約 0.1-0.5 秒 (95% 改善)
- 記憶體使用：約 10-20MB (80% 減少)
- CPU 使用：低負載
```

---

## 🎓 學習收穫

### 核心概念
1. **效能分析的系統性**：不只看表面慢，要找根本原因
2. **複雜度思維**：從 O(n²) 到 O(log n) 的差異是巨大的
3. **權衡藝術**：速度 vs 記憶體 vs 複雜度的平衡

### 常見效能模式
1. **索引缺失**：線性搜尋 → 雜湊表/B-tree
2. **快取缺失**：重複計算 → 記憶化
3. **批量操作**：N+1 查詢 → 批量載入
4. **分頁策略**：全量載入 → 資料庫分頁

### 優化策略層次
```
Level 1: 演算法優化（最大收益）
Level 2: 資料結構選擇
Level 3: 快取策略
Level 4: 硬體升級（最後選擇）
```

---

## 🚀 進階挑戰

### 挑戰 1：效能測試設計
**提示詞**：
```
設計一個完整的效能測試方案：

1. 基準測試（Benchmark）設計
2. 負載測試場景
3. 壓力測試指標
4. 效能迴歸測試
5. 監控指標定義

包含具體的測試工具和腳本。
```

### 挑戰 2：效能監控系統
**提示詞**：
```
設計一個即時效能監控系統：

1. 關鍵指標定義（KPI）
2. 告警觸發條件
3. 自動擴容策略
4. 效能報告生成
5. 瓶頸預警機制
```

### 挑戰 3：資料庫優化
**提示詞**：
```
針對這個搜尋系統，設計資料庫優化方案：

1. 索引策略
2. 查詢優化
3. 資料分割（Sharding）
4. 讀寫分離
5. 快取層設計

提供 SQL 和架構圖。
```

---

## 📚 相關資源

**效能分析工具**：
- [cProfile](https://docs.python.org/3/library/profile.html) - Python 效能分析
- [py-spy](https://github.com/benfred/py-spy) - 生產環境分析
- [locust](https://locust.io/) - 負載測試

**學習資源**：
- [High Performance Python](https://www.oreilly.com/library/view/high-performance-python/9781492055013/)
- [演算法與資料結構](https://visualgo.net/en)

**後續學習**：
- B06：資料庫查詢優化
- C04：完整效能優化流程

---

## 💭 反思問題

1. **優化優先級**：面對多個效能問題，你會如何排優先級？
2. **測量重要性**：為什麼說「不能測量就不能優化」？
3. **過早優化**：什麼情況下不應該進行效能優化？
4. **實際應用**：在實際專案中，你會如何建立效能監控？

---

## 🔗 與前面情境的連結

**Agent 專業化累積**：
- B01：`code-reviewer` - 程式碼品質
- B02：`documentation-writer` - 文檔品質
- B04：`security-auditor` - 安全品質
- **B05**：`performance-analyzer` - 效能品質

**全面品質觀念**：
```
功能正確 + 安全無漏洞 + 文檔完整 + 效能良好 = 高品質軟體
```

---

**完成時間記錄**：___ 分鐘
**發現的效能問題數量**：___
**最大的效能收益來源**：___
**筆記區域**：
```
記錄你對效能優化的理解和發現...
```

---

*本情境重點是培養效能意識，學習系統化的效能分析方法。好的效能不是偶然，而是設計出來的。*