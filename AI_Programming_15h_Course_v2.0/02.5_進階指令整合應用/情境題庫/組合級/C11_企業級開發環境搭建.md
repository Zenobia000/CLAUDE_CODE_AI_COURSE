# C11：企業級開發環境搭建（組合級）

## 情境資訊

**編號**：C11
**難度**：⭐⭐⭐⭐☆（組合級偏難）
**預計時間**：2.5 小時
**學習目標**：
- 掌握使用 AI 協助設計完整開發環境
- 學會 DevOps Engineer Agent 的深度應用
- 理解 Docker, CI/CD, 測試基礎設施的整合
- 建立可復用的環境搭建模板

**適用對象**：
- 負責建立新專案的技術 Lead
- DevOps 工程師
- 需要標準化團隊開發環境

---

## 情境描述

### 背景

你的公司決定啟動一個新的微服務專案，採用 Python Flask + React 技術棧。你被指派負責建立整個開發環境基礎設施。

管理層的要求：
- **標準化**：所有開發者的環境必須一致
- **自動化**：一鍵啟動開發環境
- **品質保證**：整合自動測試與代碼檢查
- **快速部署**：支援一鍵部署到測試環境
- **可觀測性**：日誌、監控、錯誤追蹤

### 專案需求

#### 技術棧
- **後端**: Python 3.11 + Flask + SQLAlchemy
- **前端**: React 18 + TypeScript + Vite
- **資料庫**: PostgreSQL 15
- **快取**: Redis 7
- **訊息佇列**: RabbitMQ（未來需求）

#### 開發工具需求
- **版本控制**: Git + GitHub
- **CI/CD**: GitHub Actions
- **容器化**: Docker + Docker Compose
- **測試**: pytest (backend), Jest (frontend)
- **代碼品質**: Black, Flake8, ESLint, Prettier
- **安全掃描**: Bandit, npm audit
- **文檔**: Swagger (API), Storybook (UI)

#### 環境需求
- **本地開發**: Docker Compose 一鍵啟動
- **測試環境**: 自動部署到 AWS/Heroku
- **監控**: Prometheus + Grafana（未來）
- **日誌**: ELK Stack 或 CloudWatch（未來）

### 你的任務

使用 Claude Code AI Agent 平台，建立完整的企業級開發環境，包含：

1. **Docker 容器化環境**
2. **CI/CD 自動化管線**
3. **代碼品質檢查流程**
4. **測試基礎設施**
5. **部署腳本與文檔**

---

## 學習重點

### 目標 1：DevOps 思維模式

理解如何用 AI 協助設計基礎設施：
- 從需求分析到架構設計
- 從架構設計到具體設定檔
- 從設定檔到自動化腳本
- 從腳本到文檔

### 目標 2：多 Agent 協作

學會組織不同專業 Agent 完成 DevOps 任務：
- **devops-engineer**: 設計基礎設施
- **architect**: 檢視架構合理性
- **security-auditor**: 檢查安全性
- **technical-writer**: 產出文檔

### 目標 3：設定檔生成技巧

掌握生成高品質設定檔的方法：
- Dockerfile 最佳實踐
- docker-compose.yml 設計
- GitHub Actions workflow
- 環境變數管理

### 目標 4：知識模板化

將整個流程沉澱為可復用的「專案初始化模板」。

---

## 建議解決流程

### 階段一：需求分析與架構設計（30 分鐘）

**目標**：將需求轉化為具體的基礎設施設計

```bash
# 切換到 DevOps 專家模式
/agents:devops-engineer

# 提供需求分析
我需要為一個新專案建立企業級開發環境。

## 專案資訊
- 後端：Python 3.11 + Flask
- 前端：React 18 + TypeScript
- 資料庫：PostgreSQL 15 + Redis 7
- 團隊規模：5-10 人

## 需求
1. 本地開發環境標準化（Docker Compose）
2. CI/CD 自動化（GitHub Actions）
3. 代碼品質檢查（Linting, Testing, Security）
4. 自動部署到測試環境
5. 完整的開發者文檔

請設計：
1. Docker 容器架構
2. CI/CD 管線流程圖
3. 開發 vs 生產環境的差異
4. 安全性考量
5. 實作優先順序

格式：Markdown + Mermaid 圖表
```

**預期輸出**：

````markdown
# 企業級開發環境架構設計

## 1. Docker 容器架構

### 1.1 開發環境架構

```mermaid
graph TB
    subgraph "Docker Compose 開發環境"
        Frontend[Frontend Container<br/>React + Vite<br/>Port: 5173]
        Backend[Backend Container<br/>Flask + Gunicorn<br/>Port: 5000]
        DB[(PostgreSQL<br/>Port: 5432)]
        Redis[(Redis<br/>Port: 6379)]
        Nginx[Nginx<br/>Reverse Proxy<br/>Port: 80]
    end

    Dev[開發者<br/>localhost] --> Nginx
    Nginx --> Frontend
    Nginx --> Backend
    Backend --> DB
    Backend --> Redis
    Frontend -.API 呼叫.-> Backend

    style Frontend fill:#61dafb
    style Backend fill:#3776ab
    style DB fill:#336791
    style Redis fill:#dc382d
```

**容器職責**：

- **frontend**:
  - 開發模式使用 Vite dev server（HMR）
  - 掛載本地程式碼（即時反映變更）
  - 執行 ESLint, Prettier

- **backend**:
  - Flask 開發伺服器（auto-reload）
  - 掛載本地程式碼
  - 執行 pytest, Black, Flake8

- **nginx**:
  - 反向代理（統一入口）
  - 靜態檔案服務（生產環境）
  - CORS 處理

- **postgres**:
  - 資料持久化（使用 volume）
  - 初始化腳本（建立測試資料）

- **redis**:
  - Session 儲存
  - 快取

### 1.2 生產環境差異

| 項目 | 開發環境 | 生產環境 |
|------|---------|---------|
| 前端 | Vite dev server | 靜態檔案（nginx） |
| 後端 | Flask dev server | Gunicorn (多 worker) |
| 資料庫 | 本地 Docker | AWS RDS / 託管服務 |
| 日誌 | stdout | CloudWatch / ELK |
| 監控 | 無 | Prometheus + Grafana |
| HTTPS | 無 | Let's Encrypt |

## 2. CI/CD 管線設計

### 2.1 流程圖

```mermaid
graph LR
    Push[Git Push] --> PR[Pull Request]
    PR --> Lint[代碼檢查<br/>Lint + Format]
    Lint --> Test[自動測試<br/>Backend + Frontend]
    Test --> Security[安全掃描<br/>Bandit + npm audit]
    Security --> Build[建置 Docker Image]
    Build --> Deploy[部署到測試環境]

    Deploy --> Manual{手動審核}
    Manual -->|批准| Prod[部署到生產環境]

    Lint -.失敗.-> Notify[通知開發者]
    Test -.失敗.-> Notify
    Security -.高風險.-> Block[阻擋合併]

    style Lint fill:#fff9c4
    style Test fill:#c8e6c9
    style Security fill:#ffccbc
    style Build fill:#e1bee7
    style Deploy fill:#b2dfdb
```

### 2.2 GitHub Actions Workflow

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]

jobs:
  # Job 1: Backend 檢查
  backend-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Lint with Flake8
        run: flake8 app tests

      - name: Format check with Black
        run: black --check app tests

      - name: Security scan with Bandit
        run: bandit -r app -f json -o bandit-report.json

      - name: Run tests with coverage
        run: |
          pytest --cov=app --cov-report=xml --cov-report=html

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3

  # Job 2: Frontend 檢查
  frontend-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Lint
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test -- --coverage

      - name: Security audit
        run: npm audit --audit-level=high

  # Job 3: 建置 Docker Image
  build:
    needs: [backend-checks, frontend-checks]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 4: 部署到測試環境
  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    steps:
      - name: Deploy to Staging
        run: |
          # 使用 SSH 或 Cloud CLI 部署
          echo "Deploying to staging..."
```

## 3. 安全性考量

### 3.1 機敏資料管理

**絕對不可**：
- ❌ 將密碼、API Key 寫入 git
- ❌ 在 Dockerfile 中硬編碼機敏資料
- ❌ 使用預設密碼

**正確做法**：
- ✅ 使用 `.env` 檔案（加入 `.gitignore`）
- ✅ GitHub Secrets 管理 CI/CD 機敏資料
- ✅ AWS Secrets Manager / HashiCorp Vault（生產環境）

### 3.2 Docker 安全

```dockerfile
# ❌ 錯誤：使用 root user
FROM python:3.11
COPY . /app
RUN pip install -r requirements.txt
CMD ["python", "app.py"]

# ✅ 正確：使用非特權使用者
FROM python:3.11-slim
RUN useradd -m -u 1000 appuser
WORKDIR /app
COPY --chown=appuser:appuser . .
USER appuser
RUN pip install --no-cache-dir -r requirements.txt
CMD ["gunicorn", "app:app"]
```

### 3.3 網路隔離

```yaml
# docker-compose.yml
services:
  backend:
    networks:
      - frontend-net
      - backend-net

  postgres:
    networks:
      - backend-net  # 只有後端可存取

  nginx:
    networks:
      - frontend-net  # 只對外暴露

networks:
  frontend-net:
  backend-net:
```

## 4. 實作優先順序

### Phase 1: 基礎環境（第 1 週）
- [ ] Docker Compose 開發環境
- [ ] 基本 Dockerfile（前後端）
- [ ] PostgreSQL + Redis 整合
- [ ] 環境變數管理

### Phase 2: CI/CD（第 2 週）
- [ ] GitHub Actions: Linting
- [ ] GitHub Actions: Testing
- [ ] GitHub Actions: Security Scan
- [ ] 自動建置 Docker Image

### Phase 3: 部署與監控（第 3-4 週）
- [ ] 自動部署到測試環境
- [ ] 日誌收集
- [ ] 基本監控（Healthcheck）
- [ ] 完整文檔

### Phase 4: 進階功能（未來）
- [ ] Prometheus + Grafana
- [ ] ELK Stack
- [ ] 自動擴展（K8s）

## 5. 成本評估

| 項目 | 工具 | 月成本（估算） |
|------|------|---------------|
| 代碼託管 | GitHub（Team Plan） | $4/人 |
| CI/CD | GitHub Actions（免費額度） | $0 |
| 測試環境 | AWS t3.medium | $30 |
| 資料庫 | AWS RDS t3.micro | $15 |
| 監控 | CloudWatch | $10 |
| **總計** | | **約 $100-150/月** |

---

**下一步**：根據此設計，開始生成具體設定檔
````

**記憶點**：
```bash
/memory save

主題：企業級開發環境設計原則

設計層次（由上而下）：
1. 需求分析 → 列出技術棧、團隊規模、品質要求
2. 架構設計 → 容器劃分、網路拓撲、CI/CD 流程
3. 安全設計 → 機敏資料、網路隔離、最小權限
4. 成本評估 → 工具選擇、資源規劃
5. 實作規劃 → 分階段實作、優先順序

關鍵決策點：
- 開發 vs 生產環境的差異
- CI/CD 工具選擇（GitHub Actions vs GitLab CI vs Jenkins）
- 容器編排（Docker Compose vs K8s）
- 監控方案（自建 vs 託管服務）

Mermaid 圖表應用：
- graph: 容器架構、網路拓撲
- flowchart: CI/CD 流程、部署流程
- sequenceDiagram: 部署步驟

相關 Agent: devops-engineer, architect, security-auditor
```

---

### 階段二：生成 Docker 環境設定（40 分鐘）

**目標**：產出可直接使用的 Dockerfile 與 docker-compose.yml

```bash
# 繼續使用 devops-engineer
請基於上述設計，生成以下檔案：

1. **backend/Dockerfile** （生產版本）
2. **backend/Dockerfile.dev** （開發版本）
3. **frontend/Dockerfile**
4. **frontend/Dockerfile.dev**
5. **docker-compose.yml** （開發環境）
6. **docker-compose.prod.yml** （生產環境）
7. **.dockerignore**

要求：
- 遵循 Docker 最佳實踐（多階段建置、層快取）
- 使用非 root 使用者
- 環境變數從 .env 讀取
- 包含健康檢查
- 加入詳細註解說明
```

**預期輸出**（部分範例）：

```dockerfile
# backend/Dockerfile（生產版本）

# ===========================
# Stage 1: Builder
# ===========================
FROM python:3.11-slim as builder

# 安裝編譯依賴
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 建立虛擬環境（隔離依賴）
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# 複製並安裝依賴（利用 Docker 層快取）
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ===========================
# Stage 2: Runtime
# ===========================
FROM python:3.11-slim

# 只安裝執行期依賴
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 建立非特權使用者
RUN useradd -m -u 1000 appuser

# 從 builder 複製虛擬環境
COPY --from=builder /opt/venv /opt/venv

# 設定工作目錄
WORKDIR /app

# 複製應用程式（使用 .dockerignore 排除不必要的檔案）
COPY --chown=appuser:appuser . .

# 切換到非特權使用者
USER appuser

# 設定環境變數
ENV PATH="/opt/venv/bin:$PATH" \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

# 暴露端口
EXPOSE 5000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD python -c "import requests; requests.get('http://localhost:5000/health')"

# 啟動指令（生產環境使用 Gunicorn）
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--timeout", "60", "app:app"]
```

```dockerfile
# backend/Dockerfile.dev（開發版本）

FROM python:3.11-slim

# 安裝開發工具
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    git \
    && rm -rf /var/lib/apt/lists/*

# 建立工作目錄
WORKDIR /app

# 安裝依賴（包含開發依賴）
COPY requirements.txt requirements-dev.txt ./
RUN pip install --no-cache-dir -r requirements.txt -r requirements-dev.txt

# 注意：程式碼透過 volume 掛載，不複製到 image

# 暴露端口（Flask 開發伺服器 + debugger）
EXPOSE 5000 5678

# 開發環境使用 Flask dev server（支援 auto-reload）
CMD ["flask", "run", "--host=0.0.0.0", "--port=5000", "--reload"]
```

```yaml
# docker-compose.yml（開發環境）

version: '3.8'

services:
  # ===========================
  # Backend (Flask)
  # ===========================
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    container_name: dev_backend
    volumes:
      # 掛載本地程式碼（即時反映變更）
      - ./backend:/app
      # 排除 Python cache（避免權限問題）
      - /app/__pycache__
      - /app/.pytest_cache
    ports:
      - "5000:5000"  # API
      - "5678:5678"  # Debugger (debugpy)
    environment:
      - FLASK_APP=app
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://devuser:devpass@postgres:5432/devdb
      - REDIS_URL=redis://redis:6379/0
      - SECRET_KEY=dev-secret-key-change-in-production
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - app-network
    command: >
      sh -c "
        echo 'Waiting for database...' &&
        flask db upgrade &&
        flask run --host=0.0.0.0 --port=5000 --reload
      "

  # ===========================
  # Frontend (React)
  # ===========================
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    container_name: dev_frontend
    volumes:
      - ./frontend:/app
      - /app/node_modules  # 避免覆蓋 node_modules
    ports:
      - "5173:5173"  # Vite dev server
    environment:
      - VITE_API_URL=http://localhost/api
    networks:
      - app-network
    command: npm run dev

  # ===========================
  # PostgreSQL
  # ===========================
  postgres:
    image: postgres:15-alpine
    container_name: dev_postgres
    environment:
      - POSTGRES_USER=devuser
      - POSTGRES_PASSWORD=devpass
      - POSTGRES_DB=devdb
    volumes:
      # 資料持久化
      - postgres_data:/var/lib/postgresql/data
      # 初始化腳本
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U devuser -d devdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ===========================
  # Redis
  # ===========================
  redis:
    image: redis:7-alpine
    container_name: dev_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network
    command: redis-server --appendonly yes

  # ===========================
  # Nginx (反向代理)
  # ===========================
  nginx:
    image: nginx:alpine
    container_name: dev_nginx
    volumes:
      - ./nginx/nginx.dev.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "80:80"
    depends_on:
      - backend
      - frontend
    networks:
      - app-network

# ===========================
# Volumes（資料持久化）
# ===========================
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

# ===========================
# Networks
# ===========================
networks:
  app-network:
    driver: bridge
```

```
# .dockerignore

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
.pytest_cache/
.coverage
htmlcov/

# Node
node_modules/
npm-debug.log
yarn-error.log
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Git
.git/
.gitignore

# Environment
.env
.env.local
.env.*.local

# Documentation
README.md
docs/

# CI/CD
.github/
.gitlab-ci.yml

# Logs
*.log
logs/
```

**使用方式說明**：

```bash
# 一鍵啟動開發環境
docker-compose up -d

# 查看日誌
docker-compose logs -f backend

# 進入容器執行指令
docker-compose exec backend flask shell
docker-compose exec backend pytest

# 停止環境
docker-compose down

# 完全清除（包含資料庫）
docker-compose down -v
```

---

### 階段三：生成 CI/CD 設定與腳本（40 分鐘）

**目標**：產出完整的 GitHub Actions workflow

```bash
請生成完整的 GitHub Actions workflow 檔案：

1. **.github/workflows/ci.yml** - 完整 CI 管線
2. **.github/workflows/deploy-staging.yml** - 部署到測試環境
3. **scripts/deploy.sh** - 部署腳本
4. **scripts/healthcheck.sh** - 健康檢查腳本

要求：
- 並行執行（backend 與 frontend 同時檢查）
- 包含測試覆蓋率上傳（Codecov）
- 安全掃描（Bandit, npm audit）
- 只在測試通過後才建置 Docker image
- 部署包含健康檢查與 rollback 機制
```

**預期輸出**（完整 CI workflow）：

```yaml
# .github/workflows/ci.yml

name: CI Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # ===========================
  # Backend Tests
  # ===========================
  backend:
    name: Backend Checks
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt -r requirements-dev.txt

      - name: Lint with Flake8
        run: |
          cd backend
          flake8 app tests --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 app tests --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Check code formatting with Black
        run: |
          cd backend
          black --check app tests

      - name: Type checking with mypy
        run: |
          cd backend
          mypy app --ignore-missing-imports

      - name: Security scan with Bandit
        run: |
          cd backend
          bandit -r app -f json -o bandit-report.json || true
          cat bandit-report.json

      - name: Run tests with coverage
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379/0
        run: |
          cd backend
          pytest \
            --cov=app \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --junit-xml=junit.xml \
            -v

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml
          flags: backend
          name: backend-coverage

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: backend-test-results
          path: backend/junit.xml

  # ===========================
  # Frontend Tests
  # ===========================
  frontend:
    name: Frontend Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Lint with ESLint
        run: |
          cd frontend
          npm run lint

      - name: Check code formatting with Prettier
        run: |
          cd frontend
          npm run format:check

      - name: Type checking
        run: |
          cd frontend
          npm run type-check

      - name: Run tests with coverage
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false

      - name: Security audit
        run: |
          cd frontend
          npm audit --audit-level=moderate || true

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/coverage-final.json
          flags: frontend
          name: frontend-coverage

  # ===========================
  # Build Docker Images
  # ===========================
  build:
    name: Build Docker Images
    needs: [backend, frontend]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository }}-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================
  # Security Scan (Trivy)
  # ===========================
  security-scan:
    name: Container Security Scan
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ghcr.io/${{ github.repository }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

**部署腳本範例**：

```bash
#!/bin/bash
# scripts/deploy.sh

set -e  # 遇到錯誤立即退出

# ===========================
# 設定
# ===========================
IMAGE_TAG=${1:-latest}
ENVIRONMENT=${2:-staging}
HEALTH_CHECK_URL="https://${ENVIRONMENT}.example.com/health"
MAX_RETRIES=10
RETRY_INTERVAL=10

echo "🚀 Starting deployment..."
echo "   Environment: $ENVIRONMENT"
echo "   Image Tag: $IMAGE_TAG"

# ===========================
# 備份當前版本（用於 rollback）
# ===========================
echo "📦 Backing up current version..."
docker-compose -f docker-compose.prod.yml ps -q > /tmp/previous_containers.txt

# ===========================
# 拉取新 image
# ===========================
echo "⬇️  Pulling new images..."
docker pull ghcr.io/your-org/your-repo:${IMAGE_TAG}

# ===========================
# 更新服務（零停機部署）
# ===========================
echo "🔄 Updating services..."
docker-compose -f docker-compose.prod.yml up -d --no-deps --build backend

# ===========================
# 健康檢查
# ===========================
echo "🏥 Running health checks..."
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
  if curl -f -s -o /dev/null "$HEALTH_CHECK_URL"; then
    echo "✅ Health check passed!"
    break
  else
    echo "⏳ Waiting for service to be healthy... ($((RETRY_COUNT + 1))/$MAX_RETRIES)"
    sleep $RETRY_INTERVAL
    RETRY_COUNT=$((RETRY_COUNT + 1))
  fi
done

if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
  echo "❌ Health check failed! Rolling back..."

  # Rollback
  docker-compose -f docker-compose.prod.yml up -d $(cat /tmp/previous_containers.txt)

  echo "🔙 Rollback completed"
  exit 1
fi

# ===========================
# 清理舊 containers
# ===========================
echo "🧹 Cleaning up old containers..."
docker system prune -f

echo "✅ Deployment completed successfully!"
```

**記憶沉澱**：
```bash
/memory save

主題：企業級 CI/CD 設計模式

CI Pipeline 結構：
1. 並行執行（backend + frontend 同時跑）
2. 階段分離（lint → test → security → build）
3. 條件執行（只在 push 時 build）
4. 結果上傳（coverage → Codecov, security → GitHub Security）

GitHub Actions 最佳實踐：
- 使用 cache 加速（pip cache, npm cache）
- services 啟動依賴服務（postgres, redis）
- 使用 matrix 測試多版本
- secrets 管理敏感資料
- artifacts 儲存測試報告

Docker Build 優化：
- 多階段建置（builder + runtime）
- BuildKit cache（cache-from, cache-to）
- 只複製必要檔案（.dockerignore）
- 非 root 使用者

部署安全機制：
- 健康檢查（curl health endpoint）
- Rollback 機制（保留舊容器資訊）
- 零停機部署（逐步更新）
- 部署後驗證

相關工具：
- GitHub Actions, Docker Buildx, Trivy
- Codecov, Bandit, ESLint
```

---

### 階段四：生成文檔與維護指南（20 分鐘）

**目標**：產出完整的開發者文檔

```bash
# 切換到 technical-writer
/agents:technical-writer

# 設定為教學風格
/output-style:tutorial

請生成以下文檔：

1. **README.md** - 專案總覽與快速開始
2. **docs/DEVELOPMENT.md** - 詳細開發指南
3. **docs/DEPLOYMENT.md** - 部署流程文檔
4. **docs/TROUBLESHOOTING.md** - 常見問題排除

要求：
- 包含可執行的指令
- 圖文並茂（使用 Mermaid）
- 涵蓋常見問題
- 給不同角色的使用者（開發者、DevOps、新人）
```

**預期輸出**（README 範例）：

```markdown
# Project Name

企業級 Web 應用程式範本（Python Flask + React）

## 快速開始（5 分鐘）

### 前置需求

- Docker Desktop 20+
- Git

### 一鍵啟動

```bash
# 1. Clone 專案
git clone https://github.com/your-org/your-repo.git
cd your-repo

# 2. 複製環境變數範本
cp .env.example .env

# 3. 啟動所有服務
docker-compose up -d

# 4. 驗證安裝
curl http://localhost/health
```

### 存取應用程式

- 🌐 **前端**: http://localhost
- 🔧 **API**: http://localhost/api
- 📊 **API 文檔**: http://localhost/api/docs
- 🗄️ **PostgreSQL**: localhost:5432
- 🔴 **Redis**: localhost:6379

### 預設帳號

- Email: `admin@example.com`
- Password: `admin123`（請立即變更）

## 專案結構

```
.
├── backend/               # Flask API
│   ├── app/              # 應用程式主目錄
│   │   ├── models/       # 資料模型
│   │   ├── routes/       # API 端點
│   │   ├── services/     # 業務邏輯
│   │   └── utils/        # 工具函數
│   ├── tests/            # 測試
│   ├── Dockerfile        # 生產環境
│   └── Dockerfile.dev    # 開發環境
│
├── frontend/             # React App
│   ├── src/
│   │   ├── components/   # React 元件
│   │   ├── pages/        # 頁面
│   │   └── api/          # API 呼叫
│   ├── Dockerfile
│   └── Dockerfile.dev
│
├── nginx/                # 反向代理設定
├── scripts/              # 部署與工具腳本
├── docs/                 # 詳細文檔
├── .github/workflows/    # CI/CD
└── docker-compose.yml    # 開發環境
```

## 開發工作流程

```mermaid
graph LR
    Dev[本地開發] --> Commit[Git Commit]
    Commit --> Push[Git Push]
    Push --> CI[CI 檢查]
    CI --> PR[Pull Request]
    PR --> Review[Code Review]
    Review --> Merge[合併到 main]
    Merge --> Deploy[自動部署]

    style CI fill:#c8e6c9
    style Deploy fill:#b2dfdb
```

### 開發指令

```bash
# 查看日誌
docker-compose logs -f backend
docker-compose logs -f frontend

# 進入容器執行指令
docker-compose exec backend flask shell
docker-compose exec backend pytest

# 執行 database migration
docker-compose exec backend flask db migrate -m "Add new table"
docker-compose exec backend flask db upgrade

# 重新建置（當 Dockerfile 變更時）
docker-compose up -d --build
```

## 測試

```bash
# Backend 測試
docker-compose exec backend pytest --cov=app

# Frontend 測試
docker-compose exec frontend npm test

# E2E 測試（需先啟動所有服務）
npm run test:e2e
```

## 部署

詳見 [部署文檔](docs/DEPLOYMENT.md)

### 快速部署到測試環境

```bash
# 使用部署腳本
./scripts/deploy.sh latest staging
```

## 技術棧

### 後端
- Python 3.11
- Flask 2.3
- SQLAlchemy 2.0
- PostgreSQL 15
- Redis 7

### 前端
- React 18
- TypeScript 5
- Vite 4
- TailwindCSS 3

### DevOps
- Docker & Docker Compose
- GitHub Actions
- Nginx

## 文檔

- [開發指南](docs/DEVELOPMENT.md) - 詳細開發流程
- [API 文檔](http://localhost/api/docs) - OpenAPI 規範
- [架構設計](docs/ARCHITECTURE.md) - 系統架構
- [部署指南](docs/DEPLOYMENT.md) - 生產環境部署
- [問題排除](docs/TROUBLESHOOTING.md) - 常見問題

## 貢獻

請閱讀 [CONTRIBUTING.md](CONTRIBUTING.md) 了解貢獻流程。

## 授權

MIT License - 詳見 [LICENSE](LICENSE)
```

---

## 驗證標準

### ✅ 必須達成

- [ ] Docker Compose 一鍵啟動成功
- [ ] 所有服務健康檢查通過
- [ ] CI/CD workflow 可執行
- [ ] 文檔清晰完整
- [ ] 使用 `/memory` 沉澱至少 3 個 DevOps 模式

### ⭐ 額外成就

- [ ] 整合 Prometheus + Grafana 監控
- [ ] 設定自動備份機制
- [ ] 建立 disaster recovery 計畫
- [ ] 支援多環境部署（dev/staging/prod）
- [ ] 整合 Kubernetes 部署選項

---

## 學習反思

### 反思問題

1. **架構設計**：
   - 為什麼要分開發和生產環境的 Dockerfile？
   - 多階段建置的優點是什麼？

2. **CI/CD 設計**：
   - 為什麼要並行執行測試？
   - 如何平衡 CI 速度與完整性？

3. **安全性**：
   - 哪些是最關鍵的安全檢查點？
   - 如何避免機敏資料外洩？

4. **可維護性**：
   - 如何確保文檔與程式碼同步？
   - 新人 onboarding 需要多久？

### 延伸練習

1. **監控與日誌**：
   - 整合 ELK Stack 或 Loki
   - 設定告警規則（PagerDuty, Slack）

2. **進階部署**：
   - 藍綠部署
   - 金絲雀發布
   - Kubernetes Helm Charts

3. **效能優化**：
   - Redis 快取策略
   - Database 連線池調整
   - CDN 整合

---

## 相關資源

### 下一步學習

- **C19**：技術債務重構計畫 - 維護既有系統
- **E02**：AI Code Review 系統 - 整合到 CI/CD
- **E04**：團隊開發工具鏈設計 - 更大規模的基礎設施

### 工具參考

- **Docker Best Practices**: https://docs.docker.com/develop/dev-best-practices/
- **GitHub Actions**: https://docs.github.com/actions
- **12-Factor App**: https://12factor.net/
- **Kubernetes**: https://kubernetes.io/docs/

---

**建議完成時間**：2.5-3 小時
**難度評估**：4/5
**重要度**：5/5（企業級專案的基礎）
**可復用性**：5/5（可作為所有新專案的範本）
