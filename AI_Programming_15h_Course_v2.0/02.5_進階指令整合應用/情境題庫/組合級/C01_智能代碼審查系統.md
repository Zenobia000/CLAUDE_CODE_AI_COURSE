# C01：智能代碼審查系統（組合級）

## 情境資訊

**編號**：C01
**難度**：⭐⭐⭐☆☆（組合級）
**預計時間**：2 小時
**學習目標**：
- 掌握多 Agent 協作流程
- 理解代碼審查的系統化方法
- 學會安全漏洞自動檢測
- 建立審查報告生成工作流

**適用對象**：
- 完成模組 2 與 2.5 基礎級情境
- 理解安全審計基本概念
- 需要建立團隊代碼審查標準

---

## 情境描述

### 背景

你在一家金融科技公司擔任技術主管，團隊每週需要審查大量程式碼變更。手動審查耗時且容易遺漏問題，你決定建立一套智能代碼審查系統，整合安全檢測、品質分析和最佳實踐建議。

### 現有問題

你接手了一個支付處理模組，需要在合併到主分支前完成全面審查。這是一個關鍵模組，處理用戶的敏感金融資料。

### 待審查的程式碼

```python
# src/payment_processor.py

import sqlite3
import hashlib
import json
from datetime import datetime

class PaymentProcessor:
    """支付處理器"""

    def __init__(self, db_path='payments.db'):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.setup_database()

    def setup_database(self):
        """初始化資料庫"""
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS payments (
                id INTEGER PRIMARY KEY,
                user_id TEXT,
                card_number TEXT,
                cvv TEXT,
                amount REAL,
                created_at TEXT
            )
        """)
        self.conn.commit()

    def process_payment(self, user_id, card_number, cvv, amount):
        """處理支付"""
        # 驗證金額
        if amount <= 0:
            return {"success": False, "error": "Invalid amount"}

        # 儲存支付記錄
        cursor = self.conn.cursor()
        query = f"""
            INSERT INTO payments (user_id, card_number, cvv, amount, created_at)
            VALUES ('{user_id}', '{card_number}', '{cvv}', {amount}, '{datetime.now()}')
        """
        cursor.execute(query)
        self.conn.commit()

        # 呼叫第三方支付 API
        result = self._call_payment_gateway(card_number, cvv, amount)
        return result

    def _call_payment_gateway(self, card_number, cvv, amount):
        """呼叫支付閘道（模擬）"""
        # TODO: 實作真實的 API 呼叫
        return {"success": True, "transaction_id": "TXN123"}

    def get_user_payments(self, user_id):
        """取得使用者的支付記錄"""
        cursor = self.conn.cursor()
        query = f"SELECT * FROM payments WHERE user_id = '{user_id}'"
        cursor.execute(query)
        results = cursor.fetchall()
        return results

    def refund_payment(self, payment_id):
        """退款處理"""
        cursor = self.conn.cursor()
        query = f"DELETE FROM payments WHERE id = {payment_id}"
        cursor.execute(query)
        self.conn.commit()
        return {"success": True}

    def generate_report(self, start_date, end_date):
        """生成報表"""
        cursor = self.conn.cursor()
        query = f"""
            SELECT user_id, SUM(amount) as total
            FROM payments
            WHERE created_at BETWEEN '{start_date}' AND '{end_date}'
            GROUP BY user_id
        """
        cursor.execute(query)
        return cursor.fetchall()
```

### 你的任務

建立一套完整的智能代碼審查流程，包含：
1. **安全漏洞掃描**：識別 SQL Injection、敏感資料暴露等
2. **代碼品質分析**：檢查程式結構、命名規範、錯誤處理
3. **最佳實踐建議**：提供改進方案
4. **生成審查報告**：產出結構化的審查文件

---

## 學習重點

### 目標 1：多 Agent 協作流程設計

理解如何組織不同專業 Agent 完成複雜任務：
- security-auditor：安全掃描
- code-reviewer：品質分析
- architect：架構建議
- technical-writer：報告生成

### 目標 2：系統化問題識別

學會從不同維度分析程式碼：
- **安全性**：漏洞、敏感資料處理
- **可靠性**：錯誤處理、邊界情況
- **可維護性**：程式結構、文檔
- **效能**：資源管理、查詢優化

### 目標 3：知識沉澱機制

使用 `/memory` 指令建立審查模式庫：
- 常見漏洞模式
- 修復方案範本
- 審查檢查清單

### 目標 4：自動化報告生成

使用 `/output-style` 生成專業報告：
- 執行摘要
- 問題分類與優先級
- 修復建議與範例
- 風險評估

---

## 建議解決流程

### 階段一：安全漏洞深度掃描（30 分鐘）

**目標**：識別所有安全風險點

```bash
# 切換到安全專家模式
/agents:security-auditor

# 提供審查指令
請對 src/payment_processor.py 進行全面安全審計。

重點關注：
1. SQL Injection 漏洞
2. 敏感資料處理（信用卡號、CVV）
3. 身份驗證與授權
4. 資料庫連線安全
5. 錯誤訊息洩漏
6. 第三方 API 呼叫安全性

請列出所有發現的問題，並標註嚴重程度（Critical/High/Medium/Low）。
```

**預期輸出**：

```markdown
# 安全審計報告

## Critical 嚴重問題

### 1. SQL Injection 漏洞（多處）
**位置**：process_payment(), get_user_payments(), generate_report()
**問題**：使用字串格式化直接組合 SQL 查詢
**範例**：
```python
query = f"SELECT * FROM payments WHERE user_id = '{user_id}'"
```
**風險**：攻擊者可以注入惡意 SQL，存取或刪除所有資料
**修復建議**：使用參數化查詢

### 2. 明文儲存敏感資料
**位置**：setup_database(), process_payment()
**問題**：信用卡號和 CVV 以明文儲存在資料庫
**風險**：違反 PCI DSS 標準，資料外洩時直接暴露
**修復建議**：
- 不應儲存 CVV（PCI DSS 禁止）
- 信用卡號必須加密或 tokenize
- 使用專業的支付處理服務

## High 高風險問題

### 3. 缺乏輸入驗證
**位置**：process_payment()
**問題**：未驗證 card_number 和 CVV 格式
**修復建議**：添加 Luhn 算法驗證、格式檢查

### 4. 資料庫連線未關閉
**位置**：__init__()
**問題**：連線在物件生命週期中一直開啟
**風險**：連線洩漏、資源耗盡
**修復建議**：使用 context manager

## Medium 中風險問題

### 5. 缺乏異常處理
**位置**：所有方法
**問題**：資料庫操作可能拋出異常但未捕捉
**修復建議**：添加 try-except 並記錄錯誤
```

**自然學到的知識點**：
- 為什麼需要專業的安全 Agent？因為安全問題需要系統化檢查，單靠人工容易遺漏
- SQL Injection 的多種形式
- PCI DSS 對支付資料的要求

**記憶沉澱**：
```bash
/memory save

主題：SQL Injection 檢測模式

內容：
在 Python 程式碼中，以下模式極可能存在 SQL Injection：
1. f-string 或 % 格式化組合 SQL：query = f"SELECT * FROM {table} WHERE id = '{user_input}'"
2. 字串拼接：query = "SELECT * FROM users WHERE name = '" + name + "'"

安全做法：
1. 使用參數化查詢：cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
2. 使用 ORM（如 SQLAlchemy）
3. 輸入驗證與白名單

相關工具：security-auditor agent
```

---

### 階段二：代碼品質全面分析（30 分鐘）

**目標**：評估程式結構與可維護性

```bash
# 切換到代碼審查專家
/agents:code-reviewer

# 審查指令
請對 src/payment_processor.py 進行代碼品質審查。

關注點：
1. 程式結構與職責劃分
2. 錯誤處理完整性
3. 命名規範
4. 文檔字串品質
5. 測試友善性
6. 依賴管理

請提供改進建議，並評分（1-10）。
```

**預期輸出**：

```markdown
# 代碼品質審查報告

**整體評分**：4/10（需大幅改進）

## 架構問題

### 1. 單一職責原則違反
**問題**：PaymentProcessor 同時處理：
- 資料庫操作
- 業務邏輯
- 第三方 API 呼叫

**建議重構**：
```python
# 職責分離
class PaymentRepository:
    """資料持久層"""
    pass

class PaymentService:
    """業務邏輯層"""
    pass

class PaymentGateway:
    """第三方 API 層"""
    pass
```

### 2. 缺乏抽象層
**問題**：直接依賴 sqlite3，難以切換資料庫或測試
**建議**：引入 Repository Pattern 或使用 ORM

## 錯誤處理問題

### 3. 無異常處理
**問題**：所有資料庫操作都可能失敗，但未捕捉
**範例**：
```python
# 現況（危險）
cursor.execute(query)

# 應該這樣
try:
    cursor.execute(query)
except sqlite3.Error as e:
    logger.error(f"Database error: {e}")
    raise PaymentProcessingError("Failed to process payment")
```

### 4. 錯誤回傳不一致
**問題**：process_payment() 回傳 dict，但其他方法回傳 tuple 或 bool
**建議**：統一使用 Result 物件或 dataclass

## 命名與文檔

### 5. 文檔字串過於簡略
**問題**：未說明參數、回傳值、可能的異常
**建議**：使用 Google/NumPy style docstring

### 6. 魔術字串與硬編碼
**問題**：日期格式、錯誤訊息散落各處
**建議**：使用常數或設定檔

## 測試友善性

### 7. 難以測試
**問題**：
- 直接在 __init__ 建立資料庫連線
- 沒有依賴注入
- _call_payment_gateway 難以 mock

**建議**：
```python
def __init__(self, db_connection, payment_gateway):
    self.db = db_connection
    self.gateway = payment_gateway
```
```

**自然學到的概念**：
- 為什麼切換 Agent？因為安全專家和代碼審查專家關注的面向不同
- 單一職責原則在實務中的應用
- 測試友善設計的重要性

---

### 階段三：架構改進建議（30 分鐘）

**目標**：提供系統化的重構方案

```bash
# 切換到架構師視角
/agents:architect

# 提供背景與問題
基於以下發現的問題，請設計改進後的架構：

安全問題：
- SQL Injection
- 明文儲存敏感資料
- 缺乏輸入驗證

品質問題：
- 職責不清
- 缺乏抽象
- 難以測試

需求：
- 符合 PCI DSS 標準
- 可測試性
- 可擴展（未來可能支援多種支付閘道）
- 容易維護

請提供：
1. 重構後的架構設計
2. 類別圖與職責說明
3. 關鍵設計模式
4. 遷移策略（如何從現有程式碼安全遷移）
```

**預期輸出**：

```markdown
# 架構改進方案

## 設計原則

1. **分層架構（Layered Architecture）**
   - Presentation Layer（未來的 API）
   - Application Layer（業務邏輯）
   - Domain Layer（領域模型）
   - Infrastructure Layer（資料庫、外部服務）

2. **領域驅動設計（DDD）概念**
   - Payment：值物件（Value Object）
   - PaymentService：應用服務
   - PaymentRepository：倉儲

## 重構後架構

```python
# domain/models.py
from dataclasses import dataclass
from decimal import Decimal
from typing import Optional

@dataclass(frozen=True)
class CardToken:
    """加密的信用卡 Token（不儲存真實卡號）"""
    token: str
    last_four_digits: str
    expiry_month: int
    expiry_year: int

@dataclass
class Payment:
    """支付領域模型"""
    id: Optional[int]
    user_id: str
    card_token: CardToken
    amount: Decimal
    status: str  # pending, completed, failed, refunded
    transaction_id: Optional[str]
    created_at: datetime

    def is_refundable(self) -> bool:
        """業務規則：只有已完成的支付可以退款"""
        return self.status == 'completed'

# infrastructure/repositories.py
from abc import ABC, abstractmethod

class PaymentRepository(ABC):
    """支付倉儲介面"""

    @abstractmethod
    def save(self, payment: Payment) -> Payment:
        pass

    @abstractmethod
    def find_by_id(self, payment_id: int) -> Optional[Payment]:
        pass

    @abstractmethod
    def find_by_user_id(self, user_id: str) -> List[Payment]:
        pass

class SQLitePaymentRepository(PaymentRepository):
    """SQLite 實作（使用參數化查詢）"""

    def save(self, payment: Payment) -> Payment:
        query = """
            INSERT INTO payments (user_id, card_token, amount, status, created_at)
            VALUES (?, ?, ?, ?, ?)
        """
        cursor = self.conn.cursor()
        cursor.execute(query, (
            payment.user_id,
            payment.card_token.token,  # 已加密的 token
            str(payment.amount),
            payment.status,
            payment.created_at.isoformat()
        ))
        # ...

# infrastructure/payment_gateway.py
class PaymentGateway(ABC):
    """支付閘道介面"""

    @abstractmethod
    def charge(self, card_token: CardToken, amount: Decimal) -> PaymentResult:
        pass

class StripeGateway(PaymentGateway):
    """Stripe 實作"""
    pass

# application/services.py
class PaymentService:
    """支付應用服務"""

    def __init__(
        self,
        repository: PaymentRepository,
        gateway: PaymentGateway,
        tokenizer: CardTokenizer,  # 負責加密信用卡
        logger: Logger
    ):
        self.repository = repository
        self.gateway = gateway
        self.tokenizer = tokenizer
        self.logger = logger

    def process_payment(
        self,
        user_id: str,
        card_number: str,
        cvv: str,
        amount: Decimal
    ) -> Result[Payment]:
        """處理支付（含完整錯誤處理）"""
        try:
            # 1. 輸入驗證
            self._validate_payment_input(card_number, cvv, amount)

            # 2. 將信用卡資訊轉換為 Token（不儲存原始資料）
            card_token = self.tokenizer.tokenize(card_number, cvv)

            # 3. 建立支付物件
            payment = Payment(
                id=None,
                user_id=user_id,
                card_token=card_token,
                amount=amount,
                status='pending',
                transaction_id=None,
                created_at=datetime.utcnow()
            )

            # 4. 呼叫支付閘道
            result = self.gateway.charge(card_token, amount)

            # 5. 更新狀態並儲存
            if result.success:
                payment.status = 'completed'
                payment.transaction_id = result.transaction_id
            else:
                payment.status = 'failed'

            saved_payment = self.repository.save(payment)

            return Result.success(saved_payment)

        except ValidationError as e:
            self.logger.warning(f"Validation failed: {e}")
            return Result.failure(f"Invalid input: {e}")
        except GatewayError as e:
            self.logger.error(f"Gateway error: {e}")
            return Result.failure("Payment processing failed")
        except Exception as e:
            self.logger.critical(f"Unexpected error: {e}")
            return Result.failure("System error")
```

## 關鍵設計模式

1. **Repository Pattern**：抽象資料存取
2. **Dependency Injection**：提升測試性
3. **Value Object**：CardToken 不可變
4. **Strategy Pattern**：可替換的 PaymentGateway
5. **Result Pattern**：明確的錯誤處理

## 安全改進

1. **永不儲存 CVV**：PCI DSS 要求
2. **信用卡 Tokenization**：使用第三方服務（如 Stripe）
3. **參數化查詢**：防止 SQL Injection
4. **最小權限原則**：資料庫帳號只能執行必要操作

## 遷移策略

### Phase 1：建立新架構（不影響現有程式）
- 實作新的 domain models
- 實作新的 repository
- 寫測試

### Phase 2：並行運作（Feature Flag）
- 使用 feature flag 切換新舊實作
- 監控錯誤與效能

### Phase 3：資料遷移
- 將現有資料轉換為 token（需與支付閘道合作）
- 刪除明文信用卡資料

### Phase 4：移除舊程式碼
- 確認新架構穩定後，移除舊程式
```

**自然學到的模式**：
- Repository Pattern 的實際應用
- 為什麼需要 architect agent？因為需要系統化的設計思維
- 如何在不停機的情況下重構關鍵系統

**記憶點**：
```bash
/memory save

主題：安全支付系統設計模式

核心原則：
1. 永不儲存完整信用卡號和 CVV
2. 使用 Tokenization 服務（Stripe, Braintree）
3. 參數化查詢防止 SQL Injection
4. 分層架構：Domain → Application → Infrastructure

設計模式組合：
- Repository Pattern：抽象資料存取
- Dependency Injection：依賴外部注入
- Strategy Pattern：可替換的支付閘道
- Result Pattern：明確錯誤處理

遷移策略：
- Feature Flag 控制新舊切換
- 並行運作驗證
- 分階段遷移資料

相關 Agent：architect, security-auditor
```

---

### 階段四：生成審查報告（30 分鐘）

**目標**：產出專業的審查文件

```bash
# 切換到技術寫作專家
/agents:technical-writer

# 設定輸出格式
/output-style:security-report

# 請求報告生成
請基於以上所有分析，生成一份完整的「代碼審查報告」。

報告應包含：
1. 執行摘要（Executive Summary）
   - 審查範圍
   - 總體評級
   - 關鍵發現

2. 問題清單（按嚴重程度分類）
   - Critical/High/Medium/Low
   - 每個問題包含：位置、描述、風險、修復建議

3. 架構改進建議
   - 重構方案概述
   - 設計模式建議
   - 遷移路徑

4. 行動計畫（Action Items）
   - 必須立即修復（Critical）
   - 短期改進（1-2 週）
   - 長期重構（1-3 個月）

5. 附錄
   - 程式碼範例
   - 參考資料
   - 檢查清單

格式：Markdown，適合轉換為 PDF 給管理層
```

**預期輸出**：

```markdown
# 代碼審查報告：PaymentProcessor 模組

**審查日期**：2025-01-15
**審查範圍**：src/payment_processor.py
**審查者**：AI Code Review System
**狀態**：❌ 不建議合併（需重大修改）

---

## 執行摘要

### 審查結論

本次審查發現 **5 個 Critical 問題、3 個 High 問題、4 個 Medium 問題**。

**總體評級**：🔴 **不及格（2/10）**

**核心問題**：
1. 多處 SQL Injection 漏洞（Critical）
2. 明文儲存敏感金融資料（Critical）
3. 違反 PCI DSS 安全標準（Critical）

**建議**：
- ❌ 不可合併到生產環境
- ⚠️ 建議完全重構
- ✅ 已提供完整改進方案

### 風險評估

| 風險類型 | 嚴重程度 | 可能影響 |
|---------|---------|---------|
| 資料外洩 | Critical | 所有用戶信用卡資料可能被竊取 |
| SQL Injection | Critical | 資料庫可能被惡意操作或刪除 |
| 法規違規 | Critical | 違反 PCI DSS，可能被罰款或禁止處理支付 |
| 系統不穩定 | High | 缺乏錯誤處理，可能造成服務中斷 |

---

## 問題詳細清單

### 🔴 Critical（必須立即修復）

#### C-1: SQL Injection 漏洞（3 處）

**位置**：
- Line 34: `process_payment()`
- Line 46: `get_user_payments()`
- Line 56: `generate_report()`

**程式碼範例**：
```python
# ❌ 危險
query = f"SELECT * FROM payments WHERE user_id = '{user_id}'"
cursor.execute(query)
```

**風險**：
攻擊者可以構造惡意輸入：
```python
user_id = "' OR '1'='1"
# 導致查詢變成：SELECT * FROM payments WHERE user_id = '' OR '1'='1'
# 結果：洩漏所有用戶的支付記錄
```

**修復方案**：
```python
# ✅ 安全
query = "SELECT * FROM payments WHERE user_id = ?"
cursor.execute(query, (user_id,))
```

**責任人**：Backend Team
**期限**：立即（24小時內）
**驗證方式**：SQLMap 掃描通過

---

#### C-2: 明文儲存信用卡資料

**位置**：Line 18 (setup_database), Line 34 (process_payment)

**問題**：
```python
CREATE TABLE payments (
    card_number TEXT,  # ❌ 明文儲存
    cvv TEXT,          # ❌ 絕對禁止儲存
    ...
)
```

**法規要求**：
- PCI DSS 3.2.1 禁止儲存 CVV
- 信用卡號必須加密或使用 Token

**修復方案**：
1. 整合 Stripe/Braintree 的 Tokenization API
2. 只儲存 Token 和後四碼
3. 清除現有明文資料

**範例**：
```python
# ✅ 使用 Stripe
import stripe

token = stripe.Token.create(
    card={
        "number": card_number,
        "exp_month": exp_month,
        "exp_year": exp_year,
        "cvc": cvv,
    }
)

# 只儲存 token.id，永不儲存原始資料
```

**責任人**：Security Team + Backend Team
**期限**：立即（48小時內）
**成本估算**：需採購 Stripe 服務

---

（其他 Critical 問題...）

### 🟠 High（2 週內修復）

#### H-1: 缺乏輸入驗證

（詳細描述...）

### 🟡 Medium（1 個月內改進）

#### M-1: 缺乏錯誤處理

（詳細描述...）

---

## 架構改進建議

### 現有架構問題

```
┌─────────────────────────┐
│  PaymentProcessor       │
│  (God Object)           │
│                         │
│  - Database Operations  │
│  - Business Logic       │
│  - API Calls            │
│  - Validation           │
└─────────────────────────┘
```

**問題**：單一類別承擔過多職責，難以測試與維護

### 建議架構

```
┌──────────────────┐
│  PaymentService  │  ← 應用層（業務邏輯）
└────────┬─────────┘
         │
    ┌────┴────┐
    │         │
┌───▼────┐ ┌─▼──────────┐
│Payment │ │Payment     │  ← 領域層
│        │ │Gateway     │
└───┬────┘ └─┬──────────┘
    │        │
┌───▼────────▼──────┐
│ Repository        │  ← 基礎設施層
│ (Parameterized)   │
└───────────────────┘
```

**優點**：
- 分層清晰，職責單一
- 依賴注入，易於測試
- 安全性內建於架構

**實作範例**：（見階段三完整程式碼）

---

## 行動計畫

### 🚨 Phase 0：緊急修復（24-48 小時）

- [ ] **立即**：停止合併此 PR
- [ ] **立即**：修復所有 SQL Injection（改用參數化查詢）
- [ ] **立即**：移除 CVV 儲存
- [ ] **48 小時內**：整合信用卡 Tokenization 服務
- [ ] **48 小時內**：加密現有資料庫中的敏感資料（或轉為 Token 後刪除）

### 📋 Phase 1：短期改進（1-2 週）

- [ ] 實作輸入驗證（Luhn 算法、格式檢查）
- [ ] 添加完整的異常處理
- [ ] 統一錯誤回傳格式
- [ ] 添加單元測試（覆蓋率 > 80%）
- [ ] 設定 SQL 資料庫帳號最小權限

### 🏗️ Phase 2：架構重構（1-3 個月）

- [ ] 實作分層架構
- [ ] 引入 Repository Pattern
- [ ] 實作 PaymentGateway 介面（支援多種閘道）
- [ ] 建立領域模型（Payment, CardToken）
- [ ] 使用 Feature Flag 逐步遷移
- [ ] 達到測試覆蓋率 > 95%

### 📊 Phase 3：持續改進

- [ ] 建立自動化代碼審查流程
- [ ] 整合 SAST 工具（如 Bandit, SonarQube）
- [ ] 定期進行滲透測試
- [ ] PCI DSS 認證稽核

---

## 附錄

### A. 完整修復程式碼範例

（見階段三的完整架構程式碼）

### B. 參考資料

1. **PCI DSS 3.2.1 標準**
   - https://www.pcisecuritystandards.org/

2. **OWASP Top 10**
   - SQL Injection: https://owasp.org/www-project-top-ten/
   - Sensitive Data Exposure

3. **Python 安全最佳實踐**
   - Bandit: https://bandit.readthedocs.io/
   - SQLAlchemy 防注入: https://docs.sqlalchemy.org/

4. **設計模式**
   - Repository Pattern
   - Dependency Injection in Python

### C. 審查檢查清單

#### 安全性
- [x] SQL Injection 檢查
- [x] 敏感資料處理
- [ ] 身份驗證與授權（本次未涵蓋）
- [x] 錯誤訊息洩漏
- [ ] CSRF 防護（本次未涵蓋）

#### 程式碼品質
- [x] 單一職責原則
- [x] 錯誤處理
- [x] 測試友善性
- [x] 文檔完整性
- [x] 依賴管理

#### 架構
- [x] 分層架構
- [x] 抽象與介面
- [x] 設計模式應用
- [x] 可擴展性

---

**報告結論**：

本次審查發現多項嚴重安全漏洞與架構問題。**強烈不建議**在未完成 Critical 問題修復前合併此程式碼到生產環境。

已提供完整的修復方案與架構改進建議，預估需要 1-3 個月完成完整重構。建議採用 Feature Flag 與分階段遷移策略，確保業務連續性。

**下一步行動**：
1. 召開緊急會議，討論修復時間表
2. 分配責任人與資源
3. 建立每週進度檢查機制

---

**產生時間**：2025-01-15 14:30 UTC
**審查系統版本**：Claude Code AI Review v1.0
```

**自然學到的工作流程**：
- 為什麼需要 technical-writer agent？因為專業報告需要清晰的結構與表達
- 如何將技術發現轉化為管理層可理解的報告
- `/output-style:security-report` 的威力

**最終記憶沉澱**：
```bash
/memory save

主題：完整代碼審查工作流程（AI Agent 協作模式）

工作流程（4階段）：

1️⃣ 安全掃描（security-auditor）
   - 識別 SQL Injection, XSS, 敏感資料
   - 標註嚴重程度（Critical/High/Medium/Low）
   - 產出：安全問題清單

2️⃣ 品質分析（code-reviewer）
   - 檢查架構、錯誤處理、命名、文檔
   - 評估可測試性與可維護性
   - 產出：品質問題清單 + 評分

3️⃣ 架構設計（architect）
   - 基於問題設計改進方案
   - 選擇合適的設計模式
   - 規劃遷移策略
   - 產出：重構方案 + 程式碼範例

4️⃣ 報告生成（technical-writer + output-style）
   - 整合所有發現
   - 產出結構化報告
   - 包含：摘要、問題清單、修復建議、行動計畫

記憶點：
- 不同 Agent 關注不同面向，需系統化組合
- 使用 /memory 在各階段間傳遞知識
- /output-style 控制最終產出格式

時間分配：
- 安全掃描：30 min
- 品質分析：30 min
- 架構設計：30 min
- 報告生成：30 min
- 總計：2 小時
```

---

## 驗證標準

### ✅ 必須達成

- [ ] 成功完成四階段審查流程
- [ ] 識別所有 SQL Injection 漏洞
- [ ] 識別敏感資料處理問題
- [ ] 提供可執行的重構方案
- [ ] 生成結構化的審查報告
- [ ] 使用 `/memory` 沉澱至少 3 個知識點

### ⭐ 額外成就

- [ ] 發現超過 10 個問題
- [ ] 提供完整的測試程式碼範例
- [ ] 生成可直接使用的遷移計畫
- [ ] 建立自動化審查腳本（結合 Bash + Bandit）
- [ ] 設計 GitHub Action workflow 自動執行審查

---

## 學習反思

### 反思問題

1. **Agent 協作**：
   - 四個 Agent 的分工是否清晰？
   - 如果只用一個 Agent，會缺少什麼？

2. **流程設計**：
   - 為什麼要分階段，而不是一次完成？
   - 每個階段的輸出如何影響下一階段？

3. **知識沉澱**：
   - `/memory` 在哪些時機點最有價值？
   - 如何組織記憶以便未來檢索？

4. **實際應用**：
   - 如果要整合到 CI/CD，哪些部分可以自動化？
   - 如何平衡完整性與速度？

### 延伸練習

1. **自動化整合**：
   - 撰寫 GitHub Action，在 PR 時自動執行此審查流程
   - 將報告發布到 PR comment

2. **擴展審查範圍**：
   - 添加 API 安全審查（OWASP API Top 10）
   - 添加效能分析（profiling）
   - 添加授權與身份驗證檢查

3. **建立團隊標準**：
   - 基於此流程，建立團隊的代碼審查檢查清單
   - 設計審查範本（Template）

---

## 相關資源

### 下一步學習

- **C03**：自動化文檔生成 - 學習 technical-writer 深度應用
- **C11**：企業級開發環境搭建 - 整合 SAST 工具到 CI/CD
- **C19**：技術債務重構計畫 - 大規模重構的系統化方法

### 工具參考

- **Bandit**：Python 安全掃描器（可整合到自動化流程）
- **SonarQube**：代碼品質持續檢測
- **SQLMap**：SQL Injection 掃描工具
- **Stripe/Braintree**：支付 Tokenization 服務

### 學習資源

- **PCI DSS 3.2.1**：支付行業安全標準
- **OWASP Top 10**：十大安全風險
- **Clean Architecture（Robert C. Martin）**：架構設計原則
- **Refactoring（Martin Fowler）**：重構模式

---

**建議完成時間**：2-3 小時（含延伸思考）
**難度評估**：3/5
**重要度**：5/5（企業級必備技能）
**可複用性**：5/5（此流程可直接應用到任何代碼審查）
