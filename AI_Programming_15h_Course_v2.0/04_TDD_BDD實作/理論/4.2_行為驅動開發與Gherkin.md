# 4.2 行為驅動開發與 Gherkin

## 📋 內容概述

本章探討行為驅動開發（BDD）與 Gherkin 語法，學習如何用「業務語言」撰寫可執行的規範。

**閱讀時間**：45 分鐘
**實作時間**：60-90 分鐘（跟著範例實作）

---

## 🎯 學習目標

- 理解 BDD 的核心理念
- 掌握 Gherkin Given-When-Then 語法
- 能從使用者故事推導 BDD 場景
- 用 AI 將 Gherkin 轉換為可執行測試
- 理解 BDD 與 TDD 的協同使用

---

## 第一部分：什麼是 BDD？

### 定義

**BDD（Behavior-Driven Development）**：
> 一種軟體開發方法，用「業務語言」描述軟體行為，讓所有人（開發者、測試、PM、客戶）都能理解和參與。

### BDD 的核心理念

#### 理念 1：共同語言

```
傳統開發：
PM  ：「用戶可以加入商品到購物車」
開發 ：「所以要實作 ShoppingCart.addItem() 方法」
測試 ：「我要測試 cart.items.length 增加 1」

三個人說三種語言，容易誤解！
```

```
BDD：
所有人：「Given 用戶在商品頁面
        When 用戶點擊『加入購物車』
        Then 購物車中應該有該商品」

所有人說同一種語言，沒有誤解！
```

#### 理念 2：需求即測試

```
傳統：
1. PM 寫需求文件（Word/Confluence）
2. 開發實作功能
3. 測試另外寫測試
4. 文件、程式碼、測試不同步

BDD：
1. 所有人一起寫 Gherkin 規範
2. 規範就是測試
3. 規範就是文檔
4. 永遠同步（因為是同一份）
```

#### 理念 3：Outside-In（由外而內）

```
TDD：從單元測試開始（由內而外）
     測試 createTask() 方法 → 實作 → 測試 completeTask() → ...

BDD：從使用者場景開始（由外而內）
     場景：用戶完成任務 → 細化 → 實作 → 驗證
```

---

### BDD vs TDD：什麼時候用哪個？

#### TDD（測試驅動開發）

**最適合**：
- ✅ 開發核心業務邏輯
- ✅ 演算法和資料結構
- ✅ 工具函數和 utilities
- ✅ 底層模組（不直接面對使用者）

**範例**：
```python
# TDD 風格：測試內部邏輯
def test_calculate_discount_for_vip_customer():
    calculator = PriceCalculator()
    price = calculator.calculate_price(
        original_price=1000,
        customer_type='VIP',
        quantity=5
    )
    assert price == 850  # 15% VIP 折扣
```

#### BDD（行為驅動開發）

**最適合**：
- ✅ 使用者可見的功能
- ✅ 需要與非技術人員溝通
- ✅ 驗收測試
- ✅ E2E（端對端）測試

**範例**：
```gherkin
# BDD 風格：描述使用者行為
Scenario: VIP 客戶購買多件商品獲得折扣
  Given 我是 VIP 客戶
  And 我的購物車有 5 件商品
  And 每件商品原價 200 元
  When 我結帳
  Then 我應該支付 850 元
  And 我應該看到「VIP 折扣已套用」訊息
```

#### 混合使用（推薦）

```
專案結構：
├── features/              # BDD 驗收測試
│   ├── checkout.feature   # 描述結帳流程（使用者視角）
│   └── cart.feature       # 描述購物車行為
│
└── tests/                 # TDD 單元測試
    ├── test_price_calculator.py  # 測試價格計算邏輯
    ├── test_discount_rules.py    # 測試折扣規則
    └── test_cart_service.py      # 測試購物車服務

BDD 確保「做對的事」
TDD 確保「把事做對」
```

---

## 第二部分：Gherkin 語法速成

### 核心結構：Given-When-Then

#### Given（前置條件）

**描述**：情境的起始狀態
**問自己**：在開始之前，什麼已經存在？

```gherkin
Given 用戶已登入
Given 購物車是空的
Given 商品庫存充足
Given 用戶餘額為 1000 元
```

**可以有多個 Given**：
```gherkin
Given 我是 VIP 客戶
And 我已登入系統
And 我的購物車是空的
```

#### When（觸發動作）

**描述**：使用者執行的動作
**問自己**：使用者做了什麼？

```gherkin
When 用戶點擊「加入購物車」
When 用戶輸入優惠碼「SAVE20」
When 用戶提交結帳
When 用戶取消訂單
```

**通常只有一個 When**：
```gherkin
# ✓ 好：一個主要動作
When 用戶提交結帳

# ❌ 不好：多個動作（應該拆成多個場景）
When 用戶加入商品
And 用戶輸入優惠碼
And 用戶點擊結帳
And 用戶確認付款
```

#### Then（預期結果）

**描述**：預期的系統狀態或輸出
**問自己**：應該發生什麼？

```gherkin
Then 購物車中應該有該商品
Then 總價應該顯示為 800 元
Then 用戶應該看到「訂單已確認」訊息
Then 訂單狀態應該是「處理中」
```

**可以有多個 Then**：
```gherkin
Then 訂單應該建立成功
And 用戶應該收到確認郵件
And 庫存應該減少
And 購物車應該被清空
```

---

### Gherkin 完整語法

#### Feature（功能）

**定義整個功能**：
```gherkin
Feature: 購物車管理
  作為一個線上購物用戶
  我想要能管理購物車
  以便我可以選購商品並結帳

  Background:
    Given 用戶已登入系統
    And 以下商品可供購買：
      | 商品名稱  | 價格  | 庫存 |
      | iPhone   | 30000 | 10   |
      | iPad     | 20000 | 5    |
      | MacBook  | 50000 | 3    |

  Scenario: 用戶可以加入商品到購物車
    # 場景 1

  Scenario: 用戶可以更新商品數量
    # 場景 2
```

#### Background（背景）

**所有場景的共同前置條件**：
```gherkin
Feature: 會員系統

  Background:
    Given 系統中有以下用戶：
      | 姓名  | 會員等級 | 餘額  |
      | Alice | VIP      | 10000 |
      | Bob   | 一般會員  | 5000  |
    And 我以管理員身份登入

  Scenario: 查詢 VIP 會員資訊
    When 我搜尋「Alice」
    Then 我應該看到她是 VIP 會員
```

#### Scenario Outline（場景大綱）

**用於測試多組資料**：
```gherkin
Scenario Outline: 不同會員等級獲得不同折扣
  Given 我是「<會員等級>」
  And 我的購物車總額為「<原價>」元
  When 我結帳
  Then 我應該支付「<折後價>」元

  Examples:
    | 會員等級 | 原價  | 折後價 |
    | VIP      | 1000  | 850    |
    | 一般會員  | 1000  | 950    |
    | 新會員    | 1000  | 1000   |
```

#### Data Tables（資料表格）

**表達結構化資料**：
```gherkin
Scenario: 建立訂單包含多個商品
  Given 購物車中有以下商品：
    | 商品名稱 | 數量 | 單價  |
    | iPhone  | 2    | 30000 |
    | AirPods | 1    | 5000  |
  When 我提交訂單
  Then 訂單總額應該是 65000 元
```

#### Doc Strings（文檔字串）

**表達大段文字**：
```gherkin
Scenario: 用戶註冊時收到歡迎郵件
  When 新用戶「alice@example.com」註冊
  Then 用戶應該收到郵件，內容為：
    """
    親愛的用戶，

    歡迎加入我們的服務！
    您的帳號已經建立成功。

    祝購物愉快！
    """
```

---

### 撰寫好 Gherkin 的原則

#### 原則 1：用業務語言，不用技術語言

```gherkin
# ❌ 錯誤：技術細節
Given ShoppingCart 物件已初始化
And session cookie 包含 user_id=123
When POST /api/cart/items with payload {"product_id": 456}
Then response status 應該是 201
And database 應該有新記錄

# ✓ 正確：業務語言
Given 用戶已登入
And 用戶在「iPhone 15」商品頁面
When 用戶點擊「加入購物車」
Then 購物車中應該有「iPhone 15」
And 購物車徽章應該顯示「1」
```

#### 原則 2：一個場景測試一個行為

```gherkin
# ❌ 錯誤：一個場景測試太多
Scenario: 完整的購物流程
  Given 用戶已登入
  When 用戶搜尋「iPhone」
  And 用戶點擊第一個商品
  And 用戶加入購物車
  And 用戶點擊結帳
  And 用戶輸入地址
  And 用戶選擇付款方式
  And 用戶確認訂單
  Then 訂單應該建立成功
  # 太長了！中間任何步驟失敗都難以定位

# ✓ 正確：拆分成多個場景
Scenario: 用戶可以加入商品到購物車
  Given 用戶在「iPhone 15」商品頁面
  When 用戶點擊「加入購物車」
  Then 購物車中應該有「iPhone 15」

Scenario: 用戶可以結帳購物車中的商品
  Given 用戶購物車中有「iPhone 15」
  When 用戶點擊「結帳」
  Then 用戶應該進入結帳頁面

Scenario: 用戶可以完成訂單
  Given 用戶在結帳頁面
  And 用戶已填寫完整資訊
  When 用戶點擊「確認訂單」
  Then 訂單應該建立成功
```

#### 原則 3：場景應該獨立且可重複執行

```gherkin
# ❌ 錯誤：場景依賴順序
Scenario: 建立用戶（場景 1）
  When 我建立用戶「alice@example.com」
  Then 用戶應該建立成功

Scenario: 用戶登入（場景 2，依賴場景 1）
  When 用戶「alice@example.com」登入
  Then 應該登入成功
  # 如果只執行場景 2 會失敗！

# ✓ 正確：場景獨立
Scenario: 建立用戶
  When 我建立用戶「alice@example.com」
  Then 用戶應該建立成功

Scenario: 用戶登入
  Given 系統中已有用戶「alice@example.com」
  When 用戶「alice@example.com」登入
  Then 應該登入成功
  # 可以單獨執行
```

#### 原則 4：避免實作細節

```gherkin
# ❌ 錯誤：包含 UI 實作細節
Given 用戶在首頁
When 用戶點擊 id 為「nav-cart」的元素
And 用戶等待 2 秒
And 用戶在 class 為「cart-item」的第一個元素上點擊刪除按鈕
Then class 為「cart-empty」的 div 應該可見

# ✓ 正確：描述業務行為
Given 用戶購物車中有 1 件商品
When 用戶移除該商品
Then 購物車應該是空的
And 用戶應該看到「購物車是空的」訊息
```

---

## 第三部分：從使用者故事到 Gherkin 規範

### 步驟 1：收集使用者故事

**使用者故事格式**：
```
作為一個 [角色]
我想要 [功能]
以便 [價值]
```

**範例**：
```
作為一個線上購物用戶
我想要能夠將商品加入購物車
以便我可以稍後一起結帳
```

### 步驟 2：提取關鍵場景

**問三個問題**：
1. 這個功能的「快樂路徑」是什麼？（一切順利的情況）
2. 有哪些「替代路徑」？（不同的選擇）
3. 有哪些「錯誤路徑」？（出錯的情況）

**範例**：
```
使用者故事：加入商品到購物車

快樂路徑：
→ 用戶成功加入商品

替代路徑：
→ 用戶加入已在購物車的商品（數量 +1）
→ 用戶加入多個同商品

錯誤路徑：
→ 商品已售完
→ 用戶未登入
→ 超過購買限制
```

### 步驟 3：撰寫 Gherkin 場景

#### 快樂路徑

```gherkin
Scenario: 用戶成功加入商品到購物車
  Given 用戶已登入
  And 用戶在「iPhone 15」商品頁面
  And 該商品有庫存
  When 用戶點擊「加入購物車」
  Then 購物車中應該有「iPhone 15」
  And 購物車徽章應該顯示「1」
  And 用戶應該看到「已加入購物車」訊息
```

#### 替代路徑

```gherkin
Scenario: 用戶加入已在購物車的商品
  Given 用戶已登入
  And 用戶購物車中已有 1 件「iPhone 15」
  When 用戶再次加入「iPhone 15」
  Then 購物車中「iPhone 15」的數量應該是 2
  And 購物車徽章應該顯示「2」
```

#### 錯誤路徑

```gherkin
Scenario: 商品已售完無法加入購物車
  Given 用戶已登入
  And 用戶在「iPhone 15」商品頁面
  But 該商品已售完
  When 用戶點擊「加入購物車」
  Then 用戶應該看到「商品已售完」錯誤訊息
  And 購物車中不應該有「iPhone 15」

Scenario: 未登入用戶無法加入商品到購物車
  Given 用戶未登入
  And 用戶在「iPhone 15」商品頁面
  When 用戶點擊「加入購物車」
  Then 用戶應該被導向登入頁面
  And 購物車中不應該有「iPhone 15」
```

---

### 完整範例：電商結帳流程

#### Feature 定義

```gherkin
Feature: 電商結帳流程
  作為一個線上購物用戶
  我想要能夠順利完成結帳
  以便我可以購買商品

  Background:
    Given 系統中有以下商品：
      | 商品名稱  | 價格  | 庫存 |
      | iPhone   | 30000 | 10   |
      | AirPods  | 5000  | 20   |
    And 用戶「alice@example.com」已登入
    And 用戶餘額為 50000 元
```

#### 場景 1：正常結帳流程

```gherkin
Scenario: 用戶成功完成結帳
  Given 用戶購物車中有以下商品：
    | 商品名稱 | 數量 |
    | iPhone  | 1    |
    | AirPods | 1    |
  When 用戶提交結帳
  Then 訂單應該建立成功
  And 訂單總額應該是 35000 元
  And 用戶餘額應該是 15000 元
  And 用戶應該收到訂單確認郵件
  And 購物車應該被清空
  And 商品庫存應該減少：
    | 商品名稱 | 剩餘庫存 |
    | iPhone  | 9        |
    | AirPods | 19       |
```

#### 場景 2：套用優惠碼

```gherkin
Scenario: 用戶套用優惠碼獲得折扣
  Given 用戶購物車中有「iPhone」1 件
  And 系統中有優惠碼「SAVE10」可折抵 10%
  When 用戶輸入優惠碼「SAVE10」
  And 用戶提交結帳
  Then 訂單原價應該是 30000 元
  And 優惠折扣應該是 3000 元
  And 訂單實付金額應該是 27000 元
  And 用戶應該看到「優惠碼已套用」訊息
```

#### 場景 3：餘額不足

```gherkin
Scenario: 用戶餘額不足無法結帳
  Given 用戶購物車中有「iPhone」2 件
  And 用戶餘額為 50000 元
  But 訂單總額為 60000 元
  When 用戶提交結帳
  Then 用戶應該看到「餘額不足」錯誤訊息
  And 訂單不應該建立
  And 購物車應該保持不變
  And 用戶餘額應該是 50000 元（未扣款）
```

#### 場景 4：庫存不足

```gherkin
Scenario: 商品庫存不足無法結帳
  Given 用戶購物車中有「iPhone」15 件
  But「iPhone」實際庫存只有 10 件
  When 用戶提交結帳
  Then 用戶應該看到「庫存不足」錯誤訊息
  And 錯誤訊息應該說明「iPhone 庫存不足，僅剩 10 件」
  And 訂單不應該建立
  And 購物車中「iPhone」數量應該自動調整為 10 件
```

#### 場景 5：無效的優惠碼

```gherkin
Scenario: 用戶輸入無效的優惠碼
  Given 用戶購物車中有「iPhone」1 件
  When 用戶輸入優惠碼「INVALID」
  Then 用戶應該看到「優惠碼無效」錯誤訊息
  And 訂單金額應該保持為原價 30000 元
```

---

## 第四部分：AI 輔助 BDD 工作流程

### 完整工作流程

```
1️⃣ 人類：撰寫使用者故事
        ↓
2️⃣ 人類 + AI：將故事拆解為 Gherkin 場景
        ↓
3️⃣ 人類：檢查並完善 Gherkin 規範
        ↓
4️⃣ AI：生成測試程式碼（step definitions）
        ↓
5️⃣ 人類：檢查測試邏輯
        ↓
6️⃣ 執行測試 → 🔴 RED
        ↓
7️⃣ AI：實作功能讓測試通過
        ↓
8️⃣ 人類：檢查實作
        ↓
9️⃣ 執行測試 → 🟢 GREEN
        ↓
🔟 人類 + AI：重構並驗證
```

---

### 實戰演練：電商結帳流程

#### 步驟 1-2：從故事到 Gherkin

**與 AI 的對話**：
```
你：「我有一個使用者故事：

『作為一個線上購物用戶
 我想要能夠順利完成結帳
 以便我可以購買商品』

請幫我將這個故事拆解為 Gherkin 場景。
考慮快樂路徑、替代路徑和錯誤路徑。」

AI：「好的，我建議以下場景：

1. 快樂路徑：
   - 用戶成功完成結帳

2. 替代路徑：
   - 用戶套用優惠碼
   - 用戶選擇不同付款方式
   - 用戶選擇不同配送方式

3. 錯誤路徑：
   - 餘額不足
   - 庫存不足
   - 無效的優惠碼
   - 地址資訊不完整

讓我為第一個場景生成 Gherkin 規範：

[AI 生成 Gherkin 程式碼]
```

#### 步驟 3：人類檢查 Gherkin

**檢查清單**：
- [ ] 是否用業務語言（非技術術語）？
- [ ] 場景是否獨立？
- [ ] 場景是否聚焦在一個行為？
- [ ] 非技術人員能理解嗎？
- [ ] 是否避免 UI 實作細節？

#### 步驟 4：AI 生成測試程式碼

**與 AI 的對話**：
```
你：「現在我有完整的 Gherkin 規範：

[貼上 Gherkin 程式碼]

請幫我生成 pytest-bdd 的 step definitions。
使用 Python 3.11+ 和 type hints。」

AI：「好的，這是 step definitions：」
```

**AI 生成的程式碼**：
```python
# features/steps/checkout_steps.py
from pytest_bdd import given, when, then, parsers
from pytest import fixture
from cart import ShoppingCart
from product import Product
from user import User

@given(parsers.parse('用戶「{email}」已登入'))
def user_logged_in(email: str, context):
    context.user = User(email)
    context.user.login()

@given(parsers.parse('用戶餘額為 {amount:d} 元'))
def user_balance(amount: int, context):
    context.user.balance = amount

@given('用戶購物車中有以下商品：')
def cart_items(datatable, context):
    context.cart = ShoppingCart(context.user)
    for row in datatable:
        product = Product(row['商品名稱'])
        quantity = int(row['數量'])
        context.cart.add_item(product, quantity)

@when('用戶提交結帳')
def submit_checkout(context):
    context.order = context.cart.checkout()

@then('訂單應該建立成功')
def order_created(context):
    assert context.order is not None
    assert context.order.status == 'confirmed'

@then(parsers.parse('訂單總額應該是 {amount:d} 元'))
def order_total(amount: int, context):
    assert context.order.total == amount

@then(parsers.parse('用戶餘額應該是 {amount:d} 元'))
def user_balance_after(amount: int, context):
    assert context.user.balance == amount

@then('用戶應該收到訂單確認郵件')
def confirmation_email(context):
    # 檢查郵件佇列
    assert context.user.email in email_queue

@then('購物車應該被清空')
def cart_empty(context):
    assert len(context.cart.items) == 0
```

#### 步驟 5：人類檢查測試邏輯

**檢查要點**：
```python
# 檢查點 1：斷言是否足夠嚴格？
@then('訂單應該建立成功')
def order_created(context):
    assert context.order is not None  # ✓ 基本檢查
    assert context.order.status == 'confirmed'  # ✓ 狀態檢查
    # ？ 是否還要檢查 order.id、order.created_at？

# 檢查點 2：是否考慮邊界情況？
@given(parsers.parse('用戶餘額為 {amount:d} 元'))
def user_balance(amount: int, context):
    context.user.balance = amount
    # ？ 如果 amount 是負數怎麼辦？

# 檢查點 3：測試資料是否隔離？
@given('用戶購物車中有以下商品：')
def cart_items(datatable, context):
    context.cart = ShoppingCart(context.user)
    # ✓ 每次都建立新的購物車（隔離）
```

#### 步驟 6-9：執行測試循環

```bash
# 執行 BDD 測試
$ pytest features/checkout.feature -v

# 第一次執行：全部失敗（紅）
FAILED features/checkout.feature::用戶成功完成結帳

# 實作功能後：全部通過（綠）
PASSED features/checkout.feature::用戶成功完成結帳 ✓
PASSED features/checkout.feature::用戶套用優惠碼獲得折扣 ✓
PASSED features/checkout.feature::用戶餘額不足無法結帳 ✓
```

---

## 第五部分：BDD 最佳實踐

### 實踐 1：三方協作（Three Amigos）

**參與者**：
- **Product Owner / BA**：提供業務需求
- **Developer**：技術實作
- **Tester / QA**：測試視角

**流程**：
```
1. PO 提出使用者故事
   ↓
2. 三方共同討論：
   - 快樂路徑是什麼？
   - 有哪些邊界情況？
   - 可能的錯誤？
   ↓
3. 一起撰寫 Gherkin 規範
   ↓
4. 規範成為共同理解的基礎
```

**AI 在三方協作的角色**：
```
人類討論業務邏輯
↓
AI 將討論轉化為 Gherkin 規範
↓
人類檢查並修正
↓
達成共識
```

### 實踐 2：Living Documentation（活文檔）

**傳統文檔的問題**：
```
Sprint 1：寫了 100 頁 Word 文檔
Sprint 3：程式碼已改 10 次
Sprint 5：沒人更新文檔
Sprint 10：文檔完全過時，沒人看
```

**BDD 的解決方案**：
```
Gherkin 規範 = 可執行的文檔

文檔更新 = 更新 Gherkin = 測試失敗 = 被迫同步

規範、測試、文檔永遠一致（因為是同一份）
```

**生成人類友善的文檔**：
```bash
# 生成 HTML 報告
$ pytest features/ --html=report.html

# 報告包含：
# - 所有場景的執行結果
# - Given-When-Then 步驟
# - 失敗的場景和原因
# - 可以給非技術人員看
```

### 實踐 3：測試金字塔中的 BDD

```
        ╱╲
       ╱  ╲       E2E Tests (BDD)
      ╱────╲      - 少量（10%）
     ╱      ╲     - 關鍵使用者流程
    ╱────────╲    - 執行慢但價值高
   ╱          ╲
  ╱   Integration ╲   Integration Tests
 ╱                ╲  - 中等數量（20%）
╱──────────────────╲
       Unit Tests      Unit Tests (TDD)
  - 大量（70%）
  - 執行快
  - 覆蓋核心邏輯

BDD 在頂端：驗證「做對的事」
TDD 在底層：確保「把事做對」
```

---

## 🎯 總結

### BDD 的核心價值

1. **共同語言**：所有人都能理解的規範
2. **需求即測試**：規範就是可執行的測試
3. **活文檔**：永遠同步的文檔
4. **Outside-In**：從使用者視角設計功能

### Gherkin 的關鍵要素

1. **Given**：前置條件（情境）
2. **When**：觸發動作（使用者做什麼）
3. **Then**：預期結果（系統應該怎樣）
4. **用業務語言**：任何人都能理解

### AI 輔助 BDD 的威力

1. **加速規範撰寫**：AI 幫助將故事轉為 Gherkin
2. **生成測試程式碼**：自動產生 step definitions
3. **提醒遺漏場景**：AI 建議邊界情況
4. **維護文檔同步**：AI 協助更新規範

### BDD + TDD = 完美組合

```
BDD：確保「做對的事」
     從使用者視角驗證功能

TDD：確保「把事做對」
     從技術視角實作細節

兩者結合 = 高品質軟體
```

---

## 📚 延伸閱讀

- **Gherkin Reference**: https://cucumber.io/docs/gherkin/reference/
- **BDD in Action** by John Ferguson Smart
- **The Cucumber Book** by Matt Wynne

---

## 🔗 下一步

完成本章後，繼續學習：

➡️ **4.3 測試金字塔與 AI**
- 理解不同測試層級
- 設計測試策略
- AI 在各層級的應用

**實作建議**：
開始實作「練習 2：BDD 購物車流程」：
1. 撰寫完整的 Gherkin 規範
2. 用 AI 生成 step definitions
3. 實作功能讓測試通過
4. 體驗 BDD 的完整流程

---

**BDD 不只是測試方法，更是溝通方式！**
**開始用 Gherkin 與團隊溝通吧！**
