# 4.1 AI 驅動的測試驅動開發

## 📋 內容概述

本章探討如何用 AI 輔助測試驅動開發（TDD），在不破壞 TDD 精神的前提下，大幅提升開發效率。

**閱讀時間**：60 分鐘
**實作時間**：60-90 分鐘（跟著範例實作）

---

## 🎯 學習目標

- 理解 TDD 的紅-綠-重構循環
- 掌握 AI 輔助 TDD 的完整工作流程
- 體驗「測試先行」的威力
- 建立 TDD 思維模式

---

## 第一部分：TDD 核心原則

### 什麼是測試驅動開發？

**定義**：
> TDD 是一種軟體開發方法，在寫實作程式碼之前，先寫測試程式碼。

**核心循環**：
```
🔴 Red（紅）   → 寫一個失敗的測試
🟢 Green（綠）  → 寫最簡單的程式碼讓測試通過
🔵 Refactor（重構） → 改善程式碼品質，保持測試通過
```

### 為什麼要 TDD？

#### 錯誤的理由

❌ **「為了提高測試覆蓋率」**
- 覆蓋率只是副產品，不是目的

❌ **「因為測試很重要」**
- 測試確實重要，但這不足以說明為什麼要「先」寫測試

❌ **「為了找 bug」**
- TDD 的主要目的不是找 bug，而是設計

#### 正確的理由

✅ **「測試驅動設計」**
```
寫測試 → 思考介面 → 發現設計問題 → 改進設計
```

✅ **「即時回饋」**
```
每幾分鐘就知道程式碼是否正確
不需要等到整個功能完成才測試
```

✅ **「重構的保護網」**
```
有測試保護 → 放心重構 → 持續改善程式碼
沒有測試 → 害怕改程式碼 → 程式碼腐化
```

✅ **「可執行的規範」**
```
測試 = 程式碼應該如何運作的規範
測試 = 活文檔（永遠不會過時）
```

---

### TDD 的三個階段詳解

#### 🔴 紅階段：寫失敗的測試

**目的**：
- 清楚定義「下一個」要實作的功能
- 建立可驗證的成功標準
- 確認測試真的會失敗（避免假陽性）

**原則**：
1. **只寫一個測試**（不要一次寫完所有測試）
2. **測試應該明確且簡單**（一個測試只驗證一件事）
3. **測試名稱描述預期行為**（不是描述實作）
4. **確認測試真的失敗**（執行測試，看到紅色）

**範例**：
```python
# Good: 描述行為，測試簡單明確
def test_user_can_create_task_with_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")
    assert task.title == "Buy milk"

# Bad: 一次測試太多東西
def test_task_manager():
    task_manager = TaskManager()
    task1 = task_manager.create_task("Buy milk")
    task2 = task_manager.create_task("Do homework")
    assert task1.title == "Buy milk"
    assert task2.title == "Do homework"
    assert task_manager.get_all_tasks() == [task1, task2]
    assert task1.is_completed == False
```

#### 🟢 綠階段：讓測試通過

**目的**：
- 用最快的方式讓測試通過
- 先求能動，再求好（重構階段會改善）
- 累積進度，建立信心

**原則**：
1. **用最簡單的方式讓測試通過**（可以寫「醜陋」的程式碼）
2. **不要過度設計**（YAGNI - You Aren't Gonna Need It）
3. **快速通過這個階段**（5-10 分鐘內完成）
4. **確認測試真的通過**（執行測試，看到綠色）

**範例**：

```python
# 第一次迭代：最簡單的實作（甚至可以 hardcode）
class TaskManager:
    def create_task(self, title):
        task = Task()
        task.title = "Buy milk"  # 寫死的值，但測試通過了！
        return task

# 第二個測試會強迫你改進
def test_user_can_create_task_with_different_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Do homework")
    assert task.title == "Do homework"  # 這會失敗

# 改進實作
class TaskManager:
    def create_task(self, title):
        task = Task()
        task.title = title  # 現在正確了
        return task
```

**為什麼允許「醜陋」的程式碼？**
- 快速得到回饋（知道方向正確）
- 避免過早優化（不知道需求會如何演變）
- 重構階段會改善（有測試保護）

#### 🔵 重構階段：改善程式碼

**目的**：
- 改善程式碼品質
- 消除重複
- 改善命名和結構
- 讓程式碼更易讀、易維護

**原則**：
1. **測試必須保持通過**（重構不改變行為）
2. **小步迭代**（每次改一點點）
3. **經常執行測試**（確保沒有破壞功能）
4. **追求簡潔**（刪除不必要的程式碼）

**常見重構手法**：

```python
# 重構前：重複的程式碼
class TaskManager:
    def create_task(self, title):
        task = Task()
        task.title = title
        task.is_completed = False
        task.created_at = datetime.now()
        return task

    def create_task_with_priority(self, title, priority):
        task = Task()
        task.title = title
        task.is_completed = False
        task.created_at = datetime.now()
        task.priority = priority
        return task

# 重構後：提取共同邏輯
class TaskManager:
    def create_task(self, title, priority=None):
        task = Task()
        task.title = title
        task.is_completed = False
        task.created_at = datetime.now()
        if priority:
            task.priority = priority
        return task
```

---

## 第二部分：為什麼 TDD 與 AI 是完美組合

### 傳統 TDD 的挑戰

**挑戰 1：寫測試很花時間**
```
寫測試骨架 → 設置 fixtures → 寫斷言 → 處理邊界情況
可能需要 30-60 分鐘
```

**挑戰 2：測試程式碼也需要維護**
```
功能變更 → 測試也要改 → 又是一堆時間
```

**挑戰 3：思維轉換困難**
```
習慣先寫實作 → 強迫自己先寫測試 → 感覺不自然
```

**挑戰 4：初期速度慢**
```
剛開始 TDD → 感覺效率很低 → 容易放棄
```

### AI 如何完美解決這些挑戰

**解決挑戰 1：AI 生成測試骨架**
```
人類：描述要測試的行為（30 秒）
↓
AI：生成完整測試程式碼（5 秒）
↓
人類：檢查並完善（2-3 分鐘）

總計：3-4 分鐘（原本需要 30 分鐘）
```

**解決挑戰 2：AI 協助維護測試**
```
人類：說明功能變更
↓
AI：更新測試程式碼
↓
人類：驗證正確性

維護時間從 30 分鐘降到 5 分鐘
```

**解決挑戰 3：AI 協助建立 TDD 習慣**
```
AI 先生成測試 → 人類自然地遵循 TDD 流程
不需要「強迫」自己，工具流程就是這樣設計的
```

**解決挑戰 4：加速初期學習**
```
看 AI 如何寫測試 → 學習測試的模式 → 建立肌肉記憶
幾週後即使不用 AI 也能寫好測試
```

---

### AI 輔助 TDD 的核心價值

**價值 1：保持 TDD 精神，提升執行效率**
```
❌ 錯誤想法：用 AI 生成實作，跳過測試
✅ 正確做法：用 AI 加速測試編寫，嚴格遵循 TDD

TDD 的價值（設計、回饋、保護）完全保留
但執行效率提升 3-5 倍
```

**價值 2：降低 TDD 學習曲線**
```
傳統：自己摸索如何寫好測試（需要 3-6 個月）
AI 輔助：看 AI 示範 + 不斷練習（需要 2-4 週）

學習時間縮短 80%
```

**價值 3：提升測試品質**
```
AI 可以：
- 自動考慮邊界情況
- 生成更全面的測試
- 提供不同的測試視角
- 發現人類容易忽略的情況

測試品質往往比人類手寫更好
```

**價值 4：讓 TDD 變得有趣**
```
傳統 TDD：寫測試是「苦工」
AI 輔助 TDD：像在玩遊戲

看到測試快速通過 → 獲得成就感 → 更願意寫測試
正向循環建立
```

---

## 第三部分：AI 輔助 TDD 工作流程

### 完整工作流程圖

```
┌─────────────────────────────────────────────────┐
│ 1️⃣ 人類：定義下一個測試場景                        │
│    「我要測試用戶可以建立任務」                      │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 2️⃣ AI：生成測試骨架                               │
│    def test_user_can_create_task(): ...         │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 3️⃣ 人類：檢查並完善測試邏輯                        │
│    補充邊界情況、改善斷言                           │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 4️⃣ 執行測試 → 🔴 RED（確認測試失敗）               │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 5️⃣ AI：生成讓測試通過的實作                        │
│    class TaskManager: ...                       │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 6️⃣ 人類：檢查實作的正確性和簡潔性                   │
│    確保是「最簡單」的實作                           │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 7️⃣ 執行測試 → 🟢 GREEN（確認測試通過）             │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 8️⃣ 人類 + AI：協作重構                            │
│    人類指出重構方向，AI 執行重構                    │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│ 9️⃣ 執行所有測試 → 🟢 確認沒有破壞                  │
└────────────────┬────────────────────────────────┘
                 ↓
        回到步驟 1️⃣（下一個功能）
```

---

### 詳細步驟說明

#### 步驟 1：人類定義測試場景

**你要做的**：
- 思考「下一個」最小的功能單元
- 用一句話描述要測試的行為
- 不要想太遠（只專注當下這一個測試）

**與 AI 的對話範例**：
```
你：「我要用 TDD 方式建立任務管理系統。
     第一個測試：用戶可以建立一個任務，並指定標題。
     請幫我生成測試程式碼。」

（清楚、具體、聚焦在一個行為）
```

#### 步驟 2：AI 生成測試骨架

**AI 會做什麼**：
```python
# AI 生成的測試程式碼
import pytest
from task_manager import TaskManager

def test_user_can_create_task_with_title():
    """Test that a user can create a task with a specific title"""
    # Arrange
    task_manager = TaskManager()
    title = "Buy milk"

    # Act
    task = task_manager.create_task(title)

    # Assert
    assert task is not None
    assert task.title == "Buy milk"
    assert isinstance(task.id, str)  # AI 可能會考慮更多細節
```

**AI 的價值**：
- 自動設置測試結構（Arrange-Act-Assert）
- 考慮基本的邊界情況
- 生成清晰的測試名稱和文檔

#### 步驟 3：人類檢查並完善

**你要做的**：
```python
# 檢查點 1：測試邏輯是否正確？
assert task.title == "Buy milk"  # ✓ 正確

# 檢查點 2：是否測試太多？
assert isinstance(task.id, str)  # ？ 這個測試必要嗎？
# 決定：第一個測試先專注在 title，id 留給下一個測試

# 檢查點 3：是否有遺漏？
# 加上：任務建立時應該是「未完成」狀態
assert task.is_completed == False  # ✓ 補充

# 最終版本
def test_user_can_create_task_with_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")

    assert task.title == "Buy milk"
    assert task.is_completed == False
```

**關鍵原則**：
- 測試應該簡單且專注
- 一個測試只驗證一個行為
- 名稱清楚描述預期行為

#### 步驟 4：執行測試 - 確認 RED

**你要做的**：
```bash
$ pytest tests/test_task_manager.py::test_user_can_create_task_with_title

# 應該看到
FAILED tests/test_task_manager.py::test_user_can_create_task_with_title
ModuleNotFoundError: No module named 'task_manager'
```

**為什麼這一步重要**：
- 確認測試真的會失敗（避免假陽性）
- 看到紅色是正常的（甚至是令人興奮的）
- 建立清楚的目標（讓這個紅色變綠色）

**常見錯誤**：
```python
# ❌ 錯誤：測試寫錯了，永遠通過
def test_user_can_create_task_with_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")
    assert True  # 這個測試永遠通過！

# ✓ 正確：有實質的驗證
def test_user_can_create_task_with_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")
    assert task.title == "Buy milk"  # 真正的驗證
```

#### 步驟 5：AI 生成實作

**與 AI 的對話**：
```
你：「現在我有一個失敗的測試（貼上測試程式碼）。
     請幫我實作 TaskManager 和 Task 類別，
     用『最簡單』的方式讓測試通過。」

AI：「好的，這是最簡實作：」
```

```python
# AI 生成的實作
class Task:
    def __init__(self, title):
        self.title = title
        self.is_completed = False

class TaskManager:
    def create_task(self, title):
        return Task(title)
```

**AI 的價值**：
- 快速生成基本實作（節省打字時間）
- 通常會產生簡潔的程式碼
- 可以處理基本的邊界情況

#### 步驟 6：人類檢查實作

**你要檢查的**：

**檢查點 1：是否真的「最簡單」？**
```python
# ❌ 過度設計
class TaskManager:
    def __init__(self):
        self.tasks = []
        self.id_counter = 0

    def create_task(self, title):
        self.id_counter += 1
        task = Task(str(self.id_counter), title)
        self.tasks.append(task)
        return task

# 問：測試有要求儲存任務嗎？沒有。
# 問：測試有要求 ID 嗎？沒有。
# 結論：過度設計了，違反 YAGNI 原則

# ✓ 最簡實作
class TaskManager:
    def create_task(self, title):
        return Task(title)
```

**檢查點 2：程式碼是否清晰？**
```python
# ❌ 命名不清
class TaskManager:
    def ct(self, t):  # 什麼鬼？
        return Task(t)

# ✓ 清晰的命名
class TaskManager:
    def create_task(self, title):
        return Task(title)
```

**檢查點 3：有沒有明顯的問題？**
```python
# ❌ 沒有處理 None
class Task:
    def __init__(self, title):
        self.title = title  # title 是 None 會怎樣？

# ✓ 加上基本驗證（如果需要）
class Task:
    def __init__(self, title):
        if not title:
            raise ValueError("Title cannot be empty")
        self.title = title
```

但注意：**只有在測試要求時才加驗證**！
如果測試沒有測試空標題的情況，就不要加這個驗證（YAGNI）。

#### 步驟 7：執行測試 - 確認 GREEN

**你要做的**：
```bash
$ pytest tests/test_task_manager.py::test_user_can_create_task_with_title

# 應該看到
PASSED tests/test_task_manager.py::test_user_can_create_task_with_title ✓
```

**這一刻的感受**：
- 🎉 成就感（從紅變綠）
- 💪 信心（知道這部分功能是正確的）
- 🚀 動力（想繼續下一個測試）

**如果測試沒通過**：
1. 檢查實作邏輯
2. 檢查測試邏輯
3. 與 AI 討論問題在哪裡
4. 修正後再次執行

#### 步驟 8：協作重構

**你要做的**：

**重構時機 1：看到重複程式碼**
```python
# 寫了幾個測試後，發現重複
def test_create_task():
    task_manager = TaskManager()  # 重複
    task = task_manager.create_task("Task 1")
    assert task.title == "Task 1"

def test_complete_task():
    task_manager = TaskManager()  # 重複
    task = task_manager.create_task("Task 1")
    task_manager.complete_task(task.id)
    assert task.is_completed

# 對 AI 說：
「我注意到每個測試都在建立 TaskManager。
 請幫我重構，使用 pytest fixture。」

# AI 生成
@pytest.fixture
def task_manager():
    return TaskManager()

def test_create_task(task_manager):
    task = task_manager.create_task("Task 1")
    assert task.title == "Task 1"
```

**重構時機 2：程式碼不夠清晰**
```python
# 實作變複雜了
class TaskManager:
    def create_task(self, title, priority=None, due_date=None):
        task = Task(title)
        if priority:
            task.priority = priority
        if due_date:
            task.due_date = due_date
        if not hasattr(self, 'tasks'):
            self.tasks = []
        self.tasks.append(task)
        return task

# 對 AI 說：
「這個方法做太多事了，請幫我重構：
 1. 提取任務初始化邏輯
 2. 提取任務儲存邏輯」

# AI 生成
class TaskManager:
    def __init__(self):
        self.tasks = []

    def create_task(self, title, priority=None, due_date=None):
        task = self._initialize_task(title, priority, due_date)
        self._store_task(task)
        return task

    def _initialize_task(self, title, priority, due_date):
        task = Task(title)
        if priority:
            task.priority = priority
        if due_date:
            task.due_date = due_date
        return task

    def _store_task(self, task):
        self.tasks.append(task)
```

**重構時機 3：發現設計問題**
```python
# 測試揭示了設計問題
def test_get_completed_tasks():
    task_manager = TaskManager()
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    task_manager.complete_task(task1.id)

    # 這行程式碼看起來很醜
    completed = [t for t in task_manager.tasks if t.is_completed]
    assert len(completed) == 1

# 對 AI 說：
「TaskManager 應該提供一個方法來取得已完成的任務。
 請加上 get_completed_tasks() 方法。」

# AI 生成
class TaskManager:
    def get_completed_tasks(self):
        return [task for task in self.tasks if task.is_completed]

# 測試變簡潔了
def test_get_completed_tasks(task_manager):
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    task_manager.complete_task(task1.id)

    completed = task_manager.get_completed_tasks()
    assert len(completed) == 1
    assert completed[0] == task1
```

#### 步驟 9：執行所有測試

**你要做的**：
```bash
$ pytest tests/

# 應該看到所有測試通過
======================== test session starts ========================
tests/test_task_manager.py ............                      [100%]
======================== 12 passed in 0.23s =========================
```

**這一步的意義**：
- 確保重構沒有破壞現有功能
- 建立信心（所有功能都還正常）
- 可以安心繼續下一個功能

**如果有測試失敗**：
1. 不要慌張（這就是測試的價值）
2. 查看失敗的測試
3. 回退剛才的重構
4. 更小心地重構
5. 再次執行測試

---

## 第四部分：完整範例 - TDD 構建任務管理系統

### 情境設定

**需求**：
建立一個簡單的任務管理系統，支援：
1. 建立任務（標題）
2. 標記任務完成
3. 取得所有任務
4. 取得已完成的任務

**時間估計**：60-90 分鐘

---

### 第一個循環：建立任務

#### 🔴 RED - 寫測試

```python
# tests/test_task_manager.py
import pytest
from task_manager import TaskManager

def test_user_can_create_task_with_title():
    """用戶可以建立一個有標題的任務"""
    # Arrange
    task_manager = TaskManager()

    # Act
    task = task_manager.create_task("Buy milk")

    # Assert
    assert task.title == "Buy milk"
    assert task.is_completed == False
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

FAILED - ModuleNotFoundError: No module named 'task_manager'
```

✓ 測試失敗了（預期中）

#### 🟢 GREEN - 實作

```python
# task_manager.py
class Task:
    def __init__(self, title):
        self.title = title
        self.is_completed = False

class TaskManager:
    def create_task(self, title):
        return Task(title)
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓
```

#### 🔵 REFACTOR - 重構

目前程式碼很簡單，暫不需要重構。

---

### 第二個循環：任務需要唯一 ID

#### 🔴 RED - 寫測試

```python
def test_created_tasks_have_unique_ids():
    """每個任務都有唯一的 ID"""
    task_manager = TaskManager()

    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")

    assert task1.id != task2.id
    assert isinstance(task1.id, str)
```

**執行測試**：
```bash
FAILED - AttributeError: 'Task' object has no attribute 'id'
```

#### 🟢 GREEN - 實作

```python
import uuid

class Task:
    def __init__(self, title):
        self.id = str(uuid.uuid4())
        self.title = title
        self.is_completed = False

class TaskManager:
    def create_task(self, title):
        return Task(title)
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓  # 兩個測試都通過
```

#### 🔵 REFACTOR - 重構

目前程式碼依然簡潔，無需重構。

---

### 第三個循環：標記任務完成

#### 🔴 RED - 寫測試

```python
def test_user_can_mark_task_as_completed():
    """用戶可以標記任務為已完成"""
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")

    task_manager.complete_task(task.id)

    assert task.is_completed == True
```

**執行測試**：
```bash
FAILED - AttributeError: 'TaskManager' object has no attribute 'complete_task'
```

#### 🟢 GREEN - 實作

```python
class TaskManager:
    def __init__(self):
        self.tasks = []

    def create_task(self, title):
        task = Task(title)
        self.tasks.append(task)  # 需要儲存任務
        return task

    def complete_task(self, task_id):
        task = self._find_task(task_id)
        if task:
            task.is_completed = True

    def _find_task(self, task_id):
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓✓  # 三個測試都通過
```

#### 🔵 REFACTOR - 重構

看到測試開始重複建立 `TaskManager`，提取 fixture：

```python
# tests/test_task_manager.py
import pytest
from task_manager import TaskManager

@pytest.fixture
def task_manager():
    return TaskManager()

def test_user_can_create_task_with_title(task_manager):
    task = task_manager.create_task("Buy milk")
    assert task.title == "Buy milk"
    assert task.is_completed == False

def test_created_tasks_have_unique_ids(task_manager):
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    assert task1.id != task2.id

def test_user_can_mark_task_as_completed(task_manager):
    task = task_manager.create_task("Buy milk")
    task_manager.complete_task(task.id)
    assert task.is_completed == True
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓✓  # 重構後依然通過
```

---

### 第四個循環：取得所有任務

#### 🔴 RED - 寫測試

```python
def test_can_get_all_tasks(task_manager):
    """可以取得所有任務"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")

    all_tasks = task_manager.get_all_tasks()

    assert len(all_tasks) == 2
    assert task1 in all_tasks
    assert task2 in all_tasks
```

**執行測試**：
```bash
FAILED - AttributeError: 'TaskManager' object has no attribute 'get_all_tasks'
```

#### 🟢 GREEN - 實作

```python
class TaskManager:
    # ... 其他方法

    def get_all_tasks(self):
        return self.tasks.copy()  # 返回副本，避免外部修改
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓✓✓
```

#### 🔵 REFACTOR - 重構

程式碼簡潔，無需重構。

---

### 第五個循環：取得已完成的任務

#### 🔴 RED - 寫測試

```python
def test_can_get_completed_tasks(task_manager):
    """可以取得已完成的任務"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    task3 = task_manager.create_task("Task 3")

    task_manager.complete_task(task1.id)
    task_manager.complete_task(task3.id)

    completed = task_manager.get_completed_tasks()

    assert len(completed) == 2
    assert task1 in completed
    assert task3 in completed
    assert task2 not in completed
```

**執行測試**：
```bash
FAILED - AttributeError: 'TaskManager' object has no attribute 'get_completed_tasks'
```

#### 🟢 GREEN - 實作

```python
class TaskManager:
    # ... 其他方法

    def get_completed_tasks(self):
        return [task for task in self.tasks if task.is_completed]
```

**執行測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓✓✓✓  # 所有測試通過！
```

#### 🔵 REFACTOR - 重構

可以提取一個通用的過濾方法：

```python
class TaskManager:
    # ... 其他方法

    def get_completed_tasks(self):
        return self._filter_tasks(lambda task: task.is_completed)

    def get_pending_tasks(self):  # 順便加上這個
        return self._filter_tasks(lambda task: not task.is_completed)

    def _filter_tasks(self, predicate):
        return [task for task in self.tasks if predicate(task)]
```

**執行所有測試**：
```bash
$ pytest tests/test_task_manager.py -v

PASSED ✓✓✓✓✓  # 重構後依然通過
```

---

### 完整程式碼

#### task_manager.py（最終版本）

```python
import uuid

class Task:
    """代表一個任務"""
    def __init__(self, title):
        self.id = str(uuid.uuid4())
        self.title = title
        self.is_completed = False

class TaskManager:
    """管理任務的類別"""
    def __init__(self):
        self.tasks = []

    def create_task(self, title):
        """建立一個新任務"""
        task = Task(title)
        self.tasks.append(task)
        return task

    def complete_task(self, task_id):
        """標記任務為已完成"""
        task = self._find_task(task_id)
        if task:
            task.is_completed = True

    def get_all_tasks(self):
        """取得所有任務"""
        return self.tasks.copy()

    def get_completed_tasks(self):
        """取得已完成的任務"""
        return self._filter_tasks(lambda task: task.is_completed)

    def get_pending_tasks(self):
        """取得未完成的任務"""
        return self._filter_tasks(lambda task: not task.is_completed)

    def _find_task(self, task_id):
        """找到指定 ID 的任務"""
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None

    def _filter_tasks(self, predicate):
        """根據條件過濾任務"""
        return [task for task in self.tasks if predicate(task)]
```

#### test_task_manager.py（完整測試）

```python
import pytest
from task_manager import TaskManager

@pytest.fixture
def task_manager():
    return TaskManager()

def test_user_can_create_task_with_title(task_manager):
    """用戶可以建立一個有標題的任務"""
    task = task_manager.create_task("Buy milk")
    assert task.title == "Buy milk"
    assert task.is_completed == False

def test_created_tasks_have_unique_ids(task_manager):
    """每個任務都有唯一的 ID"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    assert task1.id != task2.id
    assert isinstance(task1.id, str)

def test_user_can_mark_task_as_completed(task_manager):
    """用戶可以標記任務為已完成"""
    task = task_manager.create_task("Buy milk")
    task_manager.complete_task(task.id)
    assert task.is_completed == True

def test_can_get_all_tasks(task_manager):
    """可以取得所有任務"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    all_tasks = task_manager.get_all_tasks()
    assert len(all_tasks) == 2
    assert task1 in all_tasks
    assert task2 in all_tasks

def test_can_get_completed_tasks(task_manager):
    """可以取得已完成的任務"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")
    task3 = task_manager.create_task("Task 3")

    task_manager.complete_task(task1.id)
    task_manager.complete_task(task3.id)

    completed = task_manager.get_completed_tasks()
    assert len(completed) == 2
    assert task1 in completed
    assert task3 in completed
    assert task2 not in completed

def test_can_get_pending_tasks(task_manager):
    """可以取得未完成的任務"""
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")

    task_manager.complete_task(task1.id)

    pending = task_manager.get_pending_tasks()
    assert len(pending) == 1
    assert task2 in pending
    assert task1 not in pending
```

---

## 第五部分：TDD 常見陷阱與解決方案

### 陷阱 1：一次寫太多測試

**問題**：
```python
# ❌ 錯誤：一次寫 10 個測試
def test_create_task(): ...
def test_complete_task(): ...
def test_delete_task(): ...
def test_update_task(): ...
def test_get_tasks(): ...
def test_filter_tasks(): ...
# ... 還有 4 個

# 然後開始實作，發現：
# - 不知道從哪裡開始
# - 設計可能需要大幅調整
# - 所有測試都要改
```

**解決方案**：
```python
# ✓ 正確：一次只寫一個測試
def test_create_task(): ...

# 實作讓它通過

# 再寫下一個
def test_complete_task(): ...

# 實作讓它通過

# 持續這個循環
```

**為什麼**：
- 設計會隨著測試演化
- 早期的假設可能是錯的
- 小步迭代更容易調整方向

---

### 陷阱 2：測試實作細節而非行為

**問題**：
```python
# ❌ 錯誤：測試實作細節
def test_task_manager_uses_list_to_store_tasks():
    task_manager = TaskManager()
    assert isinstance(task_manager.tasks, list)

def test_task_manager_increments_counter():
    task_manager = TaskManager()
    task_manager.create_task("Task 1")
    assert task_manager._counter == 1
```

**為什麼這不好**：
- 重構時測試會壞掉
- 限制了實作的靈活性
- 測試沒有真正的業務價值

**解決方案**：
```python
# ✓ 正確：測試行為
def test_can_retrieve_created_tasks():
    task_manager = TaskManager()
    task = task_manager.create_task("Task 1")

    all_tasks = task_manager.get_all_tasks()
    assert task in all_tasks

def test_each_task_has_unique_identifier():
    task_manager = TaskManager()
    task1 = task_manager.create_task("Task 1")
    task2 = task_manager.create_task("Task 2")

    assert task1.id != task2.id
```

**為什麼這更好**：
- 測試的是「做什麼」而非「怎麼做」
- 重構時測試依然有效
- 測試有真實的業務價值

---

### 陷阱 3：過早優化

**問題**：
```python
# ❌ 錯誤：第一個測試就考慮效能
def test_create_task():
    task_manager = TaskManager()
    task = task_manager.create_task("Task 1")
    assert task.title == "Task 1"

# 實作時過度設計
class TaskManager:
    def __init__(self):
        self.tasks = {}  # 用 dict 因為「查找更快」
        self.task_index = {}  # 建立索引因為「可能需要快速查找」
        self._cache = LRUCache(100)  # 加上快取因為「效能」

    def create_task(self, title):
        # 50 行複雜的程式碼...
        pass
```

**為什麼這不好**：
- 測試只需要最簡單的實作
- 複雜的程式碼難以維護
- 可能永遠不需要這些優化

**解決方案**：
```python
# ✓ 正確：最簡實作
class TaskManager:
    def __init__(self):
        self.tasks = []  # 簡單的 list 就夠了

    def create_task(self, title):
        task = Task(title)
        self.tasks.append(task)
        return task

# 等到真的需要時再優化
# TDD 的第一原則：Make it work, make it right, make it fast
```

---

### 陷阱 4：跳過重構階段

**問題**：
```python
# 幾個循環後，程式碼變成這樣：
class TaskManager:
    def create_task(self, title):
        task = Task(title)
        self.tasks.append(task)
        return task

    def create_task_with_priority(self, title, priority):
        task = Task(title)
        task.priority = priority  # 重複
        self.tasks.append(task)  # 重複
        return task

    def create_task_with_due_date(self, title, due_date):
        task = Task(title)
        task.due_date = due_date  # 重複
        self.tasks.append(task)  # 重複
        return task

# 因為「測試通過了」，就不重構
```

**為什麼這不好**：
- 程式碼重複（DRY 原則）
- 難以維護（一個 bug 要修三個地方）
- 技術債務累積

**解決方案**：
```python
# ✓ 正確：立即重構
class TaskManager:
    def create_task(self, title, priority=None, due_date=None):
        task = Task(title)
        if priority:
            task.priority = priority
        if due_date:
            task.due_date = due_date
        self.tasks.append(task)
        return task

# 或者更進一步
class TaskManager:
    def create_task(self, title, **kwargs):
        task = Task(title)
        for key, value in kwargs.items():
            setattr(task, key, value)
        self.tasks.append(task)
        return task
```

---

### 陷阱 5：為了覆蓋率而測試

**問題**：
```python
# ❌ 錯誤：無意義的測試
def test_task_has_title_attribute():
    task = Task("Buy milk")
    assert hasattr(task, 'title')

def test_task_manager_can_be_instantiated():
    task_manager = TaskManager()
    assert task_manager is not None

def test_task_title_is_string():
    task = Task("Buy milk")
    assert isinstance(task.title, str)
```

**為什麼這不好**：
- 沒有測試真正的業務邏輯
- 測試沒有保護作用
- 浪費時間維護無用的測試

**解決方案**：
```python
# ✓ 正確：測試有意義的行為
def test_user_can_create_task_with_title():
    task_manager = TaskManager()
    task = task_manager.create_task("Buy milk")
    assert task.title == "Buy milk"

def test_task_title_cannot_be_empty():
    task_manager = TaskManager()
    with pytest.raises(ValueError):
        task_manager.create_task("")

def test_task_title_is_trimmed():
    task_manager = TaskManager()
    task = task_manager.create_task("  Buy milk  ")
    assert task.title == "Buy milk"
```

---

## 第六部分：AI 輔助 TDD 的最佳實踐

### 實踐 1：清楚告訴 AI 你在做 TDD

**好的提示**：
```
「我要用 TDD 方式開發任務管理系統。

第一個測試：用戶可以建立任務並指定標題。
請生成測試程式碼，使用 pytest 框架。

記住：
1. 測試名稱要清楚描述行為
2. 使用 Arrange-Act-Assert 結構
3. 一個測試只驗證一個行為」
```

**為什麼這樣好**：
- AI 知道你的開發方式
- AI 會生成符合 TDD 風格的測試
- 明確的期望減少來回溝通

---

### 實踐 2：讓 AI 生成「最簡」實作

**好的提示**：
```
「現在我有這個失敗的測試：
[貼上測試程式碼]

請實作 TaskManager 類別，用『最簡單』的方式讓測試通過。

記住：
1. 不要過度設計
2. 只實作測試要求的功能
3. 不要添加測試沒要求的功能」
```

**為什麼這樣好**：
- 強調「最簡」會讓 AI 避免過度設計
- 明確限制範圍
- 保持 TDD 的精神

---

### 實踐 3：與 AI 討論設計決策

**好的對話**：
```
你：「我在想 complete_task() 方法，
     有兩種設計：
     1. complete_task(task_id)
     2. task.complete()

     你覺得哪個更好？為什麼？」

AI：「我建議用 complete_task(task_id)，原因：
     1. 封裝更好（TaskManager 控制狀態變更）
     2. 便於添加驗證邏輯
     3. 便於記錄歷史（未來可能需要）

     但如果任務是完全獨立的實體，
     task.complete() 也是合理的設計。」

你：「好的，我採用第一種設計。請幫我實作。」
```

**為什麼這樣好**：
- AI 可以提供不同的視角
- 討論幫助你理解設計權衡
- 最終決策權在你手上

---

### 實踐 4：用 AI 檢查測試品質

**好的提示**：
```
「請檢查我的測試程式碼：
[貼上測試程式碼]

檢查這些方面：
1. 測試是否清晰且易讀？
2. 是否測試了行為而非實作細節？
3. 是否有遺漏的邊界情況？
4. 測試名稱是否描述性強？
5. 是否有不必要的重複？

請給我具體的改進建議。」
```

**AI 可能的回應**：
```
「你的測試整體不錯，但有幾個改進建議：

1. test_create_task() 可以更具體：
   改名為 test_user_can_create_task_with_title()

2. 缺少邊界情況測試：
   - 空標題應該怎麼處理？
   - 超長標題應該怎麼處理？

3. 重複的設置可以提取：
   建議使用 pytest fixture

4. 斷言可以更嚴格：
   除了檢查 title，也檢查 is_completed 的初始值」
```

---

### 實踐 5：讓 AI 協助重構

**好的提示**：
```
「我的 TaskManager 類別變複雜了：
[貼上程式碼]

我想重構它，目標：
1. 提取重複的邏輯
2. 改善方法命名
3. 分離關注點

請建議重構步驟，並幫我逐步實作。
記住：每次重構後測試都要通過。」
```

**AI 會給出漸進式的重構步驟**：
```
「好的，我建議分三步重構：

步驟 1：提取任務查找邏輯
[程式碼]
→ 執行測試確認通過

步驟 2：提取任務過濾邏輯
[程式碼]
→ 執行測試確認通過

步驟 3：改善方法命名
[程式碼]
→ 執行測試確認通過」
```

---

## 🎯 總結

### TDD 的核心價值

1. **測試驅動設計**：測試迫使你思考介面和設計
2. **即時回饋**：幾分鐘內知道程式碼是否正確
3. **重構保護**：測試讓你敢放心改程式碼
4. **活文檔**：測試永遠反映最新的行為

### AI 輔助 TDD 的威力

1. **速度提升 3-5 倍**：AI 處理重複性工作
2. **品質提升**：AI 提醒邊界情況
3. **學習加速**：看 AI 示範最佳實踐
4. **降低門檻**：新手也能快速上手 TDD

### 關鍵原則（務必記住）

1. **測試先行**：永遠先寫測試
2. **小步迭代**：一次只做一件事
3. **持續重構**：保持程式碼乾淨
4. **人類把關**：AI 加速，人類判斷

---

## 📚 延伸閱讀

- **Kent Beck - Test Driven Development: By Example**
- **Martin Fowler - Refactoring: Improving the Design of Existing Code**
- **Robert C. Martin - Clean Code**

---

## 🔗 下一步

完成本章後，繼續學習：

➡️ **4.2 行為驅動開發與 Gherkin**
- 從使用者角度寫測試
- Gherkin 語法速成
- BDD 與 TDD 的協同使用

**實作建議**：
在進入下一章前，先完成一個完整的 TDD 練習：
- 選擇情境題庫中的一題
- 嚴格遵循紅-綠-重構循環
- 體驗完整的 TDD 流程
- 建立肌肉記憶

---

**TDD 是一種習慣，不是技術。**
**開始練習，讓它成為你的自然反應！**
