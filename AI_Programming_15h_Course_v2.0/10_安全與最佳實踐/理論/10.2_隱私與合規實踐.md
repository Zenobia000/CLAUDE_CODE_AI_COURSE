# 10.2 隱私與合規實踐

> **核心問題**: 與 AI 協作時,如何保護敏感資訊並遵守企業合規要求?
>
> **學習目標**: 建立「AI 上下文清理」的本能反應,掌握 3-Step 安全工作流

---

## 為什麼隱私保護很重要?

### 真實事件: Samsung 機密洩漏

**2023 年 4 月**,Samsung 半導體部門發生三起資訊洩漏事件:

#### 事件 1: 晶片設計洩漏
```
工程師問題: "幫我優化這段 HDL 代碼的效能"
[貼上包含專有晶片設計邏輯的完整代碼]

風險:
- 晶片設計細節被 AI 記錄
- 可能出現在未來對其他用戶的建議中
- 商業機密洩漏給競爭對手
```

#### 事件 2: 會議記錄洩漏
```
工程師問題: "總結這份會議記錄並生成待辦事項"
[貼上包含未發布產品規格和發布時程的會議筆記]

風險:
- 產品路線圖洩漏
- 競爭對手可能預測 Samsung 策略
```

#### 事件 3: 測試數據洩漏
```
工程師問題: "幫我分析這些測試數據找出問題"
[上傳包含良率、缺陷率等敏感製造數據的檔案]

風險:
- 製造流程機密洩漏
- 可能影響股價和客戶信心
```

**後果**:
- Samsung 全面禁止員工使用公開 AI 工具
- 開始部署企業級私有 AI 解決方案
- 估計損失: 潛在數億美元的競爭優勢

---

## 什麼資訊不該與 AI 共享?

### 四級敏感資訊分類

```
┌─────────────────────────────────────────────────────┐
│  Level 1: 絕對禁止 (Never Share)                   │
│  ─────────────────────────────────────────────────  │
│  • 生產環境憑證 (API keys, passwords, tokens)      │
│  • 客戶個人資料 (PII: 姓名、電話、地址、身分證號)  │
│  • 金融資訊 (信用卡號、銀行帳戶)                   │
│  • 醫療記錄 (受 HIPAA 保護的資料)                  │
│  • 加密金鑰 (SSL certificates, private keys)       │
│  ────────────────────────────────────────────────── │
│  違反後果: 法律責任、資料洩漏、客戶信任喪失         │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  Level 2: 高度機密 (Highly Confidential)           │
│  ─────────────────────────────────────────────────  │
│  • 商業機密 (專有演算法、商業策略)                 │
│  • 未發布產品細節 (功能規格、發布計劃)             │
│  • 內部系統架構 (完整的網路拓撲、安全配置)         │
│  • 財務數據 (營收、成本結構)                       │
│  ────────────────────────────────────────────────── │
│  違反後果: 競爭優勢喪失、股價影響                   │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  Level 3: 內部使用 (Internal Use)                  │
│  ─────────────────────────────────────────────────  │
│  • 內部文檔 (未公開的技術文件)                     │
│  • 員工資訊 (非公開的組織架構)                     │
│  • 測試數據 (可能包含真實資料樣本)                 │
│  • 詳細日誌 (可能包含敏感資訊)                     │
│  ────────────────────────────────────────────────── │
│  建議: 僅與企業級私有 AI 共享,不使用公開 AI         │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  Level 4: 可共享 (Safe to Share)                   │
│  ─────────────────────────────────────────────────  │
│  • 公開文檔和教學範例                               │
│  • 去識別化的合成數據                               │
│  • 通用的程式碼模式 (不含業務邏輯)                 │
│  • 錯誤訊息 (已清理敏感資訊)                       │
│  ────────────────────────────────────────────────── │
│  條件: 經過清理處理,不包含任何識別資訊               │
└─────────────────────────────────────────────────────┘
```

---

## 實戰指南: 如何清理上下文

### 場景 1: 請求代碼審查

#### ❌ 錯誤做法

```python
# 直接貼上生產代碼
import boto3
from stripe import stripe

stripe.api_key = "sk_live_51N..."  # 真實 Stripe key
s3_client = boto3.client(
    's3',
    aws_access_key_id='AKIAIOSFODNN7...',  # 真實 AWS key
    aws_secret_access_key='wJalrXUtnFEMI...'
)

def process_payment(customer_id, amount):
    # 獲取客戶資料
    customer = Customer.objects.get(id=customer_id)
    # customer.email = "john.doe@example.com"
    # customer.card_number = "4532-1234-5678-9010"

    # 處理付款
    charge = stripe.Charge.create(
        amount=amount,
        currency="usd",
        customer=customer.stripe_id
    )
```

**問題**:
- 洩漏真實 API 憑證
- 包含客戶資料範例
- 可能洩漏業務邏輯

---

#### ✅ 正確做法

```python
# 清理後的版本
import os
import boto3
from stripe import stripe

# 使用環境變數 (不洩漏實際值)
stripe.api_key = os.getenv('STRIPE_API_KEY')
s3_client = boto3.client('s3')  # 使用 AWS credentials chain

def process_payment(customer_id, amount):
    """
    Process payment for a customer

    我想要審查這個付款處理流程的安全性:
    1. 是否有潛在的錯誤處理問題?
    2. amount 參數是否需要額外驗證?
    3. 是否應該添加重試邏輯?
    """
    customer = Customer.objects.get(id=customer_id)

    try:
        charge = stripe.Charge.create(
            amount=amount,
            currency="usd",
            customer=customer.payment_provider_id
        )
        return charge
    except stripe.error.CardError as e:
        # 處理卡片錯誤
        logger.error(f"Card error: {e.user_message}")
        raise PaymentError(e.user_message)
```

**改進**:
- 移除所有憑證,使用環境變數模式
- 移除真實客戶資料
- 模糊業務字段名稱 (`stripe_id` → `payment_provider_id`)
- 聚焦於具體問題,而非貼上完整代碼

---

### 場景 2: 除錯幫助

#### ❌ 錯誤做法

```
我的程式崩潰了,這是完整的錯誤日誌:

[2024-01-15 10:23:45] ERROR: Database connection failed
Connection string: postgresql://admin:P@ssw0rd123@db.company.internal:5432/production_db
User: admin@company.com
IP: 192.168.1.50
Session token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjM...

Traceback (most recent call last):
  File "/home/user/company-project/src/payment/processor.py", line 45
    customer_card = decrypt_card_number(encrypted_data, MASTER_KEY)
ValueError: Decryption failed for card ending in 9010
```

**洩漏的資訊**:
- 資料庫連接字串和密碼
- 內部網路架構
- 員工郵箱
- Session token
- 專案路徑結構
- 支付卡資訊

---

#### ✅ 正確做法

```
我的 PostgreSQL 連接在生產環境失敗,但開發環境正常:

錯誤訊息:
[TIMESTAMP] ERROR: Database connection failed
psycopg2.OperationalError: could not connect to server

連接配置 (已清理):
- 使用 connection pool (max_connections=20)
- 使用 SSL (sslmode=require)
- 通過環境變數載入憑證

問題:
1. 錯誤訊息不明確,如何增加診斷資訊?
2. 是否應該添加連接重試邏輯?
3. 如何在不洩漏憑證的情況下記錄連接失敗?

相關代碼 (簡化版):
```python
def get_db_connection():
    conn_params = {
        'host': os.getenv('DB_HOST'),
        'database': os.getenv('DB_NAME'),
        # ... 其他參數從環境變數載入
    }
    return psycopg2.connect(**conn_params)
```

**改進**:
- 移除所有真實憑證和網路資訊
- 清理錯誤日誌中的敏感資訊
- 聚焦於問題本身,而非洩漏完整上下文

---

### 場景 3: 數據分析請求

#### ❌ 錯誤做法

```
幫我分析這個 CSV 檔案找出異常:

user_id,email,purchase_amount,credit_card
1001,john.smith@gmail.com,299.99,4532-1234-5678-9010
1002,mary.jones@yahoo.com,1499.00,5425-9876-5432-1098
1003,bob.wilson@hotmail.com,89.99,3782-822463-10005
...
```

**問題**:
- 包含真實客戶 PII
- 信用卡號 (即使部分遮蔽仍不應共享)
- 可識別個人的消費記錄

---

#### ✅ 正確做法

**方案 1: 使用合成數據**

```
幫我分析這個購買數據找出異常模式:

user_id,purchase_amount,purchase_category,is_anomaly
U001,299.99,electronics,0
U002,1499.00,electronics,0
U003,89.99,books,0
U004,25000.00,electronics,1  # 異常高額
U005,299.99,electronics,0
...

數據說明:
- 10,000 筆交易記錄
- purchase_amount 範圍: $10 - $30,000
- 預期異常率: <1%

我想要:
1. 使用統計方法識別異常值
2. 考慮不同類別的正常範圍差異
3. 建議閾值設置策略
```

**方案 2: 使用聚合數據**

```
幫我分析以下交易統計:

統計摘要:
- 總交易數: 10,234
- 平均交易額: $345.67
- 中位數: $189.00
- 標準差: $523.45
- 95th percentile: $1,200.00
- 99th percentile: $3,500.00

異常案例特徵 (已去識別):
- 案例 A: 金額 $25,000 (正常範圍的 72x)
- 案例 B: 單用戶 24 小時內交易 15 次
- 案例 C: 凌晨 3AM 高額交易

問題: 如何設計異常檢測演算法?
```

---

## 合規考量

### GDPR (歐盟一般資料保護規範)

#### 核心原則

```
┌─────────────────────────────────────────────────────┐
│  GDPR 與 AI 協作的關鍵要求                          │
│  ─────────────────────────────────────────────────  │
│                                                     │
│  1. 資料最小化 (Data Minimization)                 │
│     → 只與 AI 共享完成任務所需的最少資訊            │
│                                                     │
│  2. 目的限制 (Purpose Limitation)                  │
│     → 資料只能用於明確的原始目的                    │
│     → 不得將客戶資料用於「訓練 AI」                 │
│                                                     │
│  3. 資料主體權利 (Data Subject Rights)             │
│     → 客戶有權知道其資料是否被分享給 AI             │
│     → 客戶有權要求刪除                              │
│                                                     │
│  4. 問責制 (Accountability)                        │
│     → 必須記錄何時、為何、與哪個 AI 共享資料        │
│                                                     │
└─────────────────────────────────────────────────────┘
```

#### 實踐清單

```markdown
## GDPR 合規檢查清單 (AI 協作)

### 使用公開 AI 工具前
- [ ] 確認不包含任何 EU 居民的個人資料?
- [ ] 已獲得資料主體同意 (如需要)?
- [ ] 已記錄資料處理活動 (DPA)?
- [ ] 已評估風險並有緩解措施?

### 使用企業 AI 工具前
- [ ] 已簽署資料處理協議 (DPA)?
- [ ] AI 供應商提供 GDPR 保證?
- [ ] 資料儲存在 EU 或有充分保護?
- [ ] 有資料刪除機制?

### 處理個人資料時
- [ ] 使用假名化或匿名化技術?
- [ ] 不可逆轉的去識別化?
- [ ] 記錄資料共享事件?
```

---

### 開源 License 合規

#### AI 生成代碼的版權問題

```
┌─────────────────────────────────────────────────────┐
│  AI 生成代碼的 License 風險                         │
│  ─────────────────────────────────────────────────  │
│                                                     │
│  問題: AI 可能複製了訓練數據中的受版權保護代碼      │
│                                                     │
│  實際案例:                                          │
│  • GitHub Copilot 被發現複製 GPL 授權代碼           │
│  • 未包含原始版權聲明和 License                     │
│  • 可能導致 License 污染                            │
│                                                     │
│  風險:                                              │
│  • 專有軟體中混入 GPL 代碼 → 整個專案需 GPL         │
│  • 商業產品違反開源 License → 法律訴訟              │
│  • 無法追溯代碼來源 → 審計困難                      │
│                                                     │
└─────────────────────────────────────────────────────┘
```

#### 緩解策略

```python
# 1. 要求 AI 說明代碼來源
"""
Prompt: "生成 JWT 驗證代碼,請註明是否參考了特定的開源專案"

AI Response: "以下代碼基於 PyJWT 官方文檔範例 (MIT License)..."
"""

# 2. 使用 License 檢測工具
# 掃描 AI 生成的代碼是否與已知開源專案相似
scancode-toolkit --license --copyright --summary ai_generated.py

# 3. 記錄 AI 生成代碼的出處
# 在 commit message 中標記
git commit -m "feat: add JWT validation (AI-generated, verified MIT compatible)"

# 4. 定期審查
# 使用工具比對 AI 代碼與開源倉庫
sourcegraph search "exact_code_snippet"
```

---

## 3-Step 安全工作流

建立一個系統化流程,在每次與 AI 協作時執行:

```
┌─────────────────────────────────────────────────────┐
│  Step 1: Generate (生成)                            │
│  ─────────────────────────────────────────────────  │
│  目標: 充分利用 AI 的生成能力                       │
│                                                     │
│  允許:                                              │
│  ✅ 詳細描述功能需求                                │
│  ✅ 提供通用的程式碼模式                            │
│  ✅ 分享公開文檔和技術規格                          │
│  ✅ 使用合成數據範例                                │
│                                                     │
│  禁止:                                              │
│  ❌ 包含任何真實憑證                                │
│  ❌ 包含客戶個人資料                                │
│  ❌ 洩漏商業機密                                    │
│                                                     │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 2: Sanitize (清理)                            │
│  ─────────────────────────────────────────────────  │
│  目標: 如需提供上下文,先徹底清理                    │
│                                                     │
│  檢查清單:                                          │
│  □ 所有憑證已替換為 os.getenv('VAR') ?             │
│  □ 所有個人資料已移除或假名化?                      │
│  □ 所有內部網路資訊已清除?                          │
│  □ 所有商業邏輯已泛化?                              │
│  □ 所有錯誤訊息已清理?                              │
│                                                     │
│  工具:                                              │
│  • Regex 替換: s/password=.*/password=<REDACTED>/  │
│  • 假名化工具: Faker, anonymizer                    │
│  • 手動審查: 逐行檢查                               │
│                                                     │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 3: Validate (驗證)                            │
│  ─────────────────────────────────────────────────  │
│  目標: 確保 AI 生成的代碼安全且合規                 │
│                                                     │
│  安全驗證:                                          │
│  □ 過一遍 Top 5 安全陷阱檢查清單                    │
│  □ 運行 semgrep/bandit 掃描                         │
│  □ 檢查是否引入新的依賴 (License 合規)              │
│                                                     │
│  合規驗證:                                          │
│  □ 代碼不包含客戶資料殘留                           │
│  □ 日誌輸出不洩漏敏感資訊                           │
│  □ 記錄 AI 協作事件 (如企業要求)                    │
│                                                     │
│  整合驗證:                                          │
│  □ 本地測試通過                                     │
│  □ CI/CD 安全掃描通過                               │
│  □ Code review 包含 AI 生成標記                     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 實戰模板

### 模板 1: AI 上下文清理 Checklist

列印並放在桌上,每次與 AI 互動前過一遍:

```markdown
# 🔒 AI 上下文清理檢查清單

## 憑證與秘密
- [ ] 所有密碼已移除或替換為 `os.getenv('VAR')`
- [ ] 所有 API keys 已移除
- [ ] 所有 tokens 已移除
- [ ] 資料庫連接字串已清理

## 個人資料 (PII)
- [ ] 姓名已移除或假名化
- [ ] 電子郵件地址已移除
- [ ] 電話號碼已移除
- [ ] 地址資訊已移除
- [ ] 身分證/護照號碼已移除

## 內部資訊
- [ ] 內部網路 IP 已移除
- [ ] 伺服器主機名已泛化
- [ ] 專案路徑已清理
- [ ] 員工姓名/郵箱已移除

## 商業機密
- [ ] 專有演算法已泛化
- [ ] 商業邏輯已簡化
- [ ] 客戶名稱已移除
- [ ] 財務數據已移除

## 測試數據
- [ ] 使用合成數據而非真實數據
- [ ] 數據已去識別化
- [ ] 數據量已最小化

---

✅ 所有項目確認後,才可與 AI 共享上下文
```

---

### 模板 2: 安全事件應急流程

當發現憑證或敏感資訊洩漏時:

```markdown
# 🚨 憑證洩漏應急處理流程

## 第一時間 (0-15 分鐘)

### 1. 撤銷憑證 (最高優先)
```bash
# AWS
aws iam delete-access-key --access-key-id AKIA...

# GitHub
# 前往 Settings → Developer settings → Personal access tokens → Revoke

# Stripe
# Dashboard → Developers → API keys → Roll key
```

### 2. 評估影響範圍
- [ ] 檢查憑證使用日誌,是否有異常活動?
- [ ] 檢查 Git 歷史,憑證存在多久?
- [ ] 檢查是否已推送到遠端?
- [ ] 檢查遠端倉庫是否公開?

---

## 短期處理 (15-60 分鐘)

### 3. 清理 Git 歷史

**如果還沒 push**:
```bash
# 修改最後一次 commit
git commit --amend

# 或重置到安全的 commit
git reset --hard HEAD~1
```

**如果已經 push 但倉庫是私有的**:
```bash
# 使用 BFG Repo-Cleaner
java -jar bfg.jar --replace-text passwords.txt repo.git
cd repo.git
git reflog expire --expire=now --all
git gc --prune=now --aggressive
git push --force
```

**如果倉庫是公開的**:
- ⚠️ 假設憑證已被洩漏
- ⚠️ 立即撤銷憑證
- ⚠️ 清理歷史但不依賴這能完全解決問題
- ⚠️ 通知安全團隊

### 4. 生成新憑證
```bash
# 生成新的安全憑證
# 使用密碼管理器生成強密碼
# 更新 .env 檔案
# 測試新憑證可用性
```

---

## 長期預防 (1-24 小時)

### 5. 建立防護機制
```bash
# 安裝 git-secrets
git secrets --install
git secrets --register-aws

# 設置 pre-commit hooks
pip install pre-commit
pre-commit install

# 添加 .gitignore 規則
echo ".env" >> .gitignore
echo "*.key" >> .gitignore
echo "*.pem" >> .gitignore
```

### 6. 團隊溝通
- [ ] 通知團隊成員事件詳情
- [ ] 分享教訓學習
- [ ] 更新團隊安全指南
- [ ] 安排安全培訓

### 7. 事後檢討
- [ ] 記錄事件時間線
- [ ] 分析根本原因
- [ ] 制定預防措施
- [ ] 更新應急流程

---

## 預防清單 (持續執行)

- [ ] 所有專案已設置 git-secrets
- [ ] 所有專案已設置 pre-commit hooks
- [ ] .env 檔案已加入 .gitignore
- [ ] 定期審查 GitHub secret scanning alerts
- [ ] 使用密碼管理器管理憑證
- [ ] 啟用 2FA (Two-Factor Authentication)
```

---

## 企業級最佳實踐

### 私有 AI 部署考量

```
┌─────────────────────────────────────────────────────┐
│  何時需要私有 AI 部署?                              │
│  ─────────────────────────────────────────────────  │
│                                                     │
│  必須使用私有部署:                                  │
│  • 處理客戶 PII (金融、醫療等受監管行業)            │
│  • 包含商業機密 (專有演算法、產品規格)              │
│  • 合規要求 (GDPR, HIPAA, SOC2)                    │
│  • 競爭敏感資訊 (策略、定價)                        │
│                                                     │
│  可使用公開 AI:                                     │
│  • 通用程式設計問題                                 │
│  • 公開文檔和範例                                   │
│  • 已充分清理的代碼片段                             │
│  • 學習和實驗                                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 私有 AI 解決方案選項

```bash
# 1. 自託管開源模型
# Ollama (本地運行)
ollama run codellama

# LM Studio (GUI)
# https://lmstudio.ai/

# 2. 企業級 AI 服務
# Azure OpenAI (私有部署)
# - 數據不用於訓練
# - 支援 VNet integration
# - 符合企業合規

# AWS Bedrock
# - 數據不離開 AWS 環境
# - 支援 VPC endpoint

# 3. GitHub Copilot Enterprise
# - 基於企業程式碼訓練
# - 數據不洩漏到公開模型
```

---

## 學習驗證

完成本節後,你應該能夠:

1. **識別敏感資訊**: 快速判斷哪些資訊不該與 AI 共享
2. **清理上下文**: 在與 AI 互動前徹底清理敏感資訊
3. **執行 3-Step 工作流**: Generate → Sanitize → Validate
4. **應急處理**: 當發現洩漏時,在 15 分鐘內完成憑證撤銷
5. **合規意識**: 理解 GDPR 和 License 對 AI 協作的影響

---

## 實戰練習

### 練習 1: 上下文清理

清理以下代碼片段,使其適合與 AI 共享:

```python
import smtplib
from email.mime.text import MIMEText

# Email configuration
SMTP_SERVER = "smtp.company-internal.com"
SMTP_PORT = 587
EMAIL_USER = "noreply@company.com"
EMAIL_PASSWORD = "P@ssw0rd!2024"

# Customer database
DB_HOST = "10.0.1.50"
DB_USER = "admin"
DB_PASS = "db_admin_2024"

def send_invoice(customer_email, amount, invoice_id):
    """Send invoice to customer"""
    msg = MIMEText(f"""
    Dear Valued Customer,

    Your invoice #{invoice_id} for ${amount} is ready.

    Customer: {customer_email}
    Amount: ${amount}
    """)

    msg['Subject'] = f'Invoice #{invoice_id}'
    msg['From'] = EMAIL_USER
    msg['To'] = customer_email

    with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
        server.login(EMAIL_USER, EMAIL_PASSWORD)
        server.send_message(msg)

# Test
send_invoice("john.doe@gmail.com", 299.99, "INV-2024-001")
```

<details>
<summary>點擊查看清理後版本</summary>

```python
import smtplib
import os
from email.mime.text import MIMEText

# Email configuration (使用環境變數)
SMTP_SERVER = os.getenv('SMTP_SERVER')
SMTP_PORT = int(os.getenv('SMTP_PORT', 587))
EMAIL_USER = os.getenv('EMAIL_USER')
EMAIL_PASSWORD = os.getenv('EMAIL_PASSWORD')

# Database configuration (移除,不相關)
# DB 連接代碼已移除,與郵件功能無關

def send_invoice(customer_email, amount, invoice_id):
    """
    Send invoice email to customer

    問題: 這個郵件發送函數需要改進:
    1. 如何添加錯誤處理 (SMTP 連接失敗)?
    2. 是否應該使用 HTML 模板而非純文字?
    3. 如何實作重試邏輯?
    """
    msg = MIMEText(f"""
    Dear Valued Customer,

    Your invoice #{invoice_id} for ${amount} is ready.
    """)

    msg['Subject'] = f'Invoice #{invoice_id}'
    msg['From'] = EMAIL_USER
    msg['To'] = customer_email

    try:
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()
            server.login(EMAIL_USER, EMAIL_PASSWORD)
            server.send_message(msg)
    except smtplib.SMTPException as e:
        # TODO: 需要更好的錯誤處理
        logger.error(f"Failed to send email: {e}")
        raise

# 測試使用合成數據
# send_invoice("test@example.com", 100.00, "TEST-001")
```

**清理項目**:
1. ✅ 密碼改為環境變數
2. ✅ 內部 SMTP 伺服器主機名改為通用變數
3. ✅ 內部 IP 完全移除
4. ✅ 真實客戶郵箱改為測試郵箱
5. ✅ 聚焦於技術問題,而非完整業務邏輯

</details>

---

## 下一步

完成本節後:

1. **列印清單**: 列印「AI 上下文清理檢查清單」放在桌上
2. **設置工具**: 按照 `工具整合/` 指南設置 git-secrets
3. **實戰演練**: 完成 `情境題庫/` 中的隱私保護情境
4. **團隊分享**: 與團隊討論 AI 協作的隱私政策

---

**記住**:

> **「與 AI 共享上下文就像在公開論壇發問 — 假設你說的每一句話都會被記錄」**

在 AI 時代,隱私保護不是一次性的任務,而是每次互動時的本能反應。
