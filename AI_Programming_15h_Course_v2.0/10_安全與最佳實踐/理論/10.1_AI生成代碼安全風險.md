# 10.1 AI 生成代碼安全風險

> **核心問題**: AI 生成的代碼有哪些常見安全漏洞?如何快速識別與修復?
>
> **學習目標**: 掌握 Top 5 AI 安全陷阱,建立代碼審查肌肉記憶

---

## 為什麼 AI 會生成不安全的代碼?

在深入具體漏洞前,先理解 AI 為何容易產生安全問題:

### 1. 訓練數據偏差

AI 模型的訓練數據來自:
- **GitHub 公開倉庫**: 包含大量教學範例和概念驗證代碼
- **Stack Overflow**: 快速解答往往犧牲安全性換取簡潔
- **技術文檔**: 範例代碼通常省略安全細節以突出功能

**結果**: AI 學到的是「功能優先」的代碼模式,而非「安全優先」

---

### 2. 上下文理解局限

```python
# 開發者問: "如何連接資料庫?"
# AI 看到的上下文: 只有這句話
# AI 不知道的:
# - 這是生產環境還是開發環境?
# - 是否有企業安全策略?
# - 資料庫是否包含敏感資料?

# AI 的回答 (基於統計最常見的模式):
import psycopg2
conn = psycopg2.connect(
    host="localhost",
    database="mydb",
    user="admin",
    password="password123"  # ⚠️ 硬編碼憑證!
)
```

**教訓**: AI 無法理解你的安全需求,除非你明確提供

---

### 3. 「快速可用」優於「安全完整」

AI 被訓練為提供能立即運行的代碼,這導致:

| AI 優先考慮 | 安全實踐要求 |
|-------------|--------------|
| 代碼簡短 | 完整的輸入驗證 |
| 立即可運行 | 安全的配置管理 |
| 少依賴 | 使用經過審核的安全庫 |
| 直觀易懂 | 防禦性編程 |

**結果**: AI 生成的「Hello World 級別」代碼可能缺少生產環境必需的安全措施

---

## Top 5 AI 生成的安全陷阱

### 陷阱 1: 硬編碼憑證 (Hardcoded Credentials)

#### 為何 AI 常犯此錯?

AI 在訓練數據中見過數以萬計的教學範例:

```python
# 常見教學範例模式
api_key = "your_api_key_here"
password = "admin"
secret = "mysecret123"
```

當你詢問「如何使用某 API」,AI 會複製這種模式。

---

#### 真實案例

**事件**: 2023 年 5 月,某開發者使用 GitHub Copilot 生成 AWS S3 上傳代碼

```python
# Copilot 建議的代碼
import boto3

s3 = boto3.client(
    's3',
    aws_access_key_id='AKIAIOSFODNN7EXAMPLE',      # ⚠️ 看起來像範例
    aws_secret_access_key='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'  # ⚠️ 但實際是真實憑證
)
```

開發者直接替換為真實憑證並 commit,18 分鐘後被自動掃描機器人發現。

---

#### 如何識別?

**紅旗信號**:
```python
# 1. 字串字面值包含敏感詞
password = "..."
api_key = "..."
token = "..."
secret = "..."
client_secret = "..."

# 2. 連接字串包含憑證
db_url = "postgresql://user:password@host/db"
mongo_uri = "mongodb://admin:pass@localhost"

# 3. 環境特定的硬編碼
if env == "production":
    api_key = "prod_key_12345"  # ⚠️ 生產憑證硬編碼!
```

---

#### 正確做法

**方案 1: 環境變數 (推薦用於大多數情況)**

```python
import os

# ❌ 錯誤
api_key = "sk-proj-abc123"

# ✅ 正確
api_key = os.getenv('OPENAI_API_KEY')
if not api_key:
    raise ValueError("OPENAI_API_KEY environment variable not set")
```

**方案 2: .env 檔案 + python-dotenv**

```python
# .env 檔案 (必須在 .gitignore 中!)
OPENAI_API_KEY=sk-proj-abc123
DATABASE_URL=postgresql://user:pass@localhost/db

# Python 代碼
from dotenv import load_dotenv
import os

load_dotenv()  # 載入 .env 檔案
api_key = os.getenv('OPENAI_API_KEY')
```

**方案 3: 雲端秘密管理 (企業環境)**

```python
# AWS Secrets Manager
import boto3
import json

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

db_credentials = get_secret('prod/database/credentials')
```

---

#### 檢測工具

```bash
# 1. git-secrets (掃描 commit)
git secrets --scan

# 2. TruffleHog (掃描歷史 commits)
trufflehog git https://github.com/user/repo

# 3. detect-secrets (Python 專案)
detect-secrets scan > .secrets.baseline
```

---

### 陷阱 2: SQL 注入 (SQL Injection)

#### 為何 AI 常犯此錯?

AI 見過大量使用字串拼接的 SQL 查詢範例 (因為它們更直觀):

```python
# Stack Overflow 上常見的「快速解答」
query = "SELECT * FROM users WHERE username = '" + username + "'"
```

這種模式在教學中很常見,但在生產環境中極度危險。

---

#### 真實攻擊場景

```python
# AI 生成的代碼
def get_user(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)
    return cursor.fetchone()

# 攻擊者輸入
username = "admin' OR '1'='1"

# 實際執行的 SQL
# SELECT * FROM users WHERE username = 'admin' OR '1'='1'
# 結果: 返回所有用戶資料!
```

**更危險的攻擊**:
```python
username = "'; DROP TABLE users; --"
# 實際執行: SELECT * FROM users WHERE username = ''; DROP TABLE users; --'
# 結果: 用戶表被刪除
```

---

#### 如何識別?

**紅旗信號**:
```python
# 1. 字串拼接 (f-string)
query = f"SELECT * FROM {table} WHERE id = {user_id}"

# 2. 字串格式化 (.format())
query = "SELECT * FROM users WHERE name = '{}'".format(name)

# 3. 字串連接 (+)
query = "DELETE FROM posts WHERE id = " + post_id

# 4. % 格式化
query = "UPDATE users SET email = '%s' WHERE id = %d" % (email, user_id)
```

**唯一安全的模式**: **參數化查詢**

---

#### 正確做法

**Python (psycopg2)**:
```python
# ❌ 錯誤: 字串拼接
query = f"SELECT * FROM users WHERE username = '{username}'"
cursor.execute(query)

# ✅ 正確: 參數化查詢
query = "SELECT * FROM users WHERE username = %s"
cursor.execute(query, (username,))  # 注意是 tuple
```

**Python (SQLite)**:
```python
# ❌ 錯誤
cursor.execute(f"SELECT * FROM posts WHERE id = {post_id}")

# ✅ 正確
cursor.execute("SELECT * FROM posts WHERE id = ?", (post_id,))
```

**Node.js (MySQL)**:
```javascript
// ❌ 錯誤
const query = `SELECT * FROM users WHERE email = '${email}'`;
connection.query(query);

// ✅ 正確
const query = 'SELECT * FROM users WHERE email = ?';
connection.query(query, [email]);
```

**使用 ORM (推薦)**:
```python
# SQLAlchemy
user = session.query(User).filter(User.username == username).first()

# Django ORM
user = User.objects.get(username=username)
```

---

#### 檢測工具

```bash
# 1. Semgrep (靜態分析)
semgrep --config "p/sql-injection" .

# 2. Bandit (Python 專用)
bandit -r . -f json -o bandit-report.json

# 3. SQLMap (動態測試)
sqlmap -u "http://example.com/search?q=test" --batch
```

---

### 陷阱 3: 路徑遍歷 (Path Traversal)

#### 為何 AI 常犯此錯?

AI 生成的檔案操作代碼往往假設輸入是可信的:

```python
# AI 常見模式: 直接拼接路徑
file_path = f"/uploads/{filename}"
with open(file_path) as f:
    content = f.read()
```

---

#### 真實攻擊場景

```python
# AI 生成的檔案下載功能
@app.route('/download/<filename>')
def download_file(filename):
    file_path = f"/var/www/uploads/{filename}"
    return send_file(file_path)

# 攻擊者請求
# GET /download/../../../../etc/passwd
# 實際路徑: /var/www/uploads/../../../../etc/passwd
#         = /etc/passwd
# 結果: 攻擊者下載了系統密碼檔案
```

---

#### 如何識別?

**紅旗信號**:
```python
# 1. 直接拼接用戶輸入
path = base_dir + "/" + user_input

# 2. f-string 拼接路徑
path = f"{upload_dir}/{filename}"

# 3. os.path.join 但未驗證
path = os.path.join(base_dir, user_filename)  # ⚠️ 仍不安全!

# 4. 讀取用戶指定的檔案
with open(request.args.get('file')) as f:  # ⚠️ 極度危險!
    content = f.read()
```

---

#### 正確做法

**方案 1: 使用 pathlib 驗證 (Python 3.9+)**

```python
from pathlib import Path

UPLOAD_DIR = Path("/var/www/uploads")

def safe_file_read(filename):
    # 1. 建構完整路徑
    file_path = UPLOAD_DIR / filename

    # 2. 解析為絕對路徑
    resolved_path = file_path.resolve()

    # 3. 驗證路徑在允許的目錄內
    if not resolved_path.is_relative_to(UPLOAD_DIR):
        raise ValueError(f"Invalid file path: {filename}")

    # 4. 驗證檔案存在
    if not resolved_path.is_file():
        raise FileNotFoundError(f"File not found: {filename}")

    # 5. 安全讀取
    return resolved_path.read_text()
```

**方案 2: 白名單驗證**

```python
import os
import re

ALLOWED_EXTENSIONS = {'.txt', '.pdf', '.jpg', '.png'}
UPLOAD_DIR = "/var/www/uploads"

def safe_download(filename):
    # 1. 驗證檔名格式 (只允許字母數字和 . _ -)
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")

    # 2. 驗證副檔名
    _, ext = os.path.splitext(filename)
    if ext.lower() not in ALLOWED_EXTENSIONS:
        raise ValueError("File type not allowed")

    # 3. 建構路徑並驗證
    file_path = os.path.normpath(os.path.join(UPLOAD_DIR, filename))
    if not file_path.startswith(UPLOAD_DIR):
        raise ValueError("Path traversal detected")

    return file_path
```

**方案 3: 使用檔案 ID 而非檔名**

```python
# ✅ 最安全的做法: 不直接使用用戶提供的檔名
import uuid

# 上傳時生成唯一 ID
file_id = str(uuid.uuid4())
file_mapping = {
    file_id: {
        'original_name': 'user_upload.pdf',
        'stored_path': f'/uploads/{file_id}.pdf'
    }
}

# 下載時使用 ID
@app.route('/download/<file_id>')
def download(file_id):
    file_info = file_mapping.get(file_id)
    if not file_info:
        return "File not found", 404
    return send_file(file_info['stored_path'])
```

---

### 陷阱 4: 不安全的反序列化 (Insecure Deserialization)

#### 為何 AI 常犯此錯?

Python 的 `pickle` 模組在範例代碼中很常見 (因為它簡單),但它極度危險。

---

#### 真實攻擊場景

```python
# AI 生成的 session 管理代碼
import pickle
import base64

def save_session(user_data):
    serialized = pickle.dumps(user_data)
    return base64.b64encode(serialized).decode()

def load_session(session_cookie):
    serialized = base64.b64decode(session_cookie)
    return pickle.loads(serialized)  # ⚠️ 危險!

# 攻擊者可以構造惡意 pickle 數據
# 當 pickle.loads() 執行時,可以執行任意代碼!
```

**攻擊 Payload 範例**:
```python
import pickle
import os

class Exploit:
    def __reduce__(self):
        # 當被反序列化時,執行 rm -rf /
        return (os.system, ('rm -rf /',))

malicious_data = pickle.dumps(Exploit())
# 當受害者執行 pickle.loads(malicious_data) 時...
```

---

#### 如何識別?

**紅旗信號**:
```python
# 1. pickle.loads() 任何外部數據
pickle.loads(user_input)
pickle.loads(request.data)
pickle.loads(base64.b64decode(cookie))

# 2. PyYAML 的 unsafe loader
yaml.load(user_input)  # ⚠️ 使用 yaml.safe_load() 代替

# 3. eval() 或 exec() 用戶輸入
eval(request.args.get('calc'))  # ⚠️ 絕對禁止!
```

---

#### 正確做法

**方案 1: 使用 JSON (推薦)**

```python
import json

# ❌ 錯誤
import pickle
data = pickle.loads(user_input)

# ✅ 正確
import json
data = json.loads(user_input)
```

**方案 2: 使用 Pydantic 驗證**

```python
from pydantic import BaseModel, ValidationError

class UserData(BaseModel):
    username: str
    email: str
    age: int

# 安全的反序列化
try:
    user = UserData.parse_raw(json_string)
except ValidationError as e:
    print(f"Invalid data: {e}")
```

**方案 3: 如果必須使用 pickle,簽名驗證**

```python
import hmac
import hashlib
import pickle

SECRET_KEY = os.getenv('SECRET_KEY')

def safe_pickle_dumps(obj):
    data = pickle.dumps(obj)
    signature = hmac.new(SECRET_KEY.encode(), data, hashlib.sha256).digest()
    return signature + data

def safe_pickle_loads(signed_data):
    signature = signed_data[:32]
    data = signed_data[32:]

    # 驗證簽名
    expected_sig = hmac.new(SECRET_KEY.encode(), data, hashlib.sha256).digest()
    if not hmac.compare_digest(signature, expected_sig):
        raise ValueError("Invalid signature")

    return pickle.loads(data)
```

---

### 陷阱 5: 過度權限 (Excessive Permissions)

#### 為何 AI 常犯此錯?

AI 生成的系統管理腳本往往使用最寬鬆的權限以「確保能運行」。

---

#### 真實案例

```bash
# AI 生成的部署腳本
#!/bin/bash

# 設置配置檔案
chmod 777 config.json  # ⚠️ 任何人都可讀寫執行!

# 安裝依賴
sudo pip install -r requirements.txt  # ⚠️ 不應使用 sudo!

# 啟動服務
sudo python app.py  # ⚠️ 以 root 權限運行應用!
```

**風險**:
- `chmod 777` 讓任何用戶都能修改配置檔案 (可能包含憑證)
- `sudo pip` 可能安裝惡意套件到系統級別
- `sudo python` 讓應用程式有完整系統權限

---

#### 如何識別?

**紅旗信號**:
```bash
# 1. chmod 777 或 666
chmod 777 file.sh
chmod 666 config.json

# 2. 不必要的 sudo
sudo npm install
sudo python script.py
sudo chmod +x app

# 3. 以 root 運行服務
docker run --privileged ...
su root -c "python app.py"
```

---

#### 正確做法

**最小權限原則**:

```bash
# ❌ 錯誤: 過度權限
chmod 777 config.json

# ✅ 正確: 最小權限
chmod 600 config.json  # 只有擁有者可讀寫
chmod 400 secret.key   # 只有擁有者可讀

# ❌ 錯誤: 使用 sudo 安裝 Python 套件
sudo pip install requests

# ✅ 正確: 使用虛擬環境
python -m venv venv
source venv/bin/activate
pip install requests

# ❌ 錯誤: 以 root 運行應用
sudo python app.py

# ✅ 正確: 以專用用戶運行
sudo useradd -r -s /bin/false appuser
sudo -u appuser python app.py
```

**Docker 安全實踐**:
```dockerfile
# ❌ 錯誤: 以 root 運行
FROM python:3.11
COPY . /app
CMD ["python", "app.py"]

# ✅ 正確: 建立非 root 用戶
FROM python:3.11
RUN useradd -m -u 1000 appuser
COPY --chown=appuser:appuser . /app
USER appuser
CMD ["python", "app.py"]
```

---

## AI 代碼安全驗證清單

在接受任何 AI 生成的代碼前,逐項檢查:

```markdown
## 代碼安全檢查清單

### 憑證與秘密
- [ ] 沒有硬編碼的密碼、API keys、tokens?
- [ ] 所有敏感資訊都使用環境變數?
- [ ] .env 檔案已加入 .gitignore?
- [ ] 沒有在註解中包含真實憑證?

### 輸入驗證
- [ ] 所有用戶輸入都經過驗證?
- [ ] SQL 查詢使用參數化?
- [ ] 檔案路徑經過安全驗證?
- [ ] 沒有使用 eval() 或 exec() 處理外部輸入?

### 資料處理
- [ ] 沒有使用 pickle 反序列化不可信數據?
- [ ] 使用安全的序列化格式 (JSON)?
- [ ] 敏感資料有適當的加密?
- [ ] 錯誤訊息不洩漏敏感資訊?

### 權限管理
- [ ] 檔案權限遵守最小權限原則?
- [ ] 沒有不必要的 sudo 使用?
- [ ] 服務以非 root 用戶運行?
- [ ] 資料庫帳戶權限最小化?

### 依賴管理
- [ ] 所有依賴都來自可信來源?
- [ ] 依賴版本有明確指定?
- [ ] 沒有已知安全漏洞的依賴?
- [ ] 定期更新依賴套件?
```

---

## 自動化檢測工具配置

### 1. git-secrets 設置

```bash
# 安裝 (macOS)
brew install git-secrets

# 或從源碼安裝
git clone https://github.com/awslabs/git-secrets.git
cd git-secrets
sudo make install

# 在專案中啟用
cd your-project
git secrets --install
git secrets --register-aws  # 掃描 AWS 憑證

# 添加自訂規則
git secrets --add 'password\s*=\s*["\'][^"\']+["\']'
git secrets --add 'api[_-]?key\s*=\s*["\'][^"\']+["\']'

# 掃描現有檔案
git secrets --scan

# 掃描歷史 commits
git secrets --scan-history
```

---

### 2. pre-commit 配置

建立 `.pre-commit-config.yaml`:

```yaml
repos:
  # 檢查憑證洩漏
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']

  # 檢查敏感檔案
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-added-large-files
        args: ['--maxkb=500']
      - id: check-json
      - id: check-yaml
      - id: detect-private-key

  # Python 安全掃描
  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: ['-r', 'src/']

  # SQL 注入掃描
  - repo: https://github.com/sqlfluff/sqlfluff
    rev: 2.3.5
    hooks:
      - id: sqlfluff-lint
```

安裝並啟用:
```bash
pip install pre-commit
pre-commit install
pre-commit run --all-files  # 測試所有檔案
```

---

### 3. Semgrep 配置

建立 `.semgrep.yml`:

```yaml
rules:
  # 檢測硬編碼憑證
  - id: hardcoded-credentials
    pattern-either:
      - pattern: password = "..."
      - pattern: api_key = "..."
      - pattern: secret = "..."
    message: "Potential hardcoded credential detected"
    severity: ERROR
    languages: [python, javascript]

  # 檢測 SQL 注入
  - id: sql-injection
    pattern-either:
      - pattern: cursor.execute(f"... {$VAR} ...")
      - pattern: cursor.execute("... " + $VAR + "...")
    message: "Potential SQL injection vulnerability"
    severity: ERROR
    languages: [python]

  # 檢測 pickle 使用
  - id: unsafe-pickle
    pattern: pickle.loads($INPUT)
    message: "Unsafe deserialization with pickle"
    severity: WARNING
    languages: [python]
```

運行掃描:
```bash
semgrep --config .semgrep.yml .
# 或使用官方規則集
semgrep --config "p/security-audit" .
```

---

## 學習驗證

完成本節後,你應該能夠:

1. **快速識別**: 在 AI 生成的代碼中 30 秒內找出硬編碼憑證
2. **正確修復**: 知道如何用環境變數替換硬編碼密碼
3. **辨識注入**: 識別 SQL 注入風險並使用參數化查詢
4. **路徑安全**: 驗證檔案路徑避免目錄遍歷
5. **工具使用**: 設置至少一個自動化安全掃描工具

---

## 實戰練習

### 練習 1: 安全漏洞識別

以下代碼有多少安全問題?

```python
import pickle
import sqlite3

API_KEY = "sk-proj-abcdef123456"  # OpenAI API Key

def search_users(username):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)
    return cursor.fetchall()

def load_config(config_file):
    with open(f"/config/{config_file}") as f:
        return pickle.load(f)

def save_data(data):
    eval(f"process_{data['type']}(data)")  # 動態調用函數
```

<details>
<summary>點擊查看答案</summary>

**發現的漏洞** (共 5 個):

1. **硬編碼 API Key** (Line 4)
   - 風險: HIGH
   - 修復: 使用 `os.getenv('OPENAI_API_KEY')`

2. **SQL 注入** (Line 9)
   - 風險: CRITICAL
   - 修復: 使用參數化查詢 `cursor.execute("SELECT * FROM users WHERE username = ?", (username,))`

3. **路徑遍歷** (Line 14)
   - 風險: HIGH
   - 修復: 使用 `pathlib.Path` 驗證路徑

4. **不安全的反序列化** (Line 15)
   - 風險: CRITICAL
   - 修復: 使用 `json.load()` 替代 `pickle.load()`

5. **eval() 代碼注入** (Line 18)
   - 風險: CRITICAL
   - 修復: 使用字典映射函數 `HANDLERS[data['type']](data)`

</details>

---

### 練習 2: 代碼修復

修復上述所有安全問題:

<details>
<summary>點擊查看安全版本</summary>

```python
import json
import sqlite3
import os
from pathlib import Path

# 1. 使用環境變數
API_KEY = os.getenv('OPENAI_API_KEY')
if not API_KEY:
    raise ValueError("OPENAI_API_KEY not set")

# 2. 修復 SQL 注入
def search_users(username):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    # 使用參數化查詢
    query = "SELECT * FROM users WHERE username = ?"
    cursor.execute(query, (username,))
    return cursor.fetchall()

# 3. 修復路徑遍歷 + 不安全反序列化
CONFIG_DIR = Path("/config")

def load_config(config_file):
    # 驗證路徑
    file_path = CONFIG_DIR / config_file
    resolved = file_path.resolve()
    if not resolved.is_relative_to(CONFIG_DIR):
        raise ValueError("Invalid config file path")

    # 使用 JSON 替代 pickle
    with open(resolved) as f:
        return json.load(f)

# 4. 修復 eval() 注入
HANDLERS = {
    'user': process_user,
    'order': process_order,
}

def save_data(data):
    data_type = data.get('type')
    handler = HANDLERS.get(data_type)
    if not handler:
        raise ValueError(f"Unknown data type: {data_type}")
    return handler(data)
```

</details>

---

## 下一步

完成本節後:

1. **立即實踐**: 在你當前的專案中運行 `semgrep --config "p/security-audit" .`
2. **建立習慣**: 每次接受 AI 代碼前,過一遍 5 大陷阱檢查清單
3. **深入學習**: 閱讀 `10.2_隱私與合規實踐.md` 了解數據隱私保護
4. **實戰演練**: 完成 `情境題庫/` 中的安全情境題

---

**記住**:

> **「AI 生成的代碼像是 Stack Overflow 上的複製貼上 — 可以用,但必須先理解和驗證」**

安全不是一次性的檢查,而是每次接受 AI 代碼時的本能反應。
