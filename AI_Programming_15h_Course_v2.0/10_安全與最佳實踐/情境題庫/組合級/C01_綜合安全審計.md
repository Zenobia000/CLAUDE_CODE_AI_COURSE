# C01: 綜合安全審計

> **難度**: ⭐⭐⭐ 組合級
>
> **預計耗時**: 1.5-2 小時
>
> **核心技能**: 完整安全審計流程、多工具整合、團隊協作與報告撰寫

---

## 📖 情境描述

你剛加入一家新創公司擔任 Senior Developer。第一天上班,CTO 找你:

> 「我們的核心產品是一個 SaaS 待辦事項管理系統,已經有 500+ 付費用戶。上週我們開始大量使用 GitHub Copilot 加速開發,一個月內交付了大量新功能。
>
> 但是... 我有點擔心。我們團隊都是 Junior Developers,可能太依賴 AI 了。能不能請你做一次全面的安全審計?特別關注 AI 生成的代碼。
>
> 我們下週要做 Series A 融資,投資人會要求安全審計報告。」

---

## 專案概況

**專案**: TaskMaster Pro (待辦事項管理 SaaS)
**技術棧**: Python (Flask), SQLite, JavaScript (React)
**用戶數**: 500+ 付費用戶
**數據**: 包含用戶個人任務、日曆、檔案上傳

**關鍵檔案** (已提供):
```
taskmaster/
├── backend/
│   ├── app.py              # Flask 主應用
│   ├── models.py           # 資料庫模型
│   ├── auth.py             # 認證系統 (AI 生成)
│   ├── api_tasks.py        # 任務 API (AI 生成)
│   ├── file_upload.py      # 檔案上傳 (AI 生成)
│   └── config.py           # 配置檔案
├── frontend/
│   ├── src/TaskList.js     # 任務列表元件
│   └── src/api.js          # API 客戶端
├── .env.example
├── requirements.txt
└── README.md
```

---

## 🎯 任務目標

### 階段 1: 自動化掃描 (30 分鐘)
- [ ] 設置並執行 3 種以上安全掃描工具
- [ ] 整理掃描結果,分類問題嚴重程度
- [ ] 識別誤報並記錄

### 階段 2: 手動代碼審查 (45 分鐘)
- [ ] 審查 AI 生成的 3 個核心模組
- [ ] 檢查 Top 5 安全漏洞 (SQL 注入、XSS、CSRF 等)
- [ ] 檢查敏感資訊洩漏 (憑證、PII)
- [ ] 記錄每個問題的位置和風險等級

### 階段 3: 合規檢查 (15 分鐘)
- [ ] 檢查是否有硬編碼憑證
- [ ] 驗證 .env 和 .gitignore 配置
- [ ] 檢查日誌是否洩漏 PII
- [ ] 評估 GDPR 合規性 (用戶資料處理)

### 階段 4: 修復與加固 (20 分鐘)
- [ ] 修復至少 2 個 CRITICAL 問題
- [ ] 設置自動化防護 (git-secrets, pre-commit)
- [ ] 更新 README 添加安全最佳實踐

### 階段 5: 報告撰寫 (10 分鐘)
- [ ] 撰寫給 CTO 的執行摘要
- [ ] 詳細問題列表 (嚴重程度、位置、修復建議)
- [ ] 短期 / 長期行動計劃

---

## 📁 提供的代碼範例

### backend/auth.py (AI Generated)

```python
from flask import request, jsonify
import sqlite3
import hashlib
import jwt
import datetime

SECRET_KEY = "super_secret_key_12345"  # TODO: move to config

def hash_password(password):
    return hashlib.md5(password.encode()).hexdigest()

def create_token(user_id, username):
    payload = {
        'user_id': user_id,
        'username': username,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')

def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    email = data.get('email')

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()

    password_hash = hash_password(password)

    query = f"INSERT INTO users (username, password, email) VALUES ('{username}', '{password_hash}', '{email}')"
    try:
        cursor.execute(query)
        conn.commit()
        return jsonify({"message": "User registered successfully"}), 201
    except:
        return jsonify({"error": "Registration failed"}), 400
    finally:
        conn.close()

def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()

    password_hash = hash_password(password)
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password_hash}'"

    cursor.execute(query)
    user = cursor.fetchone()
    conn.close()

    if user:
        token = create_token(user[0], user[1])
        return jsonify({"token": token, "username": user[1]}), 200

    return jsonify({"error": "Invalid credentials"}), 401
```

### backend/file_upload.py (AI Generated)

```python
from flask import request, send_file
import os

UPLOAD_FOLDER = '/var/www/uploads'

def upload_file():
    if 'file' not in request.files:
        return {"error": "No file provided"}, 400

    file = request.files['file']
    filename = request.form.get('filename', file.filename)

    # Save file
    filepath = os.path.join(UPLOAD_FOLDER, filename)
    file.save(filepath)

    return {"message": "File uploaded", "path": filepath}, 200

def download_file():
    filename = request.args.get('file')
    filepath = f"{UPLOAD_FOLDER}/{filename}"

    if os.path.exists(filepath):
        return send_file(filepath)
    return {"error": "File not found"}, 404

def list_user_files():
    user_id = request.args.get('user_id')
    query = f"SELECT * FROM files WHERE user_id = {user_id}"

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()
    cursor.execute(query)
    files = cursor.fetchall()
    conn.close()

    return {"files": files}, 200
```

### backend/api_tasks.py (AI Generated)

```python
from flask import request, jsonify
import sqlite3

def get_tasks():
    user_id = request.args.get('user_id')
    search = request.args.get('search', '')

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()

    if search:
        query = f"SELECT * FROM tasks WHERE user_id = {user_id} AND title LIKE '%{search}%'"
    else:
        query = f"SELECT * FROM tasks WHERE user_id = {user_id}"

    cursor.execute(query)
    tasks = cursor.fetchall()
    conn.close()

    return jsonify({"tasks": tasks}), 200

def create_task():
    data = request.get_json()
    user_id = data.get('user_id')
    title = data.get('title')
    description = data.get('description')

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()

    query = f"INSERT INTO tasks (user_id, title, description) VALUES ({user_id}, '{title}', '{description}')"
    cursor.execute(query)
    conn.commit()
    conn.close()

    return jsonify({"message": "Task created"}), 201

def delete_task():
    task_id = request.args.get('id')

    conn = sqlite3.connect('taskmaster.db')
    cursor = conn.cursor()

    query = f"DELETE FROM tasks WHERE id = {task_id}"
    cursor.execute(query)
    conn.commit()
    conn.close()

    return jsonify({"message": "Task deleted"}), 200
```

---

## 🔍 審計檢查清單

### Critical Issues 檢查

- [ ] **SQL Injection**: 檢查所有 SQL 查詢
- [ ] **Hardcoded Secrets**: 搜尋憑證、API keys
- [ ] **Path Traversal**: 檢查檔案操作
- [ ] **Weak Crypto**: 檢查密碼雜湊方式
- [ ] **Authentication**: JWT 實作是否安全

### High Priority 檢查

- [ ] **Input Validation**: 用戶輸入是否驗證
- [ ] **CSRF Protection**: 是否有 CSRF token
- [ ] **XSS**: 前端是否正確 escape 輸出
- [ ] **Authorization**: 是否有權限檢查
- [ ] **Rate Limiting**: 是否有防暴力破解

### Compliance 檢查

- [ ] **GDPR**: 用戶資料是否可刪除
- [ ] **.env**: 敏感資訊是否在環境變數
- [ ] **.gitignore**: 是否包含 .env, *.db
- [ ] **Logging**: 日誌是否洩漏 PII
- [ ] **Dependencies**: 依賴是否有已知漏洞

---

## ✅ 參考解答 (精簡版)

### 發現的問題摘要

#### CRITICAL (必須立即修復)

1. **SQL Injection** - 10+ 處
   - 位置: auth.py (register, login), file_upload.py (list_user_files), api_tasks.py (所有函數)
   - 風險: 完整資料庫控制
   - 修復: 使用參數化查詢

2. **硬編碼 JWT Secret**
   - 位置: auth.py line 6
   - 風險: 攻擊者可偽造 token
   - 修復: 使用環境變數

3. **弱密碼雜湊 (MD5)**
   - 位置: auth.py line 8
   - 風險: 密碼可被破解
   - 修復: 使用 bcrypt

4. **路徑遍歷**
   - 位置: file_upload.py line 13, 19
   - 風險: 讀取/寫入任意檔案
   - 修復: 路徑驗證

#### HIGH

5. **缺少權限檢查**
   - delete_task 沒檢查任務是否屬於該用戶
   - 任何人可刪除任何任務

6. **JWT 沒驗證**
   - API 端點沒驗證 JWT token

---

### 自動化掃描命令

```bash
# 1. Bandit (Python)
bandit -r backend/ -f json -o bandit-report.json

# 2. Safety (依賴漏洞)
safety check --file requirements.txt

# 3. Semgrep (安全模式)
semgrep --config "p/security-audit" backend/

# 4. Git secrets (檢查歷史)
git secrets --scan-history

# 5. TruffleHog (深度掃描)
trufflehog git file://. --only-verified
```

---

### 安全審計報告模板

```markdown
# TaskMaster Pro 安全審計報告

## 執行摘要

**審計日期**: 2024-XX-XX
**審計範圍**: Backend API (Python/Flask)
**嚴重程度**: 🔴 CRITICAL

### 關鍵發現
- ❌ 發現 **10+ Critical** 安全漏洞
- ❌ 所有 AI 生成的代碼模組都存在 SQL 注入
- ❌ 硬編碼憑證、弱加密、缺少權限檢查
- ⚠️ **不建議在當前狀態下進行融資演示**

### 建議
1. **立即**: 修復所有 CRITICAL 問題 (預計 1-2 天)
2. **本週**: 設置自動化安全掃描 CI/CD
3. **本月**: 進行滲透測試

---

## 詳細問題列表

### C1: SQL Injection (CRITICAL)

**影響**: 攻擊者可完全控制資料庫,竊取所有用戶資料

**位置**:
- `auth.py:27` - register 函數
- `auth.py:41` - login 函數
- `file_upload.py:24` - list_user_files 函數
- `api_tasks.py:9,11,23,35` - 所有任務 API

**攻擊示範**:
```python
# 繞過登入
POST /login {"username": "admin' OR '1'='1", "password": "anything"}

# 刪除所有任務
DELETE /tasks?id=1 OR 1=1
```

**修復方案**:
```python
# ❌ 錯誤
query = f"SELECT * FROM users WHERE username = '{username}'"

# ✅ 正確
cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
```

**優先級**: P0 (立即修復)
**預計修復時間**: 4 小時

---

### C2: 硬編碼 JWT Secret (CRITICAL)

**影響**: 攻擊者可偽造任意用戶的 JWT token

**位置**: `auth.py:6`

**修復方案**:
```python
# .env
JWT_SECRET_KEY=<隨機生成的 256-bit key>

# auth.py
import os
SECRET_KEY = os.getenv('JWT_SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("JWT_SECRET_KEY not set")
```

**優先級**: P0
**預計修復時間**: 30 分鐘

---

(... 省略其他問題詳細描述 ...)

---

## 行動計劃

### 立即行動 (本週)
- [ ] 修復所有 CRITICAL 問題
- [ ] 設置 git-secrets 和 pre-commit
- [ ] 添加單元測試覆蓋安全修復

### 短期 (2 週內)
- [ ] 在 CI/CD 中集成 bandit + semgrep
- [ ] 代碼審查流程加入安全檢查清單
- [ ] 團隊安全培訓

### 中期 (1 月內)
- [ ] 第三方滲透測試
- [ ] 實作 WAF (Web Application Firewall)
- [ ] 建立安全事件響應流程

---

## 總結

TaskMaster Pro 當前存在多個嚴重安全漏洞,主要源於:
1. 過度依賴 AI 生成代碼,缺少安全審查
2. 團隊安全意識不足
3. 缺乏自動化安全掃描

**建議**: 在修復 CRITICAL 問題前,暫緩融資演示。
預計修復時間: 2-3 個工作日。
```

---

## 📝 學習檢查清單

完成此情境後,你應該能夠:

- [ ] 獨立執行完整的安全審計流程
- [ ] 使用 3+ 種自動化安全掃描工具
- [ ] 撰寫專業的安全審計報告
- [ ] 評估 AI 生成代碼的安全風險
- [ ] 制定可執行的安全改進計劃

---

## 🎯 延伸挑戰

1. **實際修復**: 重寫 auth.py,修復所有安全問題
2. **CI/CD 整合**: 設置 GitHub Actions 自動安全掃描
3. **團隊分享**: 向團隊演示安全審計流程
4. **深入學習**: 研究 OWASP Top 10 並建立檢查清單

---

**完成這個情境,你就具備了進行專業安全審計的能力!**
