# 1.2 三大工具哲學對比

## 📋 學習目標

完成本章後，你將能夠：

- ✅ 理解 GitHub Copilot、Claude Code、Gemini CLI 的核心差異
- ✅ 為不同場景選擇最適合的工具
- ✅ 設計混合工具鏈提升團隊效率
- ✅ 理解上下文管理策略的本質差異

**預計時間**：45 分鐘

---

## 🎯 情境引入：工具選擇的困境

### 情境 1.2：新專案的工具選擇

你是技術主管，需要為團隊選擇 AI 編程工具。團隊成員有不同需求：

**場景 A - 前端工程師 Bob**：
> "我每天寫大量的 React 元件，需要快速的程式碼補全，最好能預測我接下來要寫什麼。"

**場景 B - 後端工程師 Carol**：
> "我們的系統有 500+ 個檔案，我經常需要進行大規模重構，比如把所有 API 從 REST 改成 GraphQL。"

**場景 C - 新進工程師 David**：
> "我剛接手一個 10 萬行的舊專案，完全看不懂架構，需要快速理解整個系統。"

**場景 D - 技術文檔撰寫者 Eve**：
> "我需要從技術會議錄音中提取資訊、整理成文檔、翻譯成多語言、發布到 Confluence。"

### 🤔 你的任務

在繼續閱讀之前，思考以下問題：

**問題 1**：為每個場景選擇工具

```
Bob (日常編碼):  _______________
Carol (大規模重構): _______________
David (快速理解專案): _______________
Eve (知識工作): _______________
```

**問題 2**：你會選擇「一個工具通吃」還是「混合使用」？為什麼？

```
你的答案：
_______________________________________________
_______________________________________________
```

---

## 📊 三大工具核心對比

### 概覽：一張圖看懂三大工具

```
GitHub Copilot          Claude Code           Gemini CLI
IDE 內建助手            CLI 代理人平台        巨量上下文分析器
    |                      |                      |
    |                      |                      |
    v                      v                      v
[實時補全]             [工作流程編排]        [全局理解]
 快速但淺層             強大但需規劃         廣泛但一次性
    |                      |                      |
    |                      |                      |
    v                      v                      v
日常編碼               複雜任務               新專案理解
小規模重構             多步驟任務             架構分析
學習語法               自動化工作流程         快速 Onboarding
```

---

### 詳細對比表

| 維度 | GitHub Copilot | Claude Code | Gemini CLI |
|------|---------------|-------------|------------|
| **核心定位** | IDE 即時助手 | AI Agent 交互平台 | 巨量上下文分析工具 |
| **使用場景** | 日常編碼、快速補全 | 複雜重構、工作流程自動化 | 專案理解、架構分析 |
| **上下文管理** | 隱式（自動） | 顯式（手動控制） | 一次性載入 |
| **上下文大小** | ~128K tokens | ~200K tokens | 1M+ tokens |
| **記憶機制** | 儲存庫索引 | CLAUDE.md + memory | GEMINI.md + chat save |
| **學習曲線** | 低（自動運作） | 中（需要學習指令） | 中（需要理解策略） |
| **整合方式** | IDE 擴充套件 | 命令列工具 | 命令列工具 |
| **互動模式** | 即時補全、對話 | 多輪對話、工作流程 | 一次性分析、對話 |
| **程式碼品質** | 需要審查 | 需要審查 | 需要審查 |
| **自動化能力** | 低 | 高（MCP、Agents） | 中 |
| **團隊協作** | 個人工具 | 可共享上下文（CLAUDE.md） | 可共享上下文（GEMINI.md） |
| **非程式應用** | 有限 | 強（知識工作） | 中（文檔分析） |
| **訂閱費用** | $10-20/月 | $20/月（Pro） | Google Cloud 計費 |

---

## 🔍 深度分析：三大工具哲學

### 1. GitHub Copilot：「即時反應」哲學

#### 核心理念

```
開發者寫程式碼 → Copilot 即時預測 → 顯示建議 → 接受/拒絕
                    ↑
              幕後發生的事：
              1. 監控你的輸入
              2. 分析當前檔案
              3. 檢查開啟的其他檔案
              4. 搜尋儲存庫索引
              5. 生成補全建議
              6. 所有這些在 <100ms 內完成
```

#### 優勢場景

**場景 1：日常編碼**

```javascript
// 你寫：
function calculateTax(

// Copilot 立即建議：
function calculateTax(amount, rate) {
  return amount * rate;
}

// 你只需按 Tab 接受
```

**場景 2：樣板程式碼**

```python
# 你寫註解：
# Create a FastAPI endpoint for user registration

# Copilot 生成完整端點：
@app.post("/api/v1/users/register")
async def register_user(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed_password = hash_password(user.password)
    new_user = User(
        email=user.email,
        username=user.username,
        hashed_password=hashed_password
    )
    db.add(new_user)
    db.commit()
    return {"message": "User registered successfully"}
```

**場景 3：單元測試生成**

```python
# 你有這個函數：
def calculate_discount(price: float, discount_percent: float) -> float:
    return price * (1 - discount_percent / 100)

# 你寫：
def test_calculate_discount

# Copilot 生成整個測試：
def test_calculate_discount():
    assert calculate_discount(100, 10) == 90
    assert calculate_discount(100, 0) == 100
    assert calculate_discount(100, 100) == 0
```

#### 局限性

```
❌ 不適合：大規模重構
   原因：只看當前檔案和附近程式碼，缺乏全局視野

❌ 不適合：複雜的多步驟任務
   原因：是「補全工具」，不是「工作流程編排工具」

❌ 不適合：深度程式碼理解
   原因：上下文視窗小（~128K tokens）
```

---

### 2. Claude Code：「工作流程編排」哲學

#### 核心理念

```
不是補全工具，是 AI Agent 協作平台

用戶描述任務 → Claude 分解步驟 → 調用工具執行 → 返回結果
                     ↓
              可調用的工具：
              - 檔案操作 (Read/Write/Edit)
              - 終端指令 (Bash)
              - 程式碼搜尋 (Grep/Glob)
              - 外部 API (MCP 伺服器)
              - 專家模式 (Agents)
              - 記憶系統 (Memory)
```

#### 優勢場景

**場景 1：大規模重構**

```bash
claude

提示詞：
將整個專案的 API 從 REST 升級到 GraphQL：
1. 分析現有的 50 個 REST 端點
2. 設計 GraphQL schema
3. 生成 resolver 函數
4. 更新前端的 API 調用
5. 生成遷移指南
6. 更新測試

請分階段執行，每個階段完成後等我確認。
```

Claude 會：
1. 掃描所有 API 檔案（Grep）
2. 分析端點定義
3. 生成 GraphQL schema
4. 逐個重構端點
5. 更新前端程式碼
6. 修改測試
7. 生成文檔

**場景 2：自動化工作流程**

```bash
提示詞：
建立每週自動化報告系統：
1. 從 GitHub 拉取本週的 Issues 和 PRs
2. 從資料庫查詢業務指標
3. 生成包含圖表的 Markdown 報告
4. 轉換為 PDF
5. 發送到 Slack #team-updates
6. 保存到 Confluence

請配置所有需要的 MCP 伺服器並自動執行。
```

Claude 會：
1. 配置 GitHub MCP
2. 配置 Database MCP
3. 配置 Slack MCP
4. 配置 Confluence MCP
5. 編排完整工作流程
6. 生成自動化腳本

**場景 3：知識工作自動化**

```bash
提示詞：
處理技術會議錄音（meeting.mp3）：
1. 轉錄為文字
2. 提取關鍵決策
3. 識別行動項目（負責人、截止日期）
4. 為每個行動項目創建 JIRA ticket
5. 生成會議摘要（繁中、英文、日文三個版本）
6. 發送到 Slack
7. 保存到 Notion

自動執行所有步驟。
```

#### 局限性

```
❌ 不適合：需要即時補全的日常編碼
   原因：是對話式工具，不是即時補全工具

❌ 不適合：不清楚任務目標的探索
   原因：需要明確的任務描述才能規劃步驟

❌ 學習曲線：比 Copilot 高
   原因：需要學習如何描述任務、使用指令、配置 MCP
```

---

### 3. Gemini CLI：「巨量上下文」哲學

#### 核心理念

```
一次載入整個專案 → 深度分析 → 回答問題

上下文視窗：1M+ tokens
           ≈ 整本小說
           ≈ 中型專案的全部程式碼
           ≈ 500+ 檔案
```

#### 優勢場景

**場景 1：快速 Onboarding**

```bash
# 載入整個專案
gemini chat --add-dir ./large-project/src

提示詞：
我是新加入的工程師，請幫我理解這個專案：
1. 主要功能是什麼？
2. 核心架構如何設計？
3. 各個模組的職責？
4. 資料流向如何？
5. 外部依賴有哪些？
6. 如果我要添加新功能「用戶推薦」，應該修改哪些檔案？

請生成一份 onboarding 文檔。
```

Gemini 可以：
- 一次讀取整個專案（1M tokens）
- 理解模組間的關係
- 追蹤資料流向
- 提供全局性的架構分析

**場景 2：架構分析**

```bash
提示詞：
分析這個專案的架構品質：
1. 識別所有的架構模式（MVC、Repository、Factory等）
2. 找出模組間的耦合問題
3. 識別循環依賴
4. 評估測試覆蓋率
5. 提出重構建議

生成詳細的架構審查報告。
```

**場景 3：程式碼遷移規劃**

```bash
提示詞：
我們要將這個 Python 2.7 專案遷移到 Python 3.11：
1. 識別所有不相容的語法
2. 列出需要更新的第三方套件
3. 找出可能破壞的 API 變更
4. 估算遷移工作量
5. 生成詳細的遷移計劃（分 10 個階段）

請給出完整的分析報告。
```

#### 局限性

```
❌ 不適合：即時補全
   原因：不是即時工具

❌ 不適合：持久化記憶
   原因：每次對話需要重新載入上下文

❌ 不適合：複雜的多步驟執行
   原因：分析能力強，但執行能力不如 Claude Code

❌ 成本：大型專案載入成本較高
   原因：1M tokens 的上下文視窗需要更多計算資源
```

---

## 🎯 決策樹：如何選擇工具

### 快速決策流程圖

```
你的需求是什麼？
    |
    ├─ 日常編碼、快速補全
    │  └─ 【GitHub Copilot】
    │      範例：寫函數、生成測試、補全程式碼
    |
    ├─ 需要理解整個專案架構
    │  └─ 【Gemini CLI】
    │      範例：新專案 onboarding、架構分析
    |
    ├─ 複雜的多步驟任務
    │  └─ 【Claude Code】
    │      範例：大規模重構、工作流程自動化
    |
    └─ 知識工作（非程式設計）
       └─ 【Claude Code】
           範例：文檔生成、會議紀錄、筆記整理
```

### 詳細決策矩陣

| 任務類型 | 推薦工具 | 理由 | 範例 |
|---------|---------|------|------|
| **日常編碼** | Copilot | 即時反應快 | 寫函數、補全程式碼 |
| **小規模重構** | Copilot | IDE 整合好 | 重命名變數、提取函數 |
| **大規模重構** | Claude Code | 全局視野 + 工作流程 | API 版本遷移、架構改造 |
| **程式碼審查** | Claude Code | 深度分析能力 | 安全審查、品質檢查 |
| **專案理解** | Gemini CLI | 巨量上下文 | 快速 onboarding |
| **架構分析** | Gemini CLI | 全局分析 | 找出架構問題 |
| **測試生成** | Copilot | 快速生成 | 單元測試、整合測試 |
| **文檔生成** | Claude Code | 自訂輸出格式 | API 文檔、技術文章 |
| **自動化流程** | Claude Code | 工具整合能力 | CI/CD、週報生成 |
| **知識萃取** | Claude Code | 多模態處理 | 會議紀錄、筆記整理 |
| **程式碼遷移** | Gemini CLI → Claude | 先分析後執行 | Python 2→3、框架升級 |

---

## 💡 混合使用策略

### 策略 1：「日常 + 深度」組合

```
日常編碼：GitHub Copilot（IDE 內）
    ↓
遇到複雜任務：切換到 Claude Code
    ↓
需要全局理解：使用 Gemini CLI 分析
```

**實際案例**：

```
任務：重構用戶認證系統

步驟 1：用 Gemini CLI 分析現狀
$ gemini chat --add-dir ./src/auth
提示：分析現有認證系統的架構和問題

步驟 2：用 Claude Code 執行重構
$ claude
提示：基於 Gemini 的分析，重構認證系統

步驟 3：用 Copilot 補全細節
在 IDE 中寫具體實現時，Copilot 自動補全
```

---

### 策略 2：「團隊工具鏈」設計

**小型團隊（5-10人）**：

```
工具配置：
- 人人必備：GitHub Copilot（日常編碼）
- 1-2 人擁有：Claude Code Pro（複雜任務）
- 共用：Gemini CLI（專案分析）

工作流程：
1. 日常開發用 Copilot
2. 遇到複雜任務找「Claude 專家」協助
3. 新人 onboarding 用 Gemini 生成文檔
```

**中大型團隊（50+人）**：

```
工具配置：
- 前端團隊：Copilot（即時補全需求高）
- 後端團隊：Copilot + Claude Code（需要重構能力）
- 架構師：Claude Code + Gemini CLI（全局視野）
- 技術文檔：Claude Code（多語言內容生成）

共享資源：
- 統一的 CLAUDE.md 模板（團隊規範）
- MCP 伺服器配置（公司內部 API）
- Gemini CLI 分析腳本（架構審查）
```

---

## 🔬 實戰案例：解決真實問題

### 案例 1：API 版本遷移（v1 → v2）

**需求**：
- 50+ API 端點
- 認證方式改變（Basic Auth → JWT）
- 回應格式統一（JSON:API 規範）

**工具選擇**：

```
階段 1：分析現狀（Gemini CLI）
$ gemini chat --add-dir ./src/api/v1
提示：分析所有 v1 API，列出需要遷移的內容

輸出：
- 53 個端點
- 12 種不同的回應格式
- 8 個安全問題
- 遷移計劃（10 個階段）

階段 2：執行遷移（Claude Code）
$ claude --add-dir ./src/api/v1
提示：基於 Gemini 的分析，執行遷移計劃
每完成一個階段暫停，等我確認

階段 3：補全細節（Copilot）
在 IDE 中修改具體實現時，Copilot 自動補全
```

**結果**：
- 使用單一工具：預估 40 小時
- 混合使用：實際 18 小時（節省 55%）

---

### 案例 2：新人快速 Onboarding

**情境**：
- 新工程師 David 加入團隊
- 專案有 100,000 行程式碼
- 需要 2 週內開始貢獻

**Day 1-2：專案理解（Gemini CLI）**

```bash
$ gemini chat --add-dir ./entire-project

David 的問題清單：
1. 專案整體架構是什麼？
2. 各個模組的職責？
3. 資料流向如何？
4. 外部依賴有哪些？
5. 測試策略是什麼？
6. 部署流程如何？
7. 常見問題有哪些？
8. 如果我要添加新功能，應該從哪裡開始？

Gemini 輸出：
→ 生成 50 頁的 onboarding 文檔
→ 包含架構圖、流程圖、程式碼範例
→ 標註關鍵檔案和入口點
```

**Day 3-5：深入理解（Claude Code）**

```bash
$ claude --add-dir ./src/core

David：
請幫我理解 user-service 模組：
1. 詳細講解每個類別的職責
2. 畫出類別關係圖
3. 解釋關鍵業務邏輯
4. 指出潛在的複雜點
5. 給我一個「修改建議」的學習任務

Claude：
→ 生成詳細的模組文檔
→ 提供學習任務（從簡單到複雜）
→ 設置學習檢查點
```

**Day 6-14：實際開發（Copilot）**

```
David 開始實際開發，Copilot 輔助日常編碼
遇到複雜問題，回到 Claude Code 尋求幫助
```

**結果**：
- 傳統方式：4 週才能獨立工作
- AI 輔助：2 週開始貢獻（節省 50%）

---

### 案例 3：技術部落格自動化

**需求**：
- 每週發布技術文章
- 需要繁中、英文、日文三個版本
- 包含程式碼範例、圖表、SEO 優化

**工具選擇**：Claude Code（唯一）

**為什麼不用 Copilot 或 Gemini？**

```
Copilot：
  ❌ 主要用於程式碼補全
  ❌ 不適合長篇內容創作

Gemini CLI：
  ⚠️ 可以生成內容
  ❌ 但缺乏工作流程整合（發布到部落格、SEO優化）

Claude Code：
  ✅ 內容創作能力強
  ✅ 可以整合 MCP（WordPress、Medium、SEO工具）
  ✅ 支援自訂輸出格式（Markdown、HTML）
  ✅ 可以自動化整個流程
```

**自動化流程**：

```bash
$ claude

提示詞：
從這週的開發工作生成技術部落格文章：

【內容來源】
1. GitHub commits（本週）
2. Pull Request 討論
3. 技術會議筆記（notes.md）

【生成內容】
1. 文章主題：自動決定
2. 程式碼範例：從實際 commits 提取
3. 架構圖：自動生成 Mermaid 圖
4. SEO 優化：關鍵字、meta description

【多語言版本】
1. 繁體中文（主要）
2. 英文（國際版）
3. 日文（日本市場）

【自動發布】
1. WordPress（公司部落格）
2. Medium（個人部落格）
3. Dev.to（開發者社群）

請自動執行整個流程。
```

Claude 會：
1. 分析 GitHub 活動（GitHub MCP）
2. 提取關鍵技術點
3. 生成文章結構
4. 撰寫內容
5. 生成程式碼範例和圖表
6. SEO 優化
7. 翻譯成三個語言
8. 自動發布到三個平台

**結果**：
- 手動方式：每篇文章 6-8 小時
- AI 自動化：每篇文章 30 分鐘（節省 90%）

---

## 🎓 學習建議：如何掌握三大工具

### 學習路徑

```
Week 1-2：GitHub Copilot
  目標：熟悉即時補全
  練習：
    - 寫 10 個函數，讓 Copilot 補全
    - 生成 20 個單元測試
    - 重構 5 個複雜函數

Week 3-4：Claude Code
  目標：掌握工作流程編排
  練習：
    - 完成 3 個大規模重構任務
    - 建立 5 個自動化工作流程
    - 配置 3 個 MCP 伺服器

Week 5-6：Gemini CLI
  目標：理解巨量上下文分析
  練習：
    - 分析 3 個開源專案
    - 生成 5 份 onboarding 文檔
    - 執行 2 次架構審查

Week 7-8：混合使用
  目標：靈活切換工具
  練習：
    - 完成 3 個需要多工具協同的任務
    - 設計團隊工具鏈
    - 優化個人工作流程
```

---

## 📝 本章總結

### 核心要點

1. **三大工具定位**
   - Copilot：日常編碼助手
   - Claude Code：工作流程編排平台
   - Gemini CLI：巨量上下文分析器

2. **選擇策略**
   - 快速補全 → Copilot
   - 複雜任務 → Claude Code
   - 專案理解 → Gemini CLI

3. **混合使用**
   - 不要只用一個工具
   - 根據任務切換工具
   - 設計團隊工具鏈

4. **學習重點**
   - 理解每個工具的哲學
   - 識別工具的最佳場景
   - 建立工具選擇直覺

---

## 🎯 學習檢查點

完成本章後，你應該能夠：

- [ ] 說明三大工具的核心差異
- [ ] 為給定場景選擇合適的工具
- [ ] 設計混合工具鏈
- [ ] 理解上下文管理的不同策略
- [ ] 評估工具的成本效益

**自我測驗**：

```
場景 1：需要重構 500 個檔案的 API 調用
你的選擇：_______________
理由：_______________

場景 2：快速理解新接手的 20 萬行專案
你的選擇：_______________
理由：_______________

場景 3：日常開發，需要快速補全
你的選擇：_______________
理由：_______________

場景 4：自動化週報生成系統
你的選擇：_______________
理由：_______________
```

---

## 📚 延伸閱讀

### 官方資源

1. **GitHub Copilot**
   - [官方文檔](https://docs.github.com/copilot)
   - [最佳實踐](https://github.blog/category/copilot/)

2. **Claude Code**
   - [官方文檔](https://claude.ai/code)
   - [MCP 協議](https://modelcontextprotocol.io/)

3. **Gemini CLI**
   - [官方文檔](https://cloud.google.com/gemini)
   - [API 參考](https://ai.google.dev/docs)

### 推薦閱讀

- "AI 工具比較研究" - 技術雷達 2024
- "開發者工具選擇指南" - ThoughtWorks
- "混合 AI 工作流程設計" - Martin Fowler

---

## 🔜 下一步

完成本章後，繼續學習：

➡️ **1.3 上下文工程第一性原理**
- 深入理解上下文管理
- 學習建立專案記憶檔案（CLAUDE.md）
- 掌握長期記憶系統設計

---

**課程版本**：v2.0
**最後更新**：2025-01-30
**預計學習時間**：45 分鐘
**難度**：⭐⭐ 中級
