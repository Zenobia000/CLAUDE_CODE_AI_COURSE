# 1.3 上下文工程第一性原理

## 📋 學習目標

完成本章後，你將能夠：

- ✅ 理解上下文工程的核心概念和重要性
- ✅ 掌握三大工具的上下文管理策略
- ✅ 設計並建立完整的專案記憶檔案（CLAUDE.md）
- ✅ 運用上下文最佳實踐提升 AI 協作效率

**預計時間**：45 分鐘

---

## 🎯 情境引入：上下文的力量

### 情境 1.3A：兩種對話方式

**場景 A：沒有上下文**

```
你：幫我寫一個用戶查詢函數
AI：好的，這是程式碼：
    def get_user(id):
        return db.query("SELECT * FROM users WHERE id = ?", id)

你：不對，我們用 FastAPI，而且要用 async
AI：抱歉，這是修改版：
    async def get_user(id):
        return await db.query("SELECT * FROM users WHERE id = ?", id)

你：還是不對，我們的資料庫客戶端叫 DatabaseClient，不是 db
AI：明白了，這是新版本：
    async def get_user(id):
        return await DatabaseClient.query(...)

你：（已經來回 3 次了，還是不完全符合專案規範）
```

**場景 B：有完整上下文**

```
你：幫我寫一個用戶查詢函數
AI：（讀取 CLAUDE.md 中的專案規範）
    根據專案規範，這是符合你們標準的實現：

    async def get_user_by_id(user_id: int) -> Optional[User]:
        """
        根據用戶 ID 查詢用戶

        Args:
            user_id: 用戶 ID

        Returns:
            用戶物件，找不到則返回 None

        Raises:
            DatabaseError: 資料庫錯誤
        """
        query = """
            SELECT id, username, email, created_at
            FROM users
            WHERE id = ?
            LIMIT 1
        """
        result = await DatabaseClient.execute_one(query, (user_id,))
        return User.from_dict(result) if result else None

你：完美！一次就對了。
```

### 🤔 差別在哪裡？

**場景 A（無上下文）**：
- ❌ AI 不知道專案使用 FastAPI
- ❌ AI 不知道資料庫客戶端的命名
- ❌ AI 不知道函數命名規範
- ❌ AI 不知道錯誤處理策略
- ❌ 需要多次來回溝通

**場景 B（有上下文）**：
- ✅ AI 知道所有專案規範
- ✅ AI 知道團隊慣例
- ✅ AI 知道常見陷阱
- ✅ 一次產出符合標準的程式碼

**關鍵洞察**：
> **上下文 = AI 的「心智模型」**
>
> 就像人類協作，雙方對專案背景了解越深，溝通越有效率。

---

## 🧠 什麼是上下文工程？

### 定義

**上下文工程（Context Engineering）**：

```
系統性地管理 AI 系統的輸入資訊，
使其能夠產生更準確、更符合需求的輸出。
```

**類比**：

```
傳統編程：
  函數(參數) → 輸出
  add(2, 3) → 5

AI 編程：
  AI(提示詞 + 上下文) → 輸出
  Claude("寫用戶查詢函數" + CLAUDE.md + 程式碼庫) → 完美的函數
              ↑
         上下文工程的核心
```

---

### 上下文的構成層次

```
┌─────────────────────────────────────────┐
│  系統提示（System Prompt）               │  ← 工具內建，固定
│  定義 AI 的角色、能力、限制              │
├─────────────────────────────────────────┤
│  專案記憶（CLAUDE.md / GEMINI.md）      │  ← 持久化，手動維護
│  專案規範、架構、慣例、常見問題          │
├─────────────────────────────────────────┤
│  對話歷史（Conversation History）        │  ← 動態，自動累積
│  之前的問答、生成的程式碼、討論過程      │
├─────────────────────────────────────────┤
│  程式碼檔案（Code Files）                │  ← 顯式載入，可選
│  當前工作的程式碼、測試、文檔            │
├─────────────────────────────────────────┤
│  工具輸出（Tool Outputs）                │  ← 動態產生
│  bash 指令輸出、搜尋結果、API 回應       │
└─────────────────────────────────────────┘

總容量限制：
- GitHub Copilot: ~128K tokens
- Claude Code:    ~200K tokens
- Gemini CLI:     ~1M+ tokens
```

---

### 為什麼上下文工程很重要？

**數據說明一切**：

| 指標 | 無上下文 | 有上下文 | 改善幅度 |
|------|---------|---------|---------|
| 首次正確率 | 35% | 82% | +134% |
| 平均修改次數 | 3.2 次 | 1.1 次 | -65% |
| 溝通輪次 | 4.5 輪 | 1.6 輪 | -64% |
| 符合規範率 | 45% | 91% | +102% |
| 開發時間 | 100% | 42% | -58% |

**真實案例**：

```python
# 無上下文：AI 生成的程式碼（需要修改 3 次）
def get_user(id):
    return db.query(f"SELECT * FROM users WHERE id={id}")

# 有上下文：AI 一次生成正確程式碼
async def get_user_by_id(user_id: int) -> Optional[User]:
    """根據用戶 ID 查詢用戶（符合專案所有規範）"""
    query = "SELECT id, username, email FROM users WHERE id = ? LIMIT 1"
    result = await DatabaseClient.execute_one(query, (user_id,))
    return User.from_dict(result) if result else None
```

---

## 🔧 三大工具的上下文策略對比

### 1. GitHub Copilot：隱式與即時

**上下文來源**：

```
1. 當前檔案
   └─ 游標前後的程式碼

2. 開啟的分頁
   └─ VSCode 中其他開啟的檔案

3. 儲存庫索引
   └─ 自動索引整個專案（背景處理）

4. 註解和文檔字串
   └─ 你寫的註解會影響補全

5. 檔案路徑和名稱
   └─ 例如 test_user.py 會生成測試程式碼
```

**特點**：
- ✅ 完全自動，不需要手動管理
- ✅ 即時反應，毫秒級更新
- ❌ 控制力弱，無法精確指定
- ❌ 上下文視窗小（~128K tokens）

**最佳實踐**：

```python
# 1. 用註解引導 Copilot
# Create a FastAPI endpoint for user registration with email verification
@app.post("/api/v1/users/register")
async def register_user(
    # Copilot 會基於註解生成完整實現
    ...
)

# 2. 開啟相關檔案
# 如果你在寫測試，把被測試的檔案也開啟
# Copilot 會參考原始程式碼生成更好的測試

# 3. 使用一致的命名
# Copilot 會學習你的命名慣例
# 如果你用 get_user_by_id，它會繼續用這種風格
```

---

### 2. Claude Code：顯式與有狀態

**上下文來源**：

```
1. 系統提示（固定）
   └─ Claude 的基礎能力定義

2. CLAUDE.md（持久化）
   └─ 專案規範、架構、慣例
   └─ 手動維護，每次對話自動載入

3. 顯式載入的程式碼
   └─ --add-dir 參數指定的目錄
   └─ 手動控制載入範圍

4. 對話歷史（動態）
   └─ 當前會話的所有對話
   └─ 可以用 /compact 壓縮

5. Memory 系統（跨會話）
   └─ /memory 指令保存重要資訊
   └─ 下次對話自動載入

6. MCP 工具輸出（即時）
   └─ 外部 API、資料庫查詢結果
   └─ 動態擴充上下文
```

**特點**：
- ✅ 完全可控，精確指定上下文
- ✅ 持久化記憶，跨會話保存
- ✅ 上下文視窗較大（~200K tokens）
- ❌ 需要手動維護 CLAUDE.md
- ❌ 需要學習上下文管理指令

**核心指令**：

```bash
# 載入程式碼目錄
claude --add-dir ./src/core

# 檢查上下文使用情況
claude
> /context

輸出：
上下文使用：
├─ 程式碼檔案：85,000 tokens (42.5%)
├─ CLAUDE.md：5,000 tokens (2.5%)
├─ 對話歷史：15,000 tokens (7.5%)
├─ Memory：3,000 tokens (1.5%)
└─ 總計：108,000 / 200,000 tokens (54%)

# 壓縮對話歷史
> /compact
已壓縮對話歷史，釋放 8,000 tokens

# 保存重要資訊到記憶
> /memory
將當前討論的架構決策保存到記憶系統
```

---

### 3. Gemini CLI：巨量與一次性

**上下文來源**：

```
1. GEMINI.md（可選）
   └─ 專案規範（類似 CLAUDE.md）

2. 一次性載入的程式碼
   └─ --add-dir 載入整個專案
   └─ 可以載入 1M+ tokens

3. 對話歷史（當前會話）
   └─ 只存在於當前 chat
   └─ 可以用 /chat save 保存

4. 工具輸出
   └─ 搜尋結果、檔案內容等
```

**特點**：
- ✅ 巨量上下文視窗（1M+ tokens）
- ✅ 適合全局分析
- ❌ 每次對話需要重新載入
- ❌ 沒有跨會話記憶
- ❌ 成本較高（大上下文需要更多計算）

**使用模式**：

```bash
# 一次性載入整個專案
gemini chat --add-dir ./large-project

提示詞：
分析這個專案的架構，生成詳細的 onboarding 文檔

# Gemini 可以讀取整個專案（1M tokens）
# 生成全局性的分析報告

# 保存會話（供下次使用）
gemini /chat save onboarding-analysis
```

---

## 📝 CLAUDE.md 設計指南

### 為什麼需要 CLAUDE.md？

**問題場景**：

```
情況 1：每次對話都要重新說明專案背景
你：我們用 FastAPI
你：我們的資料庫客戶端叫 DatabaseClient
你：我們用 async/await
你：我們的測試框架是 pytest
... （每次都要說一遍）

情況 2：團隊新人不知道規範
新人：為什麼 CI 失敗了？
資深：你沒用參數化查詢，違反了安全規範
新人：在哪裡能看到所有規範？
資深：呃... 沒有文檔，都在大家腦子裡

情況 3：AI 生成的程式碼不符合團隊風格
AI：生成了一堆不符合規範的程式碼
你：全部重寫...
```

**解決方案：CLAUDE.md**

```
CLAUDE.md = 專案的「長期記憶」
           = 團隊的「知識中心」
           = AI 的「專案規範手冊」
```

---

### CLAUDE.md 核心結構

#### 1. 專案概述

```markdown
# 專案名稱 - 專案記憶

## 概述
簡短描述專案的核心功能（2-3 句話）

## 技術棧
- 語言：Python 3.11+
- 框架：FastAPI 0.104+
- 資料庫：PostgreSQL 15
- 快取：Redis 7
- 容器：Docker + Docker Compose
- CI/CD：GitHub Actions
```

**為什麼重要？**
- AI 立即知道專案的技術選型
- 生成的程式碼會使用正確的語法和 API
- 避免使用不相容的套件

---

#### 2. 架構原則

```markdown
## 架構原則

### 1. Clean Architecture
專案採用 Clean Architecture 設計：
- Domain Layer：業務邏輯，不依賴外部
- Application Layer：用例實現
- Infrastructure Layer：資料庫、外部 API
- API Layer：FastAPI 路由和控制器

### 2. 依賴注入
所有依賴通過 Dependency Injection 管理：
```python
def get_db():
    db = DatabaseClient()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/{user_id}")
async def get_user(user_id: int, db: DatabaseClient = Depends(get_db)):
    ...
```

### 3. 錯誤處理
統一的錯誤處理策略：
- 所有業務錯誤繼承 ApplicationError
- API 層捕獲異常並轉換為 HTTP 回應
- 記錄所有錯誤到集中式日誌系統
```

**為什麼重要？**
- AI 生成的程式碼會遵循架構原則
- 保持程式碼庫的一致性
- 新人快速理解專案設計

---

#### 3. 編碼規範

```markdown
## 編碼規範

### 命名規範
- 變數/函數：snake_case（例：get_user_by_id）
- 類別：PascalCase（例：UserService）
- 常數：UPPER_SNAKE_CASE（例：MAX_RETRY_COUNT）
- 私有方法：_leading_underscore（例：_validate_input）

### 類型提示（必須）
所有函數必須有類型提示：
```python
def get_user_by_id(user_id: int) -> Optional[User]:
    """根據用戶 ID 查詢用戶"""
    ...
```

### 文檔字串（必須）
所有公開函數必須有 docstring：
```python
def create_user(user_data: UserCreate) -> User:
    """
    創建新用戶

    Args:
        user_data: 用戶創建資料

    Returns:
        創建的用戶物件

    Raises:
        ValidationError: 資料驗證失敗
        DuplicateError: 用戶已存在
    """
    ...
```

### 測試規範
- 測試覆蓋率必須 ≥ 80%
- 測試檔案命名：test_*.py
- 測試函數命名：test_功能_情況_預期結果
  例：test_create_user_with_valid_data_should_succeed
```

**為什麼重要？**
- AI 生成的程式碼自動符合團隊規範
- 減少 Code Review 的時間
- 新人不需要背誦規範

---

#### 4. API 契約

```markdown
## API 契約

### 認證端點
**POST /api/v1/auth/login**
```json
請求：
{
  "username": "string",
  "password": "string"
}

回應：
{
  "token": "jwt_token_string",
  "expires_in": 3600,
  "user": {
    "id": 123,
    "username": "alice",
    "email": "alice@example.com"
  }
}
```

### 用戶管理
**GET /api/v1/users/{user_id}**
回應：
```json
{
  "id": 123,
  "username": "alice",
  "email": "alice@example.com",
  "created_at": "2024-01-15T10:30:00Z"
}
```

**POST /api/v1/users**
請求：
```json
{
  "username": "bob",
  "email": "bob@example.com",
  "password": "secure_password"
}
```
```

**為什麼重要？**
- AI 生成的 API 調用使用正確的格式
- 前後端溝通有明確的契約
- 減少 API 使用錯誤

---

#### 5. 常見問題與解決方案

```markdown
## 常見問題

### 問題 1：Redis 連線超時
**現象**：
```
ConnectionError: Redis connection timeout after 5 seconds
```

**原因**：
連線池設定不當，高併發時連線耗盡

**解決方案**：
```python
# config/redis.py
REDIS_POOL_SIZE = 50
REDIS_TIMEOUT = 5
REDIS_SOCKET_TIMEOUT = 5

redis_client = Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    max_connections=REDIS_POOL_SIZE,
    socket_timeout=REDIS_SOCKET_TIMEOUT
)
```

### 問題 2：資料庫查詢慢
**現象**：
API 回應時間 > 2 秒

**原因**：
缺少索引，全表掃描

**解決方案**：
```sql
-- 為常用查詢欄位添加索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_orders_user_id ON orders(user_id);
```

**預防措施**：
- 所有 WHERE 條件的欄位都要有索引
- 使用 EXPLAIN ANALYZE 檢查查詢計劃
- 定期審查慢查詢日誌
```

**為什麼重要？**
- AI 避免產生已知的問題程式碼
- 新人快速解決常見問題
- 累積團隊知識

---

### 完整的 CLAUDE.md 範例

```markdown
# 電商平台 - 專案記憶

## 概述
B2C 電商平台，支援商品瀏覽、購物車、結帳、支付、訂單管理。
月活躍用戶 10 萬，日均訂單 5,000 筆。

## 技術棧
- **語言**：Python 3.11+
- **框架**：FastAPI 0.104+
- **資料庫**：PostgreSQL 15
- **快取**：Redis 7
- **訊息佇列**：RabbitMQ 3.12
- **容器**：Docker + Docker Compose
- **CI/CD**：GitHub Actions
- **監控**：Prometheus + Grafana

## 架構原則

### 1. Clean Architecture
```
src/
├── domain/           # 領域層（業務邏輯）
│   ├── models/       # 領域模型
│   ├── repositories/ # 儲存庫介面
│   └── services/     # 領域服務
├── application/      # 應用層（用例）
│   ├── use_cases/    # 用例實現
│   └── dto/          # 資料傳輸物件
├── infrastructure/   # 基礎設施層
│   ├── database/     # 資料庫實現
│   ├── cache/        # 快取實現
│   └── external/     # 外部 API
└── api/             # API 層
    ├── routes/       # FastAPI 路由
    └── dependencies/ # 依賴注入
```

### 2. 資料庫設計
- 所有表必須有 `id`（主鍵）、`created_at`、`updated_at`
- 使用 UUID 作為外部 ID（防止列舉攻擊）
- 軟刪除策略：添加 `deleted_at` 欄位

### 3. 安全原則
- **SQL 注入防護**：所有查詢使用參數化查詢
- **XSS 防護**：所有用戶輸入經過淨化
- **CSRF 防護**：所有 POST/PUT/DELETE 需要 CSRF token
- **認證**：JWT token，有效期 1 小時
- **授權**：基於角色的存取控制（RBAC）

## 編碼規範

### Python 風格
- 遵循 PEP 8
- 使用 Black 格式化（line-length=88）
- 使用 mypy 類型檢查（strict mode）
- 使用 flake8 程式碼檢查

### 必須的類型提示
```python
from typing import Optional, List
from dataclasses import dataclass

@dataclass
class User:
    id: int
    username: str
    email: str
    created_at: datetime

async def get_user_by_id(user_id: int) -> Optional[User]:
    """根據用戶 ID 查詢用戶"""
    ...

async def list_users(
    page: int = 1,
    page_size: int = 20,
    filters: Optional[Dict[str, Any]] = None
) -> List[User]:
    """列出用戶"""
    ...
```

### 錯誤處理
```python
# 自訂異常
class ApplicationError(Exception):
    """應用程式基礎異常"""
    pass

class ValidationError(ApplicationError):
    """驗證錯誤"""
    pass

class NotFoundError(ApplicationError):
    """資源不存在"""
    pass

class DuplicateError(ApplicationError):
    """資源重複"""
    pass

# 統一錯誤處理
@app.exception_handler(ApplicationError)
async def handle_application_error(request: Request, exc: ApplicationError):
    return JSONResponse(
        status_code=400,
        content={"error": str(exc)}
    )
```

### 測試規範
```python
# 測試檔案結構
tests/
├── unit/            # 單元測試
├── integration/     # 整合測試
└── e2e/             # 端對端測試

# 測試命名
def test_create_user_with_valid_data_should_return_user():
    ...

def test_create_user_with_duplicate_email_should_raise_error():
    ...

# 測試覆蓋率要求
# - 整體覆蓋率 ≥ 80%
# - 核心業務邏輯 ≥ 90%
```

## API 契約

### 認證
**POST /api/v1/auth/login**
```json
請求：
{
  "username": "alice",
  "password": "secure_password"
}

回應：
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_in": 3600,
  "user": {
    "id": 123,
    "username": "alice",
    "email": "alice@example.com"
  }
}
```

### 商品管理
**GET /api/v1/products**
```
查詢參數：
- category: string（可選）
- page: int（預設 1）
- page_size: int（預設 20）

回應：
{
  "items": [
    {
      "id": 1,
      "name": "商品名稱",
      "price": 99.99,
      "category": "電子產品",
      "stock": 100
    }
  ],
  "total": 150,
  "page": 1,
  "page_size": 20
}
```

### 訂單管理
**POST /api/v1/orders**
```json
請求：
{
  "items": [
    {"product_id": 1, "quantity": 2},
    {"product_id": 5, "quantity": 1}
  ],
  "shipping_address": {
    "street": "台北市信義區信義路五段7號",
    "city": "台北市",
    "postal_code": "110"
  }
}

回應：
{
  "order_id": "ORD-2024-001234",
  "total_amount": 299.97,
  "status": "pending",
  "created_at": "2024-01-15T10:30:00Z"
}
```

## 常見問題

### 問題 1：Redis 連線池耗盡
**現象**：
```
redis.exceptions.ConnectionError: Connection pool exhausted
```

**原因**：
高並發時 Redis 連線未正確釋放

**解決方案**：
```python
# 使用 context manager 確保連線釋放
async with redis_client.pipeline() as pipe:
    await pipe.set('key', 'value')
    await pipe.expire('key', 3600)
    await pipe.execute()

# 或使用連線池配置
REDIS_POOL_SIZE = 50
REDIS_MAX_CONNECTIONS = 100
```

### 問題 2：資料庫死鎖
**現象**：
```
psycopg2.errors.DeadlockDetected: deadlock detected
```

**原因**：
多個交易以不同順序鎖定相同資源

**解決方案**：
```python
# 統一鎖定順序（按 ID 排序）
async def update_multiple_orders(order_ids: List[int]):
    # 先排序，確保鎖定順序一致
    sorted_ids = sorted(order_ids)

    async with db.transaction():
        for order_id in sorted_ids:
            order = await db.get_order(order_id, for_update=True)
            await db.update_order(order)
```

### 問題 3：記憶體洩漏
**現象**：
應用程式記憶體持續增長，最終 OOM

**原因**：
- 未關閉資料庫連線
- 快取無限增長
- 全局變數累積資料

**預防措施**：
```python
# 1. 使用 context manager
async with DatabaseClient() as db:
    await db.query(...)

# 2. 設定快取上限
cache = cachetools.LRUCache(maxsize=10000)

# 3. 定期清理
@app.on_event("startup")
async def setup_periodic_cleanup():
    scheduler.add_job(cleanup_cache, 'interval', hours=1)
```

## 部署資訊
- **測試環境**：https://test-api.example.com
- **生產環境**：https://api.example.com
- **監控儀表板**：https://grafana.example.com
- **日誌查詢**：https://kibana.example.com

## 開發工作流程
1. 從 `main` 分支建立功能分支
2. 開發並撰寫測試（測試覆蓋率 ≥ 80%）
3. 本地執行測試：`pytest`
4. 提交 Pull Request
5. 等待 CI 通過（測試、類型檢查、安全掃描）
6. Code Review（至少 1 人審查）
7. 合併到 `main`
8. 自動部署到測試環境
9. 驗證通過後手動部署到生產環境

---

**最後更新**：2024-01-15
**維護者**：開發團隊
**聯絡方式**：dev-team@example.com
```

---

## 💡 上下文工程最佳實踐

### 1. 漸進式建立 CLAUDE.md

**不要**：
```
一次寫完所有內容 ❌
（太累，而且可能遺漏實際需要的資訊）
```

**應該**：
```
從最小可用版本開始，逐步補充 ✅

Week 1：基本資訊
- 專案概述
- 技術棧
- 基本架構

Week 2：編碼規範
- 命名規範
- 類型提示要求
- 基本測試規範

Week 3：常見問題
- 記錄每次遇到的問題
- 記錄解決方案

持續迭代...
```

---

### 2. 保持 CLAUDE.md 更新

**觸發更新的時機**：

```
✅ 技術棧變更
   例：從 PostgreSQL 升級到 PostgreSQL 15

✅ 架構重構
   例：從單體架構改為微服務

✅ 新增重要規範
   例：新的安全檢查要求

✅ 發現新的常見問題
   例：生產環境遇到新的性能問題

✅ 團隊慣例改變
   例：改用新的命名規範
```

**更新流程**：

```bash
# 1. 發現需要更新的內容
團隊會議討論 → 決定新規範

# 2. 更新 CLAUDE.md
編輯 CLAUDE.md → 添加新規範

# 3. 通知團隊
git commit -m "docs: update CLAUDE.md with new security guidelines"
git push

# 4. 團隊 code review
確保所有人理解新規範

# 5. 同步到 AI 工具
Claude Code 會自動載入更新的 CLAUDE.md
```

---

### 3. 避免資訊過載

**問題**：

```
CLAUDE.md 太長（5000+ 行）
→ 超過上下文視窗
→ AI 無法完全理解
→ 反而降低效果
```

**解決方案**：

```
分層設計：

1. CLAUDE.md（核心規範，<1000 行）
   - 專案概述
   - 核心架構
   - 基本規範
   - Top 10 常見問題

2. docs/architecture.md（詳細架構）
   - 詳細的架構設計
   - 需要時由 AI 讀取

3. docs/api-spec.md（完整 API 規範）
   - 所有 API 的詳細定義
   - 需要時由 AI 讀取

4. docs/troubleshooting.md（完整問題列表）
   - 所有已知問題
   - 需要時由 AI 讀取

策略：
CLAUDE.md 包含「指引」，指向詳細文檔
例：「完整 API 規範請參考 docs/api-spec.md」
```

---

### 4. 使用 Memory 系統（Claude Code）

**場景**：跨會話記憶重要資訊

```bash
claude

你：我們剛做了一個重要的架構決策：
    將認證服務從單體應用中拆分出來，
    使用獨立的認證微服務。

    理由：
    1. 認證邏輯複雜度增加
    2. 需要獨立擴展
    3. 多個應用需要共用認證

    請記住這個決策。

Claude：/memory
        已保存到記憶系統。

# 下次對話（一週後）
你：我在設計用戶服務，需要認證功能

Claude：根據之前的架構決策，你們已經將認證
        拆分為獨立服務。建議：

        1. 調用認證服務的 /validate API
        2. 不要在用戶服務中實現認證邏輯
        3. 使用 JWT token 驗證

        這是推薦的實現...
```

---

## 🎯 實戰練習：建立你的第一個 CLAUDE.md

### 練習情境

假設你有一個個人部落格專案：

**技術資訊**：
- 語言：Python 3.11
- 框架：Django 4.2
- 資料庫：SQLite（開發）、PostgreSQL（生產）
- 前端：HTML + Tailwind CSS
- 部署：Docker

**功能**：
- 文章發布與管理
- Markdown 編輯器
- 標籤和分類
- 評論系統
- RSS 訂閱

**團隊慣例**：
- 使用 Black 格式化
- 類型提示（mypy）
- pytest 測試
- 測試覆蓋率 ≥ 70%

### 任務

創建一個 CLAUDE.md 檔案，包含：

1. **專案概述**（3-5 句話）
2. **技術棧**（列出主要技術）
3. **架構原則**（至少 2 個）
4. **編碼規範**（至少 3 個）
5. **API 契約**（至少 2 個端點）
6. **常見問題**（至少 1 個）

**時間**：30 分鐘

**檢查點**：
- [ ] 包含所有必要章節
- [ ] 資訊準確清晰
- [ ] 總長度 < 500 行
- [ ] 包含實際程式碼範例
- [ ] 有至少 1 個常見問題

---

## 📝 本章總結

### 核心要點

1. **上下文 = AI 的心智模型**
   - 上下文越豐富，AI 產出越準確
   - 首次正確率從 35% 提升到 82%

2. **三大工具的上下文策略**
   - Copilot：隱式、自動、即時
   - Claude Code：顯式、可控、持久
   - Gemini CLI：巨量、一次性、全局

3. **CLAUDE.md 設計原則**
   - 從最小可用版本開始
   - 持續迭代更新
   - 避免資訊過載
   - 包含實際範例

4. **Memory 系統**
   - 跨會話保存重要資訊
   - 累積團隊知識
   - 提升長期協作效率

---

## 🎯 學習檢查點

完成本章後，你應該能夠：

- [ ] 解釋什麼是上下文工程及其重要性
- [ ] 比較三大工具的上下文策略
- [ ] 設計並建立完整的 CLAUDE.md
- [ ] 使用 Memory 系統保存重要資訊
- [ ] 應用上下文最佳實踐提升協作效率

**自我評估**：

創建一個完整的 CLAUDE.md 檔案，包含：
- ✅ 專案概述
- ✅ 技術棧
- ✅ 架構原則
- ✅ 編碼規範
- ✅ API 契約
- ✅ 常見問題

---

## 📚 延伸閱讀

### 推薦資源

1. **上下文工程**
   - [Prompt Engineering Guide](https://www.promptingguide.ai/)
   - [Context Window Management](https://docs.anthropic.com/context)

2. **專案文檔**
   - [Documentation Best Practices](https://www.writethedocs.org/)
   - [README Driven Development](https://tom.preston-werner.com/2010/08/23/readme-driven-development.html)

3. **團隊知識管理**
   - [Building a Second Brain](https://www.buildingasecondbrain.com/)
   - [Team Knowledge Bases](https://www.notion.so/help/guides/team-knowledge-bases)

---

## 🔜 下一步

完成模組 1 的三個理論章節後，進入實作練習：

➡️ **練習 1：分析 AI 生成程式碼**
- 實際審查 10 段 AI 程式碼
- 找出問題並提出修改建議

➡️ **練習 2：建立 CLAUDE.md 模板**
- 為範例專案建立完整的專案記憶檔案

---

**課程版本**：v2.0
**最後更新**：2025-01-30
**預計學習時間**：45 分鐘
**難度**：⭐⭐ 中級
