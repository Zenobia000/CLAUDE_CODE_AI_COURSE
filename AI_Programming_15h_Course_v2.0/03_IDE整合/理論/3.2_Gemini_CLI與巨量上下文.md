# 3.2 Gemini CLI 與巨量上下文

## 📋 學習目標

完成本章後，你將能夠：

- ✅ 理解 Gemini CLI 的「巨量上下文」核心優勢
- ✅ 掌握 1M+ tokens 的實際應用場景
- ✅ 理解 GEMINI.md 的設計原則
- ✅ 知道何時應該選擇 Gemini CLI
- ✅ 理解 Gemini 與 Claude Code 的差異

**預計時間**：15 分鐘

---

## 🎯 情境引入：新人 Onboarding 的挑戰

### 情境 3.2：第一天理解大型專案

**David 剛加入團隊**：

```
Day 1, 9:00 AM
主管：這是我們的專案，50 萬行程式碼，200+ 檔案
David：😰 從哪裡開始？

用 Claude Code？
- 上下文限制 ~200K tokens
- 大約只能分析 20-30 個檔案
- 需要多次對話才能理解全局

用 Copilot？
- 只能看當前檔案
- 無法建立全局視野
- 需要花數週慢慢理解

用 Gemini CLI？
- 一次性載入所有檔案（1M+ tokens）
- 10 分鐘內理解整體架構
- 直接問：「這個系統的核心邏輯是什麼？」
```

**關鍵問題**：
> 如何在第一天就對一個複雜系統建立全局理解？
> 答案：巨量上下文分析。

---

## 📊 核心優勢：1M+ Tokens 的威力

### 上下文大小對比

```
工具           上下文大小        能分析的內容
──────────────────────────────────────────────────
Copilot       ~128K tokens     當前檔案 + 少數開啟檔案
Claude Code   ~200K tokens     整個專案（中小型）
Gemini CLI    1M-2M tokens     大型專案 + 文檔 + 依賴

實際意義：
128K tokens  = 約 10-15 個檔案
200K tokens  = 約 20-30 個檔案
1M tokens    = 約 100-150 個檔案 + 完整文檔
```

### 什麼是「巨量上下文」？

```
範例：分析 Django 專案

傳統工具（200K tokens）：
├─ 只能分析 20 個核心檔案
├─ 無法包含所有 models
├─ 無法包含所有 views
└─ 需要多次對話，逐步理解

Gemini CLI（1M+ tokens）：
├─ 一次載入所有 models（50 個檔案）
├─ 一次載入所有 views（40 個檔案）
├─ 一次載入 API 文檔
├─ 一次載入測試檔案
└─ 直接問全局問題：
    "找出所有使用者認證相關的程式碼"
    "這個系統的資料流是什麼？"
    "哪些部分最需要重構？"
```

---

## 🎯 典型使用場景

### 場景 1：快速理解大型專案

**情境**：新進工程師接手舊專案

```bash
# 步驟 1：準備 GEMINI.md（專案記憶）
cat > GEMINI.md << 'EOF'
# Project: E-commerce Backend System

## Overview
- Microservices architecture (8 services)
- Tech stack: Python, FastAPI, PostgreSQL, Redis, RabbitMQ
- 500K lines of code, 200+ files

## Key Services
1. User Service (auth, profile)
2. Product Service (catalog, inventory)
3. Order Service (checkout, payment)
4. Notification Service (email, SMS)
...

## Analysis Goals
1. Understand data flow between services
2. Identify authentication mechanism
3. Find all API endpoints
4. Locate payment processing logic
EOF

# 步驟 2：啟動 Gemini CLI 並載入整個專案
gemini-cli --context-size 1M

# 步驟 3：一次性問全局問題
> 分析整個專案，回答：
> 1. 系統的核心架構是什麼？
> 2. 使用者從註冊到下單的完整流程？
> 3. 哪些服務之間有強耦合？
> 4. 支付流程的安全性如何？

# Gemini 分析所有檔案後回答：
> 📊 系統架構分析：
>
> 核心架構：事件驅動的微服務
> - 8 個獨立服務透過 RabbitMQ 通訊
> - 共享 PostgreSQL（需要改進：應該每個服務獨立 DB）
>
> 使用者流程：
> 1. User Service: POST /auth/register → 建立帳號
> 2. User Service: POST /auth/login → JWT token
> 3. Product Service: GET /products → 瀏覽商品
> 4. Order Service: POST /orders → 建立訂單（發送事件）
> 5. Payment Service: 監聽訂單事件 → 處理支付
> 6. Notification Service: 監聽支付成功事件 → 發送通知
>
> 強耦合問題：
> ⚠️ Order Service 直接呼叫 Payment Service API（應該用事件）
> ⚠️ 所有服務共享同一個 Redis（單點故障風險）
>
> 支付安全性：
> ✅ 使用 Stripe API（PCI 合規）
> ⚠️ 支付密鑰硬編碼在 config.py（需要改用環境變數）
> ⚠️ 缺少請求速率限制（易被 DDoS）
```

**關鍵優勢**：
- ✅ 10 分鐘內理解 50 萬行程式碼
- ✅ 發現跨服務的架構問題
- ✅ 識別安全風險
- ✅ 建立全局心智模型

---

### 場景 2：架構分析與重構規劃

**情境**：技術主管需要評估重構方案

```bash
# 任務：評估從 Monolith 到 Microservices 的遷移

# 步驟 1：讓 Gemini 分析現有 Monolith
> 分析這個 Django 專案（500 個檔案），回答：
> 1. 哪些模組可以獨立拆分成微服務？
> 2. 模組之間的依賴關係？
> 3. 哪些是共享資料庫表？
> 4. 拆分的風險評估？

# Gemini 分析結果：
> 📊 拆分建議：
>
> 可獨立拆分的模組（低風險）：
> 1. ✅ Notification Module (發送 email/SMS)
>    - 依賴：僅讀取 User 表
>    - 建議：獨立服務 + 事件驅動
>    - 風險：低
>
> 2. ✅ Analytics Module (數據分析)
>    - 依賴：僅讀取多個表（唯讀）
>    - 建議：獨立服務 + 資料倉儲
>    - 風險：低
>
> 需要謹慎拆分（中風險）：
> 3. ⚠️ Product Catalog Module
>    - 依賴：與 Order Module 有 JOIN 查詢
>    - 建議：先優化查詢，再拆分
>    - 風險：中
>
> 不建議拆分（高風險）：
> 4. ❌ Order & Payment Module
>    - 依賴：強事務耦合（ACID 要求）
>    - 建議：保持在同一服務
>    - 風險：高（分散式事務複雜）
>
> 共享資料表分析：
> - User 表：被 8 個模組使用
> - Product 表：被 5 個模組使用
> - 建議：使用 API Gateway 模式
```

**關鍵優勢**：
- ✅ 全局視野：看到所有依賴關係
- ✅ 風險評估：識別高風險拆分
- ✅ 決策支援：基於實際程式碼而非猜測

---

### 場景 3：快速定位跨專案問題

**情境**：Bug 可能存在於多個微服務中

```bash
# 問題：使用者報告「訂單建立後沒收到通知」

# 傳統方式：
# 1. 檢查 Order Service 日誌
# 2. 檢查 Notification Service 日誌
# 3. 檢查 RabbitMQ 訊息
# 4. 逐步追蹤事件流
# 需要時間：1-2 小時

# Gemini CLI 方式：
> 載入所有微服務程式碼，分析：
> 從 Order Service 的 POST /orders 端點開始，
> 追蹤整個通知流程，找出可能的失敗點。

# Gemini 分析：
> 🔍 事件流追蹤：
>
> 1. Order Service: order_controller.py:45
>    └─ 建立訂單成功 ✅
>    └─ 發布事件：order.created ✅
>
> 2. RabbitMQ: order.created 事件
>    └─ Payment Service 訂閱 ✅
>    └─ ⚠️ Notification Service 未訂閱！
>
> 3. 問題定位：
>    - notification_service/consumer.py:
>      訂閱的是 "payment.success" 事件
>    - 但 Payment Service 發布的是 "payment.completed" 事件
>    - 事件名稱不匹配！
>
> 4. 修復建議：
>    統一事件命名：payment.success → payment.completed
>    或在 Notification Service 同時訂閱兩個事件
```

**關鍵優勢**：
- ✅ 跨服務分析：一次看到所有相關程式碼
- ✅ 快速定位：5 分鐘 vs 1-2 小時
- ✅ 根因分析：而非表象

---

## 🔧 GEMINI.md 設計原則

### 核心結構

```markdown
# GEMINI.md - 專案記憶檔案

## 🎯 專案概述
[2-3 句話描述專案]

## 🏗️ 架構
[系統架構圖或描述]

## 📊 分析目標
[你想讓 Gemini 分析什麼]

## 🔑 關鍵路徑
[核心業務流程]

## ⚠️ 已知問題
[需要特別關注的地方]

## 📝 分析歷史
[之前的分析結果，避免重複]
```

### 範例：微服務專案

```markdown
# GEMINI.md

## 🎯 專案概述
電商後端系統，8 個微服務，事件驅動架構，處理每日 10 萬訂單。

## 🏗️ 架構
```
User Service ──→ Order Service ──→ Payment Service
     │                 │                  │
     └────→ RabbitMQ ←─┴──────────────────┘
                 │
                 └──→ Notification Service
```

## 📊 當前分析目標
1. 找出所有跨服務的同步呼叫（應該改成異步）
2. 識別單點故障風險
3. 分析支付流程的安全性

## 🔑 關鍵路徑
**訂單流程**：
POST /orders → order.created 事件 → 支付處理 → payment.completed 事件 → 發送通知

## ⚠️ 已知問題
1. 所有服務共享一個 Redis（需要拆分）
2. 支付密鑰硬編碼（需要環境變數）
3. 缺少 API 速率限制

## 📝 分析歷史
- 2025-01-15: 發現 Order-Payment 強耦合問題
- 2025-01-20: 識別 3 個安全漏洞
```

---

## 🔄 與 Claude Code 的差異

### 對比表

| 維度 | Gemini CLI | Claude Code |
|------|-----------|-------------|
| **上下文大小** | 1M-2M tokens | ~200K tokens |
| **適用場景** | 初次理解大型專案 | 日常開發與重構 |
| **分析深度** | 廣泛（全局視野） | 深入（工作流程） |
| **互動方式** | 一次性分析 + 對話 | 多輪對話 + 執行 |
| **工具整合** | 有限 | 強大（MCP、Agents） |
| **記憶機制** | GEMINI.md + chat | CLAUDE.md + memory |
| **執行能力** | 僅分析 | 可執行（修改程式碼） |

### 使用策略

```
階段              工具選擇           理由
────────────────────────────────────────────────
專案初期         Gemini CLI        全局理解
  Day 1-3        (1M+ tokens)      建立心智模型

日常開發         Claude Code       工作流程編排
  Day 4+         + Copilot         深度分析 + 快速編碼

重大重構         Gemini CLI        重新分析全局
                 → Claude Code     執行重構計畫
```

---

## ⚠️ 局限性與注意事項

### 不適合的場景

**❌ 場景 1：日常編碼**
```
問題：寫一個新的 API 端點
Gemini：需要啟動、載入整個專案（慢）
應該用：Copilot（即時補全）
```

**❌ 場景 2：實際執行修改**
```
問題：重構 50 個檔案的 import 語句
Gemini：只能分析，無法執行
應該用：Claude Code（可執行修改）
```

**❌ 場景 3：持續迭代開發**
```
問題：需要多次來回對話
Gemini：沒有持久記憶（每次重新載入）
應該用：Claude Code（有 memory 系統）
```

---

### 成本考量

```
Gemini CLI 計費方式：

輸入：$0.000125 per 1K tokens
輸出：$0.000375 per 1K tokens

範例計算：
載入 1M tokens 專案 + 分析（10K tokens 輸出）
= (1000 × $0.000125) + (10 × $0.000375)
= $0.125 + $0.00375
= $0.13 per 分析

如果每天分析一次：
$0.13 × 30 = $3.9/月

相較於：
Claude Code Pro: $20/月（固定）
Copilot: $10/月（固定）

建議：僅在需要全局分析時使用
```

---

## 🎯 決策指南：何時選擇 Gemini CLI

### 決策樹

```
你的任務是什麼？

├─ 新進團隊，需要快速理解大型專案（50+ 檔案）
│  └─ ✅ 選擇：Gemini CLI
│     理由：1M+ tokens 全局視野
│
├─ 架構重構規劃（需要分析所有依賴）
│  └─ ✅ 選擇：Gemini CLI
│     理由：看到完整依賴圖
│
├─ 跨服務問題定位（微服務架構）
│  └─ ✅ 選擇：Gemini CLI
│     理由：一次載入所有服務
│
├─ 日常開發與編碼
│  └─ ❌ 不選 Gemini
│     應該用：Copilot + Claude Code
│
├─ 需要實際修改程式碼
│  └─ ❌ 不選 Gemini
│     應該用：Claude Code
│
└─ 中小型專案（<30 檔案）
   └─ ❌ 不選 Gemini
      應該用：Claude Code（200K tokens 足夠）
```

---

## 💡 最佳實踐

### DO（應該做）

✅ **準備 GEMINI.md**：
```markdown
在使用前寫好 GEMINI.md
包含：專案概述、架構、分析目標
讓 Gemini 有方向地分析
```

✅ **一次性載入**：
```bash
# 第一次分析時載入所有檔案
gemini-cli --include "src/**/*.py" --include "tests/**/*.py"

# 之後的對話中保持相同上下文
```

✅ **儲存分析結果**：
```bash
# 將重要分析結果儲存到 GEMINI.md
# 避免重複分析，節省成本
```

✅ **定期更新**：
```
專案重大變更後，重新分析
更新 GEMINI.md 中的架構和已知問題
```

---

### DON'T（不應該做）

❌ **頻繁使用**：
```
不要每次寫程式碼都啟動 Gemini
成本高、速度慢
僅在需要全局分析時使用
```

❌ **用於小專案**：
```
<30 檔案的專案用 Claude Code 即可
不需要 1M tokens
```

❌ **期待實時互動**：
```
Gemini 啟動較慢（需載入大量檔案）
不適合需要快速來回的任務
```

❌ **忽略成本**：
```
每次分析 1M tokens ≈ $0.13
頻繁使用成本會累積
善用 chat 儲存避免重複載入
```

---

## 🚀 快速上手指南

### 5 分鐘入門

**步驟 1：安裝**（1 分鐘）
```bash
# 安裝 Gemini CLI
npm install -g @google/generative-ai

# 設定 API Key
export GEMINI_API_KEY="your-api-key"
```

**步驟 2：建立 GEMINI.md**（2 分鐘）
```markdown
# GEMINI.md

## Overview
[專案描述]

## Analysis Goals
1. 理解整體架構
2. 找出核心業務邏輯
3. 識別技術債
```

**步驟 3：第一次分析**（2 分鐘）
```bash
# 啟動並載入專案
gemini-cli --context-size 1M --include "src/**/*"

# 問全局問題
> 分析這個專案的架構，說明核心模組和依賴關係
```

---

## 📊 效能評估

### 適用場景 ROI

```
場景：新人 Onboarding

傳統方式：
- 閱讀文檔：2 天
- 詢問同事：3 天
- 逐步理解程式碼：2 週
總計：3 週

使用 Gemini CLI：
- 全局分析：10 分鐘
- 理解核心流程：1 小時
- 開始貢獻程式碼：第 2 天
總計：2 天

時間節省：93%
成本：$1（一次性分析）
價值：工程師 3 週薪資
```

---

## 🎯 學習檢查點

完成本章後，驗證你是否掌握：

### 理論理解

- [ ] 能說明巨量上下文（1M+ tokens）的優勢
- [ ] 能舉 3 個最適合 Gemini CLI 的場景
- [ ] 理解 GEMINI.md 的設計原則
- [ ] 知道 Gemini 與 Claude Code 的差異

### 實踐能力

- [ ] 能撰寫有效的 GEMINI.md
- [ ] 能使用 Gemini CLI 分析大型專案
- [ ] 能提出有效的全局分析問題
- [ ] 能評估何時該用 Gemini vs Claude Code

---

## 🔗 延伸學習

### 下一步

- **決策能力**：3.3 工具選擇決策樹
- **實戰練習**：基礎級 B01 - 工具選擇實戰
- **混合使用**：實作/練習 1 - 混合工具鏈設計

### 相關資源

- [Gemini API Docs](https://ai.google.dev/docs)
- [Context Window Comparison](https://artificialanalysis.ai/models)
- [Large Context Best Practices](https://cloud.google.com/vertex-ai/docs/generative-ai)

---

**章節版本**：v1.0
**最後更新**：2025-01-30
**閱讀時間**：15 分鐘
**難度**：⭐⭐ 中等

**重點總結**：
> Gemini CLI = 「全局理解」超能力（1M+ tokens）
> 最適合：新專案理解、架構分析、跨服務問題定位
> 關鍵：準備 GEMINI.md + 一次性分析 + 節省成本
> 使用時機：專案初期 or 重大重構規劃
