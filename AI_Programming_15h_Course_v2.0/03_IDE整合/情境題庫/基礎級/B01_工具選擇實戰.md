# B01：工具選擇實戰（基礎級）

## 情境資訊

**編號**：B01
**難度**：⭐⭐☆☆☆（基礎級）
**預計時間**：30 分鐘
**學習目標**：
- 訓練快速識別場景特徵的能力
- 為不同場景選擇最適合的工具
- 理解選擇背後的關鍵因素
- 建立工具選擇的直覺判斷

**適用對象**：
- 完成模組 3 理論章節
- 理解三大工具的核心差異
- 想建立快速決策能力

---

## 情境描述

你是一位全端工程師，在日常工作中會遇到各種不同的開發任務。每個任務都需要你快速判斷應該使用哪個 AI 工具來最大化效率。

以下是 10 個真實工作場景，請為每個場景選擇最適合的工具，並說明理由。

---

## 場景 1：快速實作 React 元件

### 背景

你需要實作一個「使用者個人資料卡片」元件，包含：
- 顯示頭像、姓名、email
- 「編輯」按鈕
- 響應式設計
- 基本樣式

**任務規模**：
- 單一檔案（UserCard.tsx）
- 約 100 行程式碼
- 使用已有的 UI library（Material-UI）

### 你的選擇

工具：______________

理由（寫下 2-3 個關鍵因素）：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 2：重構 REST API 為 GraphQL

### 背景

團隊決定將現有的 50 個 REST API 端點遷移到 GraphQL。需要：
- 修改 50 個 controller 檔案
- 建立 GraphQL schema
- 更新所有前端呼叫
- 確保向後兼容

**任務規模**：
- 70+ 個檔案需要修改
- 跨前後端
- 需要 2 週時間

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 3：理解遺留專案

### 背景

你剛加入新公司，接手一個 5 年前建立的電商系統：
- 600 個 Python 檔案
- 複雜的 Django 架構
- 文檔不完整
- 前任開發者已離職

**任務目標**：
- 第一天就要理解核心業務邏輯
- 找出訂單處理流程
- 識別技術債
- 為重構做準備

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 4：為函數生成單元測試

### 背景

你剛寫完 15 個業務邏輯函數，現在需要：
- 為每個函數生成單元測試
- 覆蓋正常情況
- 覆蓋邊界情況
- 覆蓋錯誤處理

**任務規模**：
- 15 個函數
- 預計 50+ 個測試案例
- 使用 pytest 框架

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 5：安全審查 Pull Request

### 背景

你是 tech lead，需要審查同事提交的 PR：
- 涉及支付處理邏輯
- 修改了 8 個檔案
- 需要檢查：SQL 注入、XSS、CSRF、密鑰安全

**任務目標**：
- 深度安全分析
- 找出所有潛在漏洞
- 提供修復建議
- 確保符合 PCI DSS 標準

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 6：批量建立 CRUD API

### 背景

你需要為 10 個不同的資料模型建立標準 CRUD API：
- User, Product, Order, Category, Review...
- 每個都是標準的 Create, Read, Update, Delete
- 相似的結構和邏輯
- 需要保持一致性

**任務規模**：
- 10 個 models
- 40 個 API 端點（每個 4 個）
- 高度重複的模式

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 7：生成 API 文檔

### 背景

你完成了後端開發，現在需要：
- 生成 OpenAPI (Swagger) 文檔
- 包含所有 50 個端點
- 描述請求/回應格式
- 提供範例
- 說明錯誤碼

**任務目標**：
- 完整、準確的 API 文檔
- 格式規範
- 易於前端團隊理解

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 8：分析微服務依賴關係

### 背景

你的系統是微服務架構，包含：
- 12 個獨立服務
- 每個服務 30-50 個檔案
- 服務之間透過 RabbitMQ 和 REST API 通訊
- 需要畫出完整的依賴圖

**任務目標**：
- 理解所有服務之間的呼叫關係
- 找出循環依賴
- 識別單點故障風險
- 規劃優化方案

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 9：實作複雜業務邏輯

### 背景

你需要實作「訂單折扣計算」邏輯：
- 會員等級折扣
- 優惠券疊加規則
- 滿額減免
- 限時活動
- 複雜的條件判斷（20+ 種情況）

**任務規模**：
- 單一檔案
- 約 200 行程式碼
- 需要詳細註解

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 場景 10：重構單體應用為微服務

### 背景

你負責規劃重構計畫：
- 現有 Monolith：1000 個檔案
- 目標：拆分為 8 個微服務
- 需要分析：模組依賴、資料庫耦合、API 邊界

**階段 1 任務**（本場景）：
- 分析整個專案
- 識別可獨立拆分的模組
- 評估拆分風險
- 制定遷移策略

### 你的選擇

工具：______________

理由：
1. _________________________________
2. _________________________________
3. _________________________________

---

## 📝 答題區

在開始對照答案前，請先完成所有 10 個場景的選擇：

```
場景 1：工具 = __________, 理由 = __________
場景 2：工具 = __________, 理由 = __________
場景 3：工具 = __________, 理由 = __________
場景 4：工具 = __________, 理由 = __________
場景 5：工具 = __________, 理由 = __________
場景 6：工具 = __________, 理由 = __________
場景 7：工具 = __________, 理由 = __________
場景 8：工具 = __________, 理由 = __________
場景 9：工具 = __________, 理由 = __________
場景 10：工具 = __________, 理由 = __________
```

---

## ✅ 參考答案與詳細分析

### 場景 1：React 元件實作

**推薦工具**：**Copilot**

**理由**：
1. **檔案規模小**：單一檔案，約 100 行
   - Copilot 的上下文範圍（~128K tokens）完全足夠

2. **即時互動**：寫元件時需要持續補全
   - JSX 語法補全
   - props 類型推導
   - event handler 生成

3. **樣板程式碼**：React 元件有固定模式
   - Copilot 擅長識別和重複模式
   - 自動生成 useState, useEffect 等

**替代方案**：無（這是 Copilot 的最佳場景）

**得分標準**：
- 選 Copilot：10 分
- 選 Claude Code：6 分（可用但不是最優）
- 選 Gemini CLI：0 分（大材小用）

---

### 場景 2：REST 到 GraphQL 重構

**推薦工具**：**Claude Code**

**理由**：
1. **跨檔案操作**：70+ 檔案需要修改
   - 超出 Copilot 的能力範圍
   - Claude Code 可以編排工作流程

2. **一致性要求**：所有修改需要統一模式
   - Claude Code 可以定義一次，應用到所有檔案
   - 使用 /agents:refactoring-specialist

3. **複雜度高**：需要理解前後端關聯
   - Claude Code 可以分析整個專案上下文
   - Copilot 只能看當前檔案

**混合使用**：
```
1. Claude Code 設計遷移計畫（1 天）
2. Claude Code 批量修改後端（3 天）
3. Copilot 輔助前端修改（2 天）
4. Claude Code 生成遷移文檔（1 天）
```

**得分標準**：
- 選 Claude Code：10 分
- 選 Gemini CLI：5 分（可分析但無法執行）
- 選 Copilot：2 分（無法處理如此規模）

---

### 場景 3：理解遺留專案

**推薦工具**：**Gemini CLI**

**理由**：
1. **巨量程式碼**：600 個檔案
   - Claude Code 上下文限制（~200K tokens）不夠
   - Gemini CLI 可載入 1M+ tokens

2. **全局理解**：需要理解整體架構
   - 一次性載入所有檔案
   - 直接問：「訂單處理流程是什麼？」

3. **快速 Onboarding**：第一天就要理解
   - Gemini CLI 10 分鐘內分析完成
   - Claude Code 需要多次對話逐步理解

**工作流程**：
```
Day 1 上午：
1. 準備 GEMINI.md（專案概述）
2. 啟動 Gemini CLI，載入所有檔案
3. 問全局問題：
   - 系統架構是什麼？
   - 訂單處理流程？
   - 支付邏輯在哪裡？
   - 有哪些技術債？

Day 1 下午開始：
- 切換到 Claude Code 進行日常開發
```

**得分標準**：
- 選 Gemini CLI：10 分
- 選 Claude Code：6 分（可用但效率低）
- 選 Copilot：0 分（無法理解全局）

---

### 場景 4：單元測試生成

**推薦工具**：**Copilot**

**理由**：
1. **重複模式**：測試案例有固定結構
   - Copilot 擅長識別和複製模式
   - 自動生成 assert 語句

2. **即時生成**：寫完函數立即生成測試
   - 開啟測試檔案
   - 寫 `def test_function_name`
   - Copilot 自動補全整個測試

3. **覆蓋完整**：自動想到邊界情況
   - 正常輸入
   - 邊界值
   - 錯誤情況

**範例**：
```python
# 你有這個函數：
def calculate_total(items, tax_rate):
    subtotal = sum(item.price for item in items)
    return subtotal * (1 + tax_rate)

# 你開始寫：
def test_calculate_total

# Copilot 自動生成：
def test_calculate_total():
    # Normal case
    items = [Item(price=100), Item(price=200)]
    assert calculate_total(items, 0.1) == 330

    # Edge case: empty list
    assert calculate_total([], 0.1) == 0

    # Edge case: zero tax
    items = [Item(price=100)]
    assert calculate_total(items, 0) == 100
```

**得分標準**：
- 選 Copilot：10 分
- 選 Claude Code：7 分（可用，特別是複雜測試）
- 選 Gemini CLI：0 分（不適合）

---

### 場景 5：安全審查 PR

**推薦工具**：**Claude Code**（/agents:security-auditor）

**理由**：
1. **深度分析**：需要專業安全知識
   - Security-auditor agent 專門訓練於安全審查
   - 可以識別細微的安全漏洞

2. **跨檔案理解**：8 個檔案的關聯
   - 理解資料流
   - 追蹤敏感資料
   - 檢查所有入口點

3. **詳細報告**：需要提供修復建議
   - Claude Code 可以生成完整報告
   - 包含風險等級和修復方案

**使用方式**：
```bash
claude

> /agents:security-auditor

> 請審查這個 PR（8 個檔案）的安全性：
> 1. 檢查 SQL 注入風險
> 2. 檢查 XSS 漏洞
> 3. 檢查支付密鑰安全
> 4. 檢查 CSRF 保護
> 5. 生成安全審查報告

> /output-style:security-report
```

**得分標準**：
- 選 Claude Code：10 分
- 選 Gemini CLI：4 分（可分析但不夠深入）
- 選 Copilot：2 分（基本提示，不夠專業）

---

### 場景 6：批量建立 CRUD API

**推薦工具**：**Copilot**

**理由**：
1. **高度重複**：10 個 models，邏輯完全相同
   - Copilot 學習第一個後，自動複製到其他

2. **模式識別**：CRUD 是標準模式
   - Create, Read, Update, Delete
   - Copilot 熟悉這些模式

3. **速度優勢**：即時補全最快
   - 寫一個完整，其他 9 個靠 Tab

**工作流程**：
```python
# 寫第一個（User）：完整實作
@app.post("/api/users")
def create_user(user: UserCreate):
    ...

@app.get("/api/users/{id}")
def get_user(user_id: int):
    ...

# 寫第二個（Product）：
@app.post("/api/products")
# ↑ Copilot 自動補全整個函數（複製 User 模式）

# 以此類推，10 個 models 快速完成
```

**得分標準**：
- 選 Copilot：10 分
- 選 Claude Code：7 分（可用但慢）
- 選 Gemini CLI：0 分（不適合）

---

### 場景 7：生成 API 文檔

**推薦工具**：**Claude Code**（/output-style:api-docs）

**理由**：
1. **格式控制**：需要特定格式（OpenAPI）
   - Claude Code 的 output-style 功能
   - 確保格式規範

2. **完整性**：50 個端點需要全部涵蓋
   - Claude Code 可以分析所有 API 檔案
   - 自動提取資訊

3. **範例生成**：需要提供使用範例
   - Claude Code 理解 API 邏輯
   - 生成真實可用的範例

**使用方式**：
```bash
claude

> /output-style:api-docs

> 分析 src/api/ 目錄下的所有端點，
> 生成完整的 OpenAPI 3.0 文檔。
>
> 要求：
> 1. 包含所有端點的完整描述
> 2. 提供請求/回應範例
> 3. 說明所有錯誤碼
> 4. 標註認證要求
```

**得分標準**：
- 選 Claude Code：10 分
- 選 Copilot：4 分（可生成但不夠完整）
- 選 Gemini CLI：3 分（可分析但格式控制弱）

---

### 場景 8：微服務依賴分析

**推薦工具**：**Gemini CLI**

**理由**：
1. **跨服務分析**：12 個服務需要一起載入
   - 每個服務 30-50 檔案
   - 總計 400+ 檔案
   - Claude Code 上下文不夠（~200K tokens）

2. **全局視野**：需要看到所有呼叫關係
   - Gemini CLI 1M+ tokens 可容納所有服務
   - 一次性問：「所有服務之間的依賴關係？」

3. **複雜分析**：需要追蹤跨服務流程
   - RabbitMQ 事件流
   - REST API 呼叫
   - 資料庫共享

**工作流程**：
```bash
# 準備 GEMINI.md
cat > GEMINI.md << 'EOF'
# Microservices Architecture

## Services (12)
1. User Service
2. Product Service
3. Order Service
...

## Analysis Goals
1. 畫出完整依賴圖
2. 找出循環依賴
3. 識別單點故障
EOF

# 啟動 Gemini CLI
gemini-cli --context-size 1M --include "services/**/src/**/*.py"

# 提問
> 分析所有 12 個服務，回答：
> 1. 服務之間的呼叫關係圖？
> 2. 有沒有循環依賴？
> 3. 哪些是關鍵服務（被多個服務依賴）？
> 4. 單點故障風險在哪裡？
```

**得分標準**：
- 選 Gemini CLI：10 分
- 選 Claude Code：5 分（需要多次對話，效率低）
- 選 Copilot：0 分（無法理解全局）

---

### 場景 9：複雜業務邏輯實作

**推薦工具**：**Copilot + Claude Code**（混合使用）

**理由**：
1. **單一檔案**：規模適合 Copilot
   - 約 200 行
   - 單一檔案操作

2. **複雜邏輯**：需要多次推敲
   - 20+ 種條件
   - 優惠券疊加規則複雜
   - 需要與 Claude Code 討論邏輯

**推薦流程**：
```
步驟 1：用 Claude Code 設計邏輯（15 分鐘）
> 討論：「訂單折扣計算」的邏輯設計
> - 會員等級折扣如何計算？
> - 優惠券疊加規則？
> - 滿額減免的優先順序？

步驟 2：用 Copilot 快速實作（30 分鐘）
> 根據討論的邏輯
> 使用 Copilot 快速撰寫程式碼
> 充分利用註解引導 Copilot

步驟 3：用 Claude Code 審查（15 分鐘）
> /agents:code-reviewer
> 檢查邏輯是否正確
> 檢查邊界情況
```

**得分標準**：
- 選 Copilot + Claude Code：10 分
- 選 Copilot：7 分（可用但需要自己驗證邏輯）
- 選 Claude Code：7 分（可用但編碼較慢）
- 選 Gemini CLI：0 分（不適合）

---

### 場景 10：Monolith 到 Microservices 規劃

**推薦工具**：**Gemini CLI（階段 1）+ Claude Code（階段 2）**

**理由**：
1. **階段 1 - 分析規劃**：Gemini CLI
   - 1000 個檔案需要全局分析
   - 找出模組依賴關係
   - 評估拆分風險
   - Gemini CLI 的 1M+ tokens 上下文優勢

2. **階段 2 - 執行遷移**：Claude Code
   - 實際修改程式碼
   - 建立新專案結構
   - 工作流程編排

**完整流程**：
```
Week 1: 規劃（Gemini CLI）
├─ Day 1-2: 全局分析
│   └─ Gemini CLI 載入所有 1000 檔案
│   └─ 分析模組依賴
│   └─ 識別可拆分模組
│   └─ 評估拆分風險
│
└─ Day 3-5: 制定計畫
    └─ 轉到 Claude Code
    └─ 設計新架構
    └─ 撰寫遷移文檔

Week 2-4: 執行（Claude Code）
└─ 逐步拆分模組
└─ 建立新服務
└─ 遷移資料庫
└─ 更新 API 呼叫
```

**得分標準**：
- 選 Gemini CLI（分析）+ Claude Code（執行）：10 分
- 選 Gemini CLI：7 分（分析對了，但無法執行）
- 選 Claude Code：4 分（可執行但缺少全局分析）
- 選 Copilot：0 分（完全不適合）

---

## 📊 評分標準

### 總分計算

每題 10 分，總分 100 分：
- **工具選擇正確**：6 分
- **理由完整**：3 分
- **考慮成本或替代方案**：1 分

### 等級評定

- **90-100 分**：⭐⭐⭐⭐⭐ 專家級
  - 工具選擇全部正確
  - 理由充分且考慮全面
  - 可以為團隊制定工具策略

- **70-89 分**：⭐⭐⭐⭐ 優秀
  - 大部分選擇正確
  - 理解工具特性
  - 可以獨立做決策

- **60-69 分**：⭐⭐⭐ 及格
  - 基本選擇正確
  - 理由尚可
  - 需要更多實踐

- **<60 分**：⭐⭐ 需要加強
  - 建議重新閱讀理論章節
  - 再次練習

---

## 🎯 反思問題

完成評分後，思考以下問題：

1. **錯誤最多的場景是哪個？為什麼？**
   - 是否忽略了檔案數量？
   - 是否忽略了上下文限制？
   - 是否忽略了執行能力？

2. **你的決策模式是什麼？**
   - 你通常先考慮什麼因素？
   - 哪個因素最容易忽略？

3. **如何改進？**
   - 下次遇到類似場景會怎麼做？
   - 需要補強哪方面知識？

---

## 🔗 下一步

### 如果得分 ≥ 70 分
恭喜！你已經掌握基本的工具選擇能力。

**建議**：
- 繼續挑戰組合級情境（C01-C05）
- 設計自己的混合工具鏈
- 應用到實際工作中

### 如果得分 < 70 分
不要氣餒！工具選擇需要經驗累積。

**建議**：
1. 重新閱讀理論/3.3 工具選擇決策樹
2. 特別關注「三個問題法」
3. 完成 B03: 場景特徵識別
4. 一週後重做本題

---

**情境版本**：v1.0
**最後更新**：2025-01-30
**建議完成時間**：30 分鐘
**難度評估**：2/5
**重要度**：5/5（工具選擇是基礎能力）
