# C01：混合工具鏈日常開發

## 📋 情境描述

### 背景故事

你是一名資深全端工程師，負責開發一個電商平台的新功能模組。團隊配置了多個 AI 工具（GitHub Copilot、Claude Code、Cursor），你需要設計一套高效的混合工作流程，在一天內完成從需求分析到部署的完整循環。

**專案資訊**：
- 專案：電商平台（React + Node.js + PostgreSQL）
- 程式碼規模：150,000 行
- 團隊：10 人全端團隊
- 工具配置：GitHub Copilot（所有人）、Claude Code（Tech Lead）、Cursor（可選）

**今天的任務**：
實作「商品推薦系統」功能
- 需求文檔：已提供 PRD（Product Requirements Document）
- 時間限制：8 小時（一個工作日）
- 品質要求：需通過 Code Review 並部署到 Staging

---

## 🎯 學習目標

完成本情境後，你將能夠：
- ✅ 設計混合 AI 工具的工作流程
- ✅ 知道何時使用哪個工具
- ✅ 最大化每個工具的優勢
- ✅ 完成完整的開發循環（需求→設計→編碼→測試→部署）
- ✅ 掌握工具切換的最佳時機

---

## 📝 完整工作流程設計

### 階段 1：需求分析與技術設計（1 小時）

**使用工具**：Claude Code（主要）+ Cursor（輔助）

**任務 1.1：理解需求文檔（20 分鐘）**

```bash
# 使用 Claude Code 快速分析 PRD
claude /read docs/PRD_recommendation_system.md

# 提問 Claude Code
"請分析這份 PRD 並回答：
1. 核心功能點有哪些？
2. 技術挑戰在哪裡？
3. 需要哪些新的 API 端點？
4. 資料庫需要哪些新表或欄位？
5. 與現有系統的整合點在哪裡？"

# 輸出：結構化的需求分析
```

**為什麼選擇 Claude Code？**
- ✅ 擅長理解長文檔（上下文容量大）
- ✅ 能夠跨檔案分析系統架構
- ✅ 提供結構化的技術建議

**任務 1.2：系統架構分析（20 分鐘）**

```bash
# 使用 Claude Code 分析現有架構
claude "分析現有的電商系統架構：
1. 檢查 src/api/products/ 目錄結構
2. 檢查資料庫 schema（models/）
3. 檢查前端元件結構（components/products/）
4. 識別可重用的模組"

# 輸出：架構分析報告
# - 現有系統的相關模組
# - 可重用的程式碼
# - 需要新建的模組
```

**任務 1.3：技術方案設計（20 分鐘）**

使用 Claude Code 生成技術設計文檔：

```bash
claude "基於以上分析，設計推薦系統的技術方案：

1. API 設計（RESTful endpoints）
2. 資料庫設計（新表和關聯）
3. 推薦算法選擇（協同過濾 vs 內容過濾）
4. 前端元件設計
5. 性能考慮（快取策略）
6. 測試策略

請輸出 technical_design.md"
```

**檢查點**：
- [ ] 完成需求分析文檔
- [ ] 完成技術設計文檔
- [ ] 識別所有需要開發的模組
- [ ] 確認與 Tech Lead 溝通技術方案

---

### 階段 2：資料庫與後端開發（2.5 小時）

**使用工具**：GitHub Copilot（主要）+ Claude Code（審查）

**任務 2.1：資料庫 Schema（30 分鐘）**

使用 **Copilot** 快速開發：

```javascript
// models/Recommendation.js

// Create a Mongoose schema for product recommendations
// Fields:
// - userId: ObjectId ref User
// - productId: ObjectId ref Product
// - score: Number (0-100)
// - reason: String (why recommended)
// - algorithm: String (collaborative/content/hybrid)
// - createdAt: Date
// - viewedAt: Date (nullable)
// - clickedAt: Date (nullable)
// - purchasedAt: Date (nullable)
// Add indexes for: userId, productId, score, createdAt
// Add compound index for (userId, score desc)

// [讓 Copilot 生成完整 Schema]
```

**為什麼選擇 Copilot？**
- ✅ 樣板程式碼生成快速
- ✅ IDE 內即時補全
- ✅ 適合單檔案開發

**任務 2.2：推薦算法實作（60 分鐘）**

使用 **Copilot** + 手動調整：

```javascript
// services/RecommendationService.js

// Implement a hybrid recommendation system that combines:
// 1. Collaborative filtering (user-based)
// 2. Content-based filtering (product attributes)
// 3. Popularity-based (trending products)
// Weight: 40% collaborative, 40% content, 20% popularity

class RecommendationService {
  // Generate recommendations for a user
  // Input: userId, limit (default 10)
  // Output: Array of { productId, score, reason }
  async generateRecommendations(userId, limit = 10) {
    // [讓 Copilot 生成]
  }

  // Collaborative filtering: find similar users
  // [讓 Copilot 生成]
  async findSimilarUsers(userId, limit = 10) {
    // Calculate Jaccard similarity based on purchase history
  }

  // Content-based: find similar products
  // [讓 Copilot 生成]
  async findSimilarProducts(productId, limit = 10) {
    // Calculate cosine similarity based on product attributes
  }

  // Get trending products
  // [讓 Copilot 生成]
  async getTrendingProducts(limit = 10) {
    // Based on recent views and purchases
  }
}
```

**技巧**：
- 逐個方法開發，不要一次寫所有註解
- 檢查 Copilot 生成的算法是否正確
- 手動優化複雜邏輯

**任務 2.3：API Endpoints（60 分鐘）**

使用 **Copilot** 快速生成 CRUD：

```javascript
// routes/recommendations.js

// Implement the following endpoints:
// GET /api/recommendations - Get recommendations for current user
// GET /api/recommendations/similar/:productId - Get similar products
// POST /api/recommendations/feedback - Record user feedback (view/click/purchase)
// GET /api/recommendations/trending - Get trending products
// [讓 Copilot 生成]
```

**檢查點**：
- [ ] Schema 定義完整且有適當索引
- [ ] 推薦算法基本可用（不需完美）
- [ ] API 端點實作完成
- [ ] 包含基本的錯誤處理

---

### 階段 3：代碼審查與安全性檢查（30 分鐘）

**使用工具**：Claude Code（主要）

**為什麼切換到 Claude Code？**
- ✅ 跨檔案分析能力強
- ✅ 系統性程式碼審查
- ✅ 安全性檢查專業

**任務 3.1：安全性審查**

```bash
claude /security-review services/RecommendationService.js routes/recommendations.js

# Claude Code 會檢查：
# - SQL/NoSQL 注入風險
# - 認證授權是否正確
# - 輸入驗證
# - 敏感資料處理
# - 速率限制
```

**任務 3.2：程式碼品質審查**

```bash
claude "審查以下程式碼的品質問題：
1. 效能問題（N+1 查詢、不必要的迴圈）
2. 記憶體洩漏
3. 錯誤處理完整性
4. 程式碼可讀性
5. 是否符合專案規範（檢查 CLAUDE.md）"
```

**任務 3.3：優化建議**

```bash
claude "提供優化建議：
1. 如何添加快取（Redis）
2. 如何優化資料庫查詢
3. 如何處理大量使用者的並發請求"
```

**檢查點**：
- [ ] 無安全漏洞
- [ ] 程式碼品質達標
- [ ] 有具體的優化方案（可後續實作）

---

### 階段 4：前端開發（2 小時）

**使用工具**：GitHub Copilot（主要）

**任務 4.1：React 元件開發（90 分鐘）**

```typescript
// components/ProductRecommendations.tsx

// Create a ProductRecommendations component that:
// 1. Fetches recommendations from API
// 2. Displays products in a grid layout (4 columns)
// 3. Shows product image, name, price, rating
// 4. Shows why it's recommended (hover tooltip)
// 5. Handles loading and error states
// 6. Tracks view/click events
// [讓 Copilot 生成]
```

```typescript
// components/SimilarProducts.tsx

// Create a SimilarProducts component for product detail page
// Similar to ProductRecommendations but:
// - Horizontal scroll layout
// - Shows "Customers also viewed" heading
// - Auto-scroll every 5 seconds
// [讓 Copilot 生成]
```

**技巧**：
- 使用 Tailwind CSS class 給 Copilot 明確的樣式指示
- 參考現有元件的程式碼風格
- TypeScript 類型定義讓 Copilot 建議更準確

**任務 4.2：狀態管理（30 分鐘）**

```typescript
// hooks/useRecommendations.ts

// Custom hook for managing recommendations state
// Features:
// - Fetch recommendations
// - Pagination (load more)
// - Track feedback (view/click)
// - Cache results (React Query or SWR)
// [讓 Copilot 生成]
```

**檢查點**：
- [ ] 元件正常渲染
- [ ] API 整合成功
- [ ] 使用者互動流暢
- [ ] 載入和錯誤狀態處理正確

---

### 階段 5：測試開發（1 小時）

**使用工具**：GitHub Copilot（主要）+ Claude Code（測試策略）

**任務 5.1：單元測試（30 分鐘）**

先用 Claude Code 設計測試策略：
```bash
claude "為推薦系統設計測試策略：
1. 需要測試哪些關鍵函數？
2. 需要 mock 哪些外部依賴？
3. 邊界情況有哪些？"
```

然後用 Copilot 生成測試：
```javascript
// tests/RecommendationService.test.js

// Write unit tests for RecommendationService
// Test cases:
// 1. generateRecommendations returns correct number of items
// 2. generateRecommendations filters out already purchased products
// 3. findSimilarUsers handles edge cases (new user, no history)
// 4. findSimilarProducts returns relevant products
// 5. getTrendingProducts respects time window
// [讓 Copilot 生成]
```

**任務 5.2：整合測試（30 分鐘）**

```javascript
// tests/recommendations.api.test.js

// Write API integration tests using Supertest
// Test all endpoints with various scenarios
// [讓 Copilot 生成]
```

**檢查點**：
- [ ] 測試覆蓋率 ≥ 70%
- [ ] 所有測試通過
- [ ] 包含邊界情況測試

---

### 階段 6：文檔與部署（1 小時）

**使用工具**：Claude Code（主要）

**任務 6.1：API 文檔生成（20 分鐘）**

```bash
claude "生成 API 文檔（OpenAPI/Swagger 格式）：
1. 分析 routes/recommendations.js
2. 提取所有端點
3. 生成完整的 OpenAPI spec
4. 包含請求/回應範例"
```

**任務 6.2：系統文檔更新（20 分鐘）**

```bash
claude "更新系統架構文檔：
1. 添加推薦系統模組到架構圖
2. 更新資料流程圖
3. 添加推薦算法說明
4. 更新 README.md"
```

**任務 6.3：部署準備（20 分鐘）**

```bash
# 使用 GitHub Copilot 生成部署配置
# docker-compose.yml
# .env.staging
# migration scripts
```

**檢查點**：
- [ ] API 文檔完整
- [ ] 系統文檔更新
- [ ] 部署配置完成
- [ ] 通過 CI/CD 管道

---

## 🎓 關鍵學習點

### 工具選擇策略

| 階段 | 主要工具 | 選擇原因 |
|------|---------|---------|
| 需求分析 | Claude Code | 長文檔理解、系統性分析 |
| 技術設計 | Claude Code | 跨檔案分析、架構設計 |
| 編碼（後端） | Copilot | 快速補全、樣板程式碼 |
| 程式碼審查 | Claude Code | 安全性、品質檢查 |
| 編碼（前端） | Copilot | React 元件、即時補全 |
| 測試策略 | Claude Code | 系統性測試規劃 |
| 測試編碼 | Copilot | 快速生成測試案例 |
| 文檔生成 | Claude Code | 結構化文檔、API spec |

### 工具切換時機

**從 Copilot 切換到 Claude Code**：
- ✅ 需要跨檔案分析時
- ✅ 需要程式碼審查時
- ✅ 需要架構級別的決策時
- ✅ 需要生成文檔時

**從 Claude Code 切換到 Copilot**：
- ✅ 開始實際編碼時
- ✅ 需要快速補全時
- ✅ 在單一檔案內工作時
- ✅ 需要即時回饋時

### 效率提升分析

**傳統開發時間**：
- 需求分析：2 小時
- 技術設計：2 小時
- 後端開發：4 小時
- 前端開發：3 小時
- 測試開發：2 小時
- 文檔撰寫：1 小時
- **總計：14 小時**

**使用混合工具鏈**：
- 需求分析：1 小時（節省 50%）
- 技術設計：0 小時（併入需求分析）
- 後端開發：2.5 小時（節省 38%）
- 前端開發：2 小時（節省 33%）
- 測試開發：1 小時（節省 50%）
- 文檔撰寫：1 小時（效率不變）
- **總計：7.5 小時（節省 46%）**

---

## ⚡ 自然學到的技能

### 工作流程設計
- ✅ EPCV 工作流程的實際應用
- ✅ 工具之間的無縫切換
- ✅ 時間管理和優先級排序

### 工具整合技巧
- ✅ 如何在 IDE 和 CLI 之間切換
- ✅ 如何保持上下文連貫性
- ✅ 如何最大化每個工具的優勢

### 品質保證
- ✅ 開發中的持續審查
- ✅ 安全性優先思維
- ✅ 測試驅動的開發流程

---

## ✅ 完成標準

### 功能完整性
- [ ] 推薦系統可正常運作
- [ ] API 端點全部實作並測試通過
- [ ] 前端元件正常顯示和互動
- [ ] 整合測試全部通過

### 程式碼品質
- [ ] 無安全漏洞
- [ ] 測試覆蓋率 ≥ 70%
- [ ] 符合專案編碼規範
- [ ] 有完整的錯誤處理

### 文檔完整性
- [ ] API 文檔完整
- [ ] 系統架構文檔更新
- [ ] README 更新
- [ ] 部署文檔完整

### 時間控制
- [ ] 在 8 小時內完成
- [ ] 預留 1 小時緩衝時間處理問題

---

## 💡 進階挑戰

### 挑戰 1：性能優化
使用 Claude Code 添加快取層：
- Redis 快取推薦結果
- 設定合理的 TTL
- 實作快取失效策略

### 挑戰 2：A/B 測試
添加推薦算法的 A/B 測試：
- 實作多個算法版本
- 隨機分配使用者到不同版本
- 收集效果指標

### 挑戰 3：即時推薦
實作即時推薦更新：
- WebSocket 連線
- 使用者行為即時追蹤
- 推薦結果即時更新

---

## 📊 工具使用統計

| 工具 | 使用時間 | 主要場景 | 效率提升 |
|------|---------|---------|---------|
| Claude Code | 2.5 小時 | 分析、審查、文檔 | 50% |
| GitHub Copilot | 4.5 小時 | 編碼、測試 | 40% |
| 手動開發 | 1.5 小時 | 複雜邏輯、調整 | - |

**關鍵發現**：
- 沒有單一工具能解決所有問題
- 工具切換的成本遠低於收益
- 混合使用比單一工具效率高 2-3 倍

---

**情境難度**：⭐⭐ 組合級
**預計時間**：8 小時（完整工作日）
**工具組合**：Claude Code + GitHub Copilot
**學習收穫**：掌握混合工具鏈的完整工作流程，實際效率提升 40-50%
