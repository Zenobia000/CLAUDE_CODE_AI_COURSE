# 6.1 MCP 協議深入 - 將外部世界掛載到 AI

## 📚 本節概述

**學習時間**：30 分鐘（理論） + 30 分鐘（實作）

**學習目標**：
- 理解 MCP（Model Context Protocol）的設計哲學
- 掌握 MCP 與傳統 API 的本質差異
- 學會配置與管理 MCP servers
- 建立 MCP 安全與治理的最佳實踐

**為什麼這很重要**：
> MCP 不是另一個 API 協議，而是 AI 與外部世界溝通的「通用語言」。
> 理解 MCP，就理解了如何讓 AI 真正融入你的工作流程。

---

## 第一部分：MCP 的本質 - 為什麼我們需要它？

### 1.1 傳統 API 整合的痛點

#### 情境：你想讓 Claude Code 讀取 GitHub Issues

**傳統 REST API 方式**：
```python
# 你需要寫這樣的程式碼
import requests

headers = {"Authorization": f"token {GITHUB_TOKEN}"}
response = requests.get(
    "https://api.github.com/repos/owner/repo/issues",
    headers=headers
)
issues = response.json()

# 然後手動把資料貼給 Claude
prompt = f"這是我的 issues：{issues}，請幫我分析..."
```

**問題在哪**？
1. **每次都要寫程式碼**：想讀取資料，就要寫 API 調用
2. **上下文斷裂**：資料在外部，AI 在內部，中間需要人工搬運
3. **無法動態互動**：AI 不能「主動」去查詢它需要的資料
4. **權限管理複雜**：每個 API 都有不同的認證機制

#### MCP 的解決方案

**使用 MCP 後**：
```bash
# 1. 配置一次 GitHub MCP（只需要做一次）
# .claude/mcp-config.json 加入 GitHub MCP

# 2. 之後就可以直接對話
"幫我分析這個 repo 的所有 open issues"
```

**Claude Code 會自動**：
- 知道你配置了 GitHub MCP
- 主動調用 GitHub API 獲取 issues
- 分析資料並給出回應
- 你不需要寫任何程式碼！

---

### 1.2 MCP 的核心理念：從「呼叫」到「掛載」

#### Linux mount 類比

**理解 MCP 最好的方式是類比 Linux 的 `mount` 指令**：

```bash
# Linux mount：將外部檔案系統掛載到本地
mount /dev/sdb1 /mnt/external

# 之後，/mnt/external 就像本地目錄一樣可以存取
cd /mnt/external
ls
cat file.txt
```

**MCP 做的是同樣的事**：
```json
// MCP config：將外部系統「掛載」到 Claude Code
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "your_token_here"
      }
    }
  }
}
```

**掛載後，Claude Code 可以像存取本地檔案一樣存取 GitHub**：
- "讀取這個 repo 的 README"
- "列出所有 open issues"
- "創建一個新的 PR"
- "查看最近的 commits"

**關鍵差異**：
| 傳統 API | MCP |
|---------|-----|
| 你寫程式碼調用 | AI 主動調用 |
| 靜態整合 | 動態整合 |
| 人工搬運資料 | AI 自主獲取 |
| 單次互動 | 多輪互動 |

---

### 1.3 MCP 的三層架構

```
┌─────────────────────────────────────────────────┐
│           Claude Code（Client）                  │
│                                                  │
│  "幫我分析 GitHub issues"                        │
└────────────────┬────────────────────────────────┘
                 │
                 │ MCP Protocol（通用協議層）
                 │
┌────────────────▼────────────────────────────────┐
│         MCP Server（伺服器層）                    │
│                                                  │
│  - 接收 Claude 的請求                            │
│  - 轉換為 API 調用                               │
│  - 返回結構化資料                                │
└────────────────┬────────────────────────────────┘
                 │
                 │ API Calls（具體 API 層）
                 │
┌────────────────▼────────────────────────────────┐
│        External Service（外部服務）              │
│                                                  │
│  GitHub / Slack / Database / Notion / ...       │
└─────────────────────────────────────────────────┘
```

#### 層次說明

**Layer 1：Protocol Layer（協議層）**
- 定義 Claude Code 與 MCP Server 的通訊格式
- 標準化的請求/回應結構
- 支援 stdio、HTTP 等傳輸方式

**Layer 2：MCP Server Layer（伺服器層）**
- 實現具體的業務邏輯
- 轉換 MCP 請求為 API 調用
- 處理認證、錯誤、重試等

**Layer 3：External Service Layer（外部服務層）**
- 真實的 API 端點
- 各自的認證機制
- 各自的資料格式

**為什麼要三層**？
- **解耦**：Claude Code 不需要知道 GitHub API 的細節
- **標準化**：所有外部系統都用同樣的方式整合
- **可擴展**：新增一個 MCP Server，就能整合新系統

---

## 第二部分：MCP vs REST API - 五個核心差異

### 2.1 差異 1：主動 vs 被動

#### REST API：被動等待

```python
# 傳統方式：你必須主動調用
def get_github_issues():
    response = requests.get(API_URL)
    return response.json()

# 每次需要資料，都要呼叫這個函數
issues = get_github_issues()
```

**問題**：AI 無法主動獲取它需要的資料。

#### MCP：主動探索

```
User: "幫我分析最近的 issues"

Claude（內心）：
1. 我需要 issues 資料
2. 檢查可用的 MCP servers
3. 發現有 GitHub MCP
4. 調用 GitHub MCP 獲取 issues
5. 分析並回應用戶

User: "那這些 issues 對應的 commits 呢？"

Claude（內心）：
1. 我需要 commits 資料
2. 再次調用 GitHub MCP
3. 獲取對應的 commits
4. 繼續分析
```

**關鍵**：Claude 可以在對話過程中，**動態決定需要什麼資料**。

---

### 2.2 差異 2：單次 vs 多輪

#### REST API：單次互動

```python
# 調用一次，得到結果
response = api.call()
# 結束
```

**問題**：如果第一次調用的資料不夠，你需要再寫程式碼調用。

#### MCP：多輪互動

```
Round 1:
Claude: 調用 GitHub MCP 獲取 issues
Result: 發現有 50 個 open issues

Round 2:
Claude: 發現 issue #123 很重要，調用 GitHub MCP 獲取詳細資訊
Result: 獲取 issue #123 的完整內容和評論

Round 3:
Claude: 發現需要查看相關的 PR，調用 GitHub MCP 獲取 linked PRs
Result: 獲取相關 PRs

Final:
Claude: 整合所有資訊，給出完整分析
```

**關鍵**：Claude 可以**像人類一樣**，一步步探索資料。

---

### 2.3 差異 3：靜態 vs 動態

#### REST API：靜態整合

```python
# 你在程式碼裡寫死了要調用哪些 API
issues = get_issues()
commits = get_commits()
prs = get_prs()
```

**問題**：AI 只能使用你預先定義好的功能。

#### MCP：動態整合

```
Claude 可用的 GitHub MCP 功能：
- list_repositories
- get_repository
- list_issues
- get_issue
- create_issue
- list_pull_requests
- get_pull_request
- list_commits
- get_commit
- search_code
- ... (30+ 功能)

Claude 會根據需要，動態選擇調用哪些功能
```

**關鍵**：Claude **自主決定**需要調用哪些功能。

---

### 2.4 差異 4：單一 vs 組合

#### REST API：單一調用

```python
# 每次只能調用一個 API
data1 = api1.call()
# 處理 data1
data2 = api2.call()
# 處理 data2
```

**問題**：整合多個 API 需要大量的膠水程式碼。

#### MCP：無縫組合

```
User: "幫我生成週報：從 GitHub 抓 issues，從 Database 抓數據，
      然後發到 Slack，最後存到 Notion"

Claude（內心）：
1. 調用 GitHub MCP 獲取 issues
2. 調用 Database MCP 查詢數據
3. 整合資料生成週報
4. 調用 Slack MCP 發送訊息
5. 調用 Notion MCP 儲存記錄

User: "完成了！"
```

**關鍵**：Claude 可以**編排多個 MCP**，完成複雜任務。

---

### 2.5 差異 5：開發者中心 vs AI 中心

#### REST API：開發者中心

```
設計思維：
- 開發者會呼叫這個 API
- 提供詳細的參數說明
- 返回固定格式的資料
- 開發者負責解析和處理
```

**適合場景**：開發者寫程式碼

#### MCP：AI 中心

```
設計思維：
- AI 會呼叫這個 MCP
- 提供語義化的功能描述
- 返回 AI 容易理解的資料
- AI 負責決策和處理
```

**適合場景**：AI 自主工作

---

### 2.6 對比總結表

| 特性 | REST API | MCP |
|-----|---------|-----|
| **調用方式** | 開發者主動呼叫 | AI 主動探索 |
| **互動模式** | 單次請求-回應 | 多輪對話式 |
| **整合方式** | 靜態預定義 | 動態自適應 |
| **功能組合** | 需要膠水程式碼 | 原生支援編排 |
| **設計中心** | 開發者 | AI |
| **學習曲線** | 需要讀 API 文檔 | AI 自動理解 |
| **錯誤處理** | 手動處理 | AI 輔助診斷 |
| **最適場景** | 傳統應用開發 | AI 輔助工作流程 |

---

## 第三部分：MCP 配置完全指南

### 3.1 配置檔案結構：.claude/mcp-config.json

#### 基本結構

```json
{
  "mcpServers": {
    "server-name": {
      "command": "執行指令",
      "args": ["參數1", "參數2"],
      "env": {
        "環境變數名": "環境變數值"
      }
    }
  }
}
```

#### 完整範例：GitHub MCP

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    }
  }
}
```

**欄位說明**：

| 欄位 | 說明 | 必填 |
|-----|------|------|
| `mcpServers` | MCP servers 的容器 | ✅ |
| `server-name` | 自訂的 server 名稱（用於識別） | ✅ |
| `command` | 啟動 MCP server 的指令 | ✅ |
| `args` | 指令的參數（陣列） | ⚠️ |
| `env` | 環境變數（通常用於 API keys） | ⚠️ |

---

### 3.2 配置步驟：以 GitHub MCP 為例

#### Step 1：取得 GitHub Personal Access Token

**為什麼需要 Token**？
- MCP Server 需要代表你調用 GitHub API
- Token 就是你的「授權證明」

**如何取得**：
1. 登入 GitHub
2. 前往 Settings → Developer settings → Personal access tokens → Tokens (classic)
3. 點擊 "Generate new token"
4. 選擇權限（Scopes）：
   - `repo`：存取私人 repos
   - `read:user`：讀取用戶資訊
   - `read:org`：讀取組織資訊（如果需要）
5. 複製 token（只會顯示一次！）

**安全提醒**：
- ⚠️ **絕不**把 token 上傳到 GitHub
- ⚠️ **絕不**把 token 寫在程式碼裡
- ✅ 存放在 `.claude/mcp-config.json`（已被 `.gitignore` 忽略）
- ✅ 定期輪換 token（建議 90 天）

#### Step 2：建立或編輯 mcp-config.json

**檔案位置**：`.claude/mcp-config.json`（專案根目錄）

```bash
# 如果檔案不存在，建立它
mkdir -p .claude
touch .claude/mcp-config.json
```

**寫入配置**：
```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "env": {
        "GITHUB_TOKEN": "ghp_YOUR_TOKEN_HERE"
      }
    }
  }
}
```

**重要**：
- `"command": "npx"`：使用 npx 執行 npm 套件
- `"-y"`：自動確認（不需要手動輸入 y）
- `"@modelcontextprotocol/server-github"`：官方 GitHub MCP server

#### Step 3：重新啟動 Claude Code

**為什麼需要重啟**？
- Claude Code 會在啟動時讀取 `mcp-config.json`
- 修改配置後，需要重啟才會生效

**如何重啟**：
- CLI：重新執行 `claude` 指令
- IDE Extension：重新載入 VSCode

#### Step 4：驗證配置

**測試指令**：
```
"幫我列出我的 GitHub repositories"
```

**預期結果**：
- Claude 會調用 GitHub MCP
- 返回你的 repos 列表

**如果失敗**：
- 檢查 token 是否正確
- 檢查 JSON 格式是否正確（注意逗號、引號）
- 檢查網路連線
- 查看錯誤訊息（通常會提示問題所在）

---

### 3.3 常用 MCP Servers 配置範例

#### 3.3.1 Database MCP（PostgreSQL）

```json
{
  "mcpServers": {
    "postgres": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-postgres"
      ],
      "env": {
        "POSTGRES_CONNECTION_STRING": "postgresql://user:password@localhost:5432/dbname"
      }
    }
  }
}
```

**權限建議**：
- 只給 `SELECT` 權限（查詢）
- 如果需要寫入，額外給 `INSERT`、`UPDATE`
- **絕不**給 `DROP`、`DELETE` 權限（除非必要）

#### 3.3.2 Slack MCP

```json
{
  "mcpServers": {
    "slack": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-slack"
      ],
      "env": {
        "SLACK_BOT_TOKEN": "xoxb-your-bot-token",
        "SLACK_TEAM_ID": "T01234567"
      }
    }
  }
}
```

**取得 Slack Token**：
1. 前往 https://api.slack.com/apps
2. 創建 App
3. 安裝 App 到 Workspace
4. 複製 Bot User OAuth Token

#### 3.3.3 Notion MCP

```json
{
  "mcpServers": {
    "notion": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-notion"
      ],
      "env": {
        "NOTION_API_KEY": "secret_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    }
  }
}
```

**取得 Notion API Key**：
1. 前往 https://www.notion.so/my-integrations
2. 創建 Integration
3. 授權給需要存取的 Pages
4. 複製 Internal Integration Token

#### 3.3.4 File System MCP

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/path/to/allowed/directory"
      ]
    }
  }
}
```

**安全提醒**：
- 只允許存取特定目錄
- **絕不**允許存取整個檔案系統（`/`）
- 考慮使用唯讀模式

---

### 3.4 多 MCP 配置：完整範例

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "POSTGRES_CONNECTION_STRING": "postgresql://readonly:password@localhost:5432/analytics"
      }
    },
    "slack": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-slack"],
      "env": {
        "SLACK_BOT_TOKEN": "xoxb-your-bot-token",
        "SLACK_TEAM_ID": "T01234567"
      }
    },
    "notion": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-notion"],
      "env": {
        "NOTION_API_KEY": "secret_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/home/user/projects"
      ]
    }
  }
}
```

**關鍵點**：
- 每個 MCP 都有獨立的名稱
- 每個 MCP 都有獨立的配置
- Claude 可以同時使用所有已配置的 MCP

---

## 第四部分：MCP 安全與治理

### 4.1 API Keys 管理最佳實踐

#### 原則 1：絕不硬編碼

**錯誤示範** ❌：
```python
# 千萬不要這樣做！
GITHUB_TOKEN = "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
```

**正確做法** ✅：
```json
// .claude/mcp-config.json
{
  "mcpServers": {
    "github": {
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    }
  }
}
```

**更安全的做法** ⭐：
```bash
# 使用環境變數
export GITHUB_TOKEN="ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
```

```json
// .claude/mcp-config.json
{
  "mcpServers": {
    "github": {
      "env": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}"
      }
    }
  }
}
```

#### 原則 2：權限最小化

**為什麼重要**？
- 如果 token 洩漏，損失最小化
- 限制 AI 的操作範圍

**GitHub Token 權限範例**：

| 場景 | 最小權限 | 說明 |
|-----|---------|------|
| 只讀取 repos | `repo:status`, `public_repo` | 不能修改任何東西 |
| 讀取 + 創建 issues | `repo`, `write:issues` | 可以創建 issues |
| 讀取 + 創建 PRs | `repo`, `write:pull_requests` | 可以創建 PRs |
| 完全控制 | `repo` | ⚠️ 謹慎使用 |

**Database 權限範例**：

| 場景 | 最小權限 | SQL |
|-----|---------|-----|
| 只查詢 | `SELECT` | `GRANT SELECT ON database.* TO 'user'@'host';` |
| 查詢 + 插入 | `SELECT`, `INSERT` | `GRANT SELECT, INSERT ON database.* TO 'user'@'host';` |
| ⚠️ 危險 | `ALL PRIVILEGES` | **絕不使用** |

#### 原則 3：定期輪換

**建議輪換週期**：
- 生產環境：**30-60 天**
- 開發環境：**90 天**
- 個人專案：**180 天**

**輪換流程**：
1. 生成新的 token
2. 更新 `mcp-config.json`
3. 測試新 token 是否正常
4. 撤銷舊 token

#### 原則 4：絕不上傳到 Git

**必須加入 .gitignore**：
```bash
# .gitignore
.claude/mcp-config.json
*.env
secrets/
```

**如果不小心上傳了**：
1. **立即撤銷 token**
2. 生成新的 token
3. 從 Git 歷史中移除（使用 `git filter-branch`）
4. Force push（如果是私人 repo）

---

### 4.2 MCP 權限管理

#### 場景 1：團隊協作

**問題**：多人共用同一個 MCP 配置，如何管理權限？

**解決方案 A**：每人使用自己的 token
```json
// 提供範本檔案：mcp-config.template.json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "YOUR_TOKEN_HERE"
      }
    }
  }
}
```

**團隊流程**：
1. 將 `mcp-config.template.json` 加入 Git
2. 每人複製為 `.claude/mcp-config.json`
3. 填入自己的 token
4. `.claude/mcp-config.json` 在 `.gitignore` 中

**解決方案 B**：使用統一的服務帳號
```
好處：
- 集中管理
- 統一審計

壞處：
- 無法區分誰做了什麼
- Token 洩漏影響全隊
```

#### 場景 2：不同環境的配置

**問題**：開發、測試、生產環境需要不同的 MCP 配置。

**解決方案**：環境變數 + 配置範本

```bash
# .env.development
GITHUB_TOKEN="ghp_dev_token"
DATABASE_URL="postgresql://localhost:5432/dev_db"

# .env.production
GITHUB_TOKEN="ghp_prod_token"
DATABASE_URL="postgresql://prod-db:5432/prod_db"
```

```json
// .claude/mcp-config.json
{
  "mcpServers": {
    "github": {
      "env": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "database": {
      "env": {
        "POSTGRES_CONNECTION_STRING": "${DATABASE_URL}"
      }
    }
  }
}
```

**切換環境**：
```bash
# 開發環境
source .env.development
claude

# 生產環境
source .env.production
claude
```

---

### 4.3 MCP 安全檢查清單

**配置前檢查**：
- [ ] Token 有設定過期時間嗎？
- [ ] 權限是最小化的嗎？
- [ ] `.gitignore` 有包含配置檔嗎？
- [ ] 有定期輪換計畫嗎？

**配置中檢查**：
- [ ] JSON 格式正確嗎？
- [ ] 環境變數有正確設定嗎？
- [ ] 敏感資訊有遮罩嗎（log 中）？

**配置後檢查**：
- [ ] 測試連線成功嗎？
- [ ] Token 有正確的權限嗎？
- [ ] 錯誤日誌有記錄嗎？
- [ ] 團隊知道如何使用嗎？

---

### 4.4 審計與監控

#### 日誌記錄

**應該記錄什麼**：
- ✅ MCP 調用的時間
- ✅ 調用的 MCP 名稱
- ✅ 調用的功能（如 `list_issues`）
- ✅ 成功或失敗
- ❌ **不要記錄**：API keys、敏感資料

**範例日誌**：
```
[2025-10-30 10:15:23] MCP Call: github.list_repositories - Success
[2025-10-30 10:15:45] MCP Call: database.query - Success
[2025-10-30 10:16:02] MCP Call: slack.send_message - Failed (Token expired)
```

#### 異常檢測

**監控指標**：
- 調用頻率（是否有異常大量調用）
- 失敗率（是否有權限問題）
- 調用模式（是否有異常行為）

**警報觸發條件**：
- 1 分鐘內調用超過 100 次
- 失敗率超過 50%
- 調用了從未使用過的功能

---

## 第五部分：常見 MCP Servers 介紹

### 5.1 GitHub MCP

**功能**：
- 列出 repositories
- 讀取 issues、PRs、commits
- 創建 issues、PRs
- 搜尋程式碼
- 管理 branches

**適用場景**：
- 自動化 issue 管理
- PR 分析與審查
- 程式碼搜尋與分析
- Release 管理

**配置範例**：
```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    }
  }
}
```

**使用範例**：
```
User: "列出我的所有 repos"
Claude: 調用 github.list_repositories

User: "這個 repo 有哪些 open issues？"
Claude: 調用 github.list_issues，過濾 state=open

User: "幫我創建一個 issue：修復登入 bug"
Claude: 調用 github.create_issue，title="修復登入 bug"
```

---

### 5.2 Database MCP（PostgreSQL/MySQL）

**功能**：
- 執行 SELECT 查詢
- 查看 table schema
- 分析查詢結果
- 生成報表

**適用場景**：
- 資料分析
- 報表生成
- 資料驗證
- 效能分析

**配置範例（PostgreSQL）**：
```json
{
  "mcpServers": {
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "POSTGRES_CONNECTION_STRING": "postgresql://user:password@localhost:5432/dbname"
      }
    }
  }
}
```

**安全建議**：
- 創建唯讀帳號
- 只授予 SELECT 權限
- 限制可存取的 tables

**使用範例**：
```
User: "查詢最近 7 天的用戶註冊數"
Claude:
  SELECT DATE(created_at), COUNT(*)
  FROM users
  WHERE created_at >= NOW() - INTERVAL '7 days'
  GROUP BY DATE(created_at)

User: "哪些用戶最活躍？"
Claude:
  SELECT user_id, COUNT(*) as action_count
  FROM user_actions
  WHERE action_date >= NOW() - INTERVAL '30 days'
  GROUP BY user_id
  ORDER BY action_count DESC
  LIMIT 10
```

---

### 5.3 Slack MCP

**功能**：
- 發送訊息到 channel
- 讀取 channel 歷史訊息
- 上傳檔案
- 管理 threads

**適用場景**：
- 自動化通知
- 報表分發
- 警報發送
- 團隊協作

**配置範例**：
```json
{
  "mcpServers": {
    "slack": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-slack"],
      "env": {
        "SLACK_BOT_TOKEN": "xoxb-your-bot-token",
        "SLACK_TEAM_ID": "T01234567"
      }
    }
  }
}
```

**權限需求**：
- `chat:write`：發送訊息
- `channels:read`：讀取 public channels
- `files:write`：上傳檔案

**使用範例**：
```
User: "發送週報到 #engineering channel"
Claude:
  1. 整理週報內容
  2. 調用 slack.send_message
  3. channel="#engineering"
  4. 訊息已發送！

User: "上傳分析報告 PDF"
Claude:
  1. 生成 PDF
  2. 調用 slack.upload_file
  3. 檔案已上傳到 #reports
```

---

### 5.4 Notion MCP

**功能**：
- 讀取 pages 和 databases
- 創建新的 pages
- 更新 page 內容
- 查詢 database

**適用場景**：
- 知識管理
- 會議記錄自動化
- 文檔生成
- 任務管理

**配置範例**：
```json
{
  "mcpServers": {
    "notion": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-notion"],
      "env": {
        "NOTION_API_KEY": "secret_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    }
  }
}
```

**授權設定**：
1. 創建 Integration
2. 授權給需要存取的 Pages
3. 複製 Internal Integration Token

**使用範例**：
```
User: "創建本週會議記錄"
Claude:
  1. 調用 notion.create_page
  2. parent=會議記錄 database
  3. 填入模板內容
  4. 記錄已創建：https://notion.so/...

User: "查詢本月的任務清單"
Claude:
  1. 調用 notion.query_database
  2. database=任務清單
  3. filter: 建立時間 >= 本月初
  4. 返回任務列表
```

---

### 5.5 File System MCP

**功能**：
- 讀取本地檔案
- 寫入檔案
- 列出目錄
- 搜尋檔案

**適用場景**：
- 本地檔案分析
- 批次處理
- 配置管理
- 日誌分析

**配置範例**：
```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/home/user/projects",
        "/home/user/documents"
      ]
    }
  }
}
```

**安全建議**：
- 只允許特定目錄
- 考慮唯讀模式
- 排除敏感檔案（如 `.env`）

**使用範例**：
```
User: "分析專案中的所有 Python 檔案"
Claude:
  1. 調用 filesystem.list_directory
  2. 遞迴找到所有 .py 檔案
  3. 讀取每個檔案
  4. 分析程式碼結構

User: "生成一個 README.md"
Claude:
  1. 分析專案結構
  2. 生成 README 內容
  3. 調用 filesystem.write_file
  4. README.md 已創建！
```

---

## 第六部分：自訂 MCP Server 開發入門

### 6.1 為什麼要自訂 MCP Server？

**場景**：
- 公司內部 API（沒有現成的 MCP）
- 特殊的資料來源（如 IoT 設備）
- 自訂的業務邏輯
- 第三方服務整合

**開發成本**：
- 簡單的 MCP：2-4 小時
- 中等複雜度：1-2 天
- 複雜的 MCP：3-5 天

---

### 6.2 MCP Server 架構

```
┌─────────────────────────────────────────┐
│        MCP Server（你要開發的）           │
│                                          │
│  ┌──────────────────────────────────┐  │
│  │  1. Protocol Handler              │  │
│  │     - 接收 Claude 的請求          │  │
│  │     - 解析請求參數                │  │
│  └──────────────────────────────────┘  │
│                                          │
│  ┌──────────────────────────────────┐  │
│  │  2. Business Logic                │  │
│  │     - 調用外部 API                │  │
│  │     - 資料處理                    │  │
│  │     - 錯誤處理                    │  │
│  └──────────────────────────────────┘  │
│                                          │
│  ┌──────────────────────────────────┐  │
│  │  3. Response Formatter            │  │
│  │     - 格式化回應                  │  │
│  │     - 返回給 Claude               │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

---

### 6.3 開發流程：Weather API MCP 範例

**需求**：創建一個 MCP Server，讓 Claude 可以查詢天氣資訊。

#### Step 1：定義功能

```
功能列表：
- get_weather(city)：查詢城市天氣
- get_forecast(city, days)：查詢未來幾天天氣
- get_alerts(city)：查詢天氣警報
```

#### Step 2：選擇技術棧

**推薦**：
- **Python**：簡單、快速、豐富的 API 客戶端
- **Node.js**：與 Claude Code 生態系統一致

**範例使用 Python**：
```python
# weather_mcp_server.py
from mcp.server import MCPServer
import requests

class WeatherMCPServer(MCPServer):
    def __init__(self):
        super().__init__("weather")
        self.api_key = os.getenv("WEATHER_API_KEY")

    def get_weather(self, city: str) -> dict:
        """Get current weather for a city"""
        url = f"https://api.weatherapi.com/v1/current.json"
        params = {
            "key": self.api_key,
            "q": city
        }
        response = requests.get(url, params=params)
        return response.json()

    def get_forecast(self, city: str, days: int = 3) -> dict:
        """Get weather forecast"""
        url = f"https://api.weatherapi.com/v1/forecast.json"
        params = {
            "key": self.api_key,
            "q": city,
            "days": days
        }
        response = requests.get(url, params=params)
        return response.json()

if __name__ == "__main__":
    server = WeatherMCPServer()
    server.run()
```

#### Step 3：配置 MCP

```json
{
  "mcpServers": {
    "weather": {
      "command": "python",
      "args": ["/path/to/weather_mcp_server.py"],
      "env": {
        "WEATHER_API_KEY": "your_api_key_here"
      }
    }
  }
}
```

#### Step 4：測試

```
User: "台北現在天氣如何？"
Claude:
  調用 weather.get_weather("Taipei")
  結果：晴天，溫度 25°C，濕度 60%

User: "未來三天的天氣預報？"
Claude:
  調用 weather.get_forecast("Taipei", 3)
  返回未來三天的預報
```

---

## 第七部分：MCP 故障排除

### 7.1 常見問題與解決方案

#### 問題 1：MCP 連線失敗

**症狀**：
```
Error: Unable to connect to MCP server 'github'
```

**可能原因**：
1. MCP server 未安裝
2. 配置檔格式錯誤
3. 環境變數未設定
4. 網路連線問題

**診斷步驟**：
```bash
# 1. 檢查 MCP server 是否可執行
npx -y @modelcontextprotocol/server-github

# 2. 檢查配置檔格式
cat .claude/mcp-config.json | jq .

# 3. 檢查環境變數
echo $GITHUB_TOKEN

# 4. 測試網路連線
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user
```

#### 問題 2：授權失敗

**症狀**：
```
Error: 401 Unauthorized
```

**可能原因**：
1. Token 無效或過期
2. Token 權限不足
3. Token 格式錯誤

**解決方案**：
```bash
# 1. 驗證 token
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user

# 2. 檢查 token 權限
# 前往 GitHub Settings → Developer settings → Personal access tokens
# 確認 token 有所需的 scopes

# 3. 重新生成 token
# 生成新 token 並更新配置
```

#### 問題 3：功能調用失敗

**症狀**：
```
Error: Function 'list_issues' not found
```

**可能原因**：
1. MCP server 版本過舊
2. 功能名稱錯誤
3. MCP server 未正確啟動

**解決方案**：
```bash
# 1. 更新 MCP server
npm update @modelcontextprotocol/server-github

# 2. 查看可用功能
# 閱讀 MCP server 文檔

# 3. 重啟 Claude Code
```

---

### 7.2 除錯技巧

#### 技巧 1：啟用詳細日誌

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        "DEBUG": "true"
      }
    }
  }
}
```

#### 技巧 2：使用 Postman 測試 API

```bash
# 在配置 MCP 前，先用 Postman 測試 API 是否可用
curl -H "Authorization: token YOUR_TOKEN" \
  https://api.github.com/user/repos
```

#### 技巧 3：簡化配置測試

```json
// 先配置一個 MCP，確保能用
{
  "mcpServers": {
    "github": {
      // 配置
    }
  }
}

// 測試通過後，再加第二個
{
  "mcpServers": {
    "github": { /* ... */ },
    "database": { /* ... */ }
  }
}
```

---

## 本節總結

### 核心概念回顧

**MCP 的本質**：
- 不是普通的 API，而是 AI 與外部世界的通用語言
- 像 Linux 的 `mount`，將外部系統掛載到 Claude Code
- 讓 AI 可以主動、動態、多輪地探索資料

**MCP vs REST API**：
| 特性 | REST API | MCP |
|-----|---------|-----|
| 調用方式 | 被動等待 | 主動探索 |
| 互動模式 | 單次 | 多輪 |
| 整合方式 | 靜態 | 動態 |
| 功能組合 | 需膠水程式碼 | 原生編排 |

**安全原則**：
1. 絕不硬編碼 API keys
2. 權限最小化
3. 定期輪換 token
4. 絕不上傳到 Git

**常用 MCP Servers**：
- GitHub：repo 管理、issue/PR 處理
- Database：資料查詢與分析
- Slack：自動化通知
- Notion：知識管理
- File System：本地檔案處理

---

### 實踐檢查點

完成以下檢查點，確保你已掌握 MCP：

**基礎級**：
- [ ] 理解 MCP 的三層架構
- [ ] 能說明 MCP 與 REST API 的五個差異
- [ ] 成功配置一個 GitHub MCP
- [ ] 理解 API keys 管理的四個原則

**中級**：
- [ ] 配置 3+ 個 MCP servers
- [ ] 理解如何診斷 MCP 連線問題
- [ ] 能設計合適的 token 權限
- [ ] 知道如何處理多環境配置

**進階**：
- [ ] 開發一個簡單的自訂 MCP server
- [ ] 設計企業級的 MCP 安全策略
- [ ] 能審計 MCP 使用日誌
- [ ] 為團隊建立 MCP 最佳實踐指南

---

### 下一步

**立即實踐**：
1. 完成 `情境題庫/基礎級/B01_配置GitHub_MCP.md`
2. 配置你的第一個 MCP server
3. 體驗 AI 主動調用外部系統的威力

**深入學習**：
1. 閱讀 `6.2_多代理人編排實戰.md`
2. 學習如何編排多個 MCP 協同工作
3. 挑戰自動化週報系統實作

**記住**：
> MCP 不是技術細節，而是思維方式的轉變。
> 從「我要寫程式碼調用 API」變成「我要讓 AI 自主工作」。

讓我們繼續前進，學習如何編排多個 Agent 與 MCP 協同工作！🚀
