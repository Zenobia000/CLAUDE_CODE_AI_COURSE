# 工作流程編排模式庫 - 四種模式的實戰應用指南

## 📋 使用說明

這不是編排命令手冊，而是**模式應用指南**。

**解決的問題**：
- 如何選擇合適的編排模式？
- 如何組合多種模式？
- 常見模式有哪些陷阱？
- 如何優化工作流程效率？

**內容結構**：
- 四種基礎模式詳解
- 每種模式的 3+ 實戰案例
- 模式組合策略
- 常見陷阱與解法

---

## 四種基礎編排模式

```
1. 串行（Sequential）  → 任務有依賴順序
2. 並行（Parallel）    → 任務互相獨立
3. 條件分支（Conditional）→ 根據結果決定下一步
4. 循環（Loop）        → 重複執行直到條件滿足
```

---

## 模式 1：串行編排（Sequential）

### 定義

任務按固定順序執行，後面的任務依賴前面的結果。

```
Task A → Task B → Task C → Task D
```

### 適用場景

✅ **何時使用**：
- 任務之間有明確依賴關係
- 後續任務需要前面任務的輸出
- 必須按順序執行的流程

❌ **不適合**：
- 任務之間沒有依賴（應該用並行）
- 某些步驟可以跳過（應該用條件分支）

### 實戰案例 1：部署流程

```
情境：自動化部署流程

階段 1：建置
User: "從 GitHub 獲取最新程式碼"
    ↓
Claude: 拉取 main 分支最新 commit

階段 2：測試（依賴階段 1）
User: "執行完整測試套件"
    ↓
Claude: 執行測試（使用階段 1 的程式碼）

階段 3：打包（依賴階段 2）
If 測試通過:
    User: "建置 Docker image"
        ↓
    Claude: 建置並標記版本

階段 4：部署（依賴階段 3）
User: "部署到 Staging 環境"
    ↓
Claude: 使用階段 3 的 image 部署

階段 5：驗證（依賴階段 4）
User: "驗證部署是否成功"
    ↓
Claude: 健康檢查
```

**關鍵點**：
- 每個階段依賴上一階段
- 任何階段失敗，整個流程中止
- 必須嚴格按順序執行

---

### 實戰案例 2：資料處理管道

```
情境：處理用戶上傳的 CSV 資料

步驟 1：驗證格式
User: "檢查 CSV 格式是否正確"
    ↓
Claude: 檢查欄位、資料類型

步驟 2：清理資料（依賴步驟 1）
User: "清理資料：移除重複、處理空值"
    ↓
Claude: 資料清理（使用步驟 1 驗證過的資料）

步驟 3：轉換資料（依賴步驟 2）
User: "將資料轉換為標準格式"
    ↓
Claude: 資料轉換（使用步驟 2 清理過的資料）

步驟 4：載入資料庫（依賴步驟 3）
User: "將資料載入 PostgreSQL"
    ↓
Claude: 批次插入（使用步驟 3 轉換過的資料）

步驟 5：生成報告（依賴步驟 4）
User: "生成資料匯入報告"
    ↓
Claude: 統計數據 + Notion 歸檔
```

**為什麼是串行？**
- 不能在驗證前清理（不知道格式）
- 不能在清理前轉換（可能有髒資料）
- 不能在轉換前載入（格式不對）

---

### 實戰案例 3：週報生成（資料獲取階段）

```
情境：生成團隊週報的資料獲取部分

步驟 1：確定時間範圍
User: "計算本週的起始和結束日期"
    ↓
Claude: start_date, end_date

步驟 2：獲取 GitHub 資料（依賴步驟 1）
User: "獲取本週的 commits 和 PRs"
    ↓
Claude: 使用 start_date, end_date 查詢

步驟 3：獲取 Database 資料（依賴步驟 1）
User: "查詢本週的 API 使用統計"
    ↓
Claude: 使用 start_date, end_date 查詢

步驟 4：彙整資料（依賴步驟 2, 3）
User: "合併所有資料源"
    ↓
Claude: 整合 GitHub + Database 資料

步驟 5：生成週報（依賴步驟 4）
User: "生成週報並發布到 Notion"
    ↓
Claude: 格式化 + 發布
```

**注意**：
- 步驟 2 和 3 雖然都依賴步驟 1，但彼此獨立
- 這裡可以優化：步驟 2 和 3 可以**並行執行**
- 這就是**模式組合**的應用（見後文）

---

### 串行模式的陷阱

#### 陷阱 1：不必要的串行

```
❌ 錯誤：所有任務都串行

步驟 1：從 GitHub 獲取 issues
步驟 2：從 Database 查詢數據
步驟 3：從 Slack 讀取訊息
步驟 4：彙整資料

問題：步驟 1, 2, 3 互相獨立，應該並行
```

```
✅ 正確：識別獨立任務

並行執行：
├─ 從 GitHub 獲取 issues
├─ 從 Database 查詢數據
└─ 從 Slack 讀取訊息
    ↓
串行執行：
彙整資料（依賴上面三個）
```

#### 陷阱 2：錯誤不會中斷流程

```
❌ 錯誤：忽略錯誤繼續執行

步驟 1：測試失敗 ❌
步驟 2：仍然繼續建置
步驟 3：仍然繼續部署

問題：測試失敗應該中止流程
```

```
✅ 正確：明確錯誤處理

User: "執行測試。
      如果失敗，立即中止流程，
      不要繼續建置和部署。"
```

---

## 模式 2：並行編排（Parallel）

### 定義

多個任務同時執行，彼此獨立，互不依賴。

```
      ┌─ Task A ─┐
Start ├─ Task B ─┤ End
      └─ Task C ─┘
```

### 適用場景

✅ **何時使用**：
- 任務之間完全獨立
- 不共享資源或狀態
- 希望縮短總執行時間

❌ **不適合**：
- 任務之間有依賴關係
- 共享有限資源（如 API rate limit）
- 需要按特定順序執行

### 實戰案例 1：週報資料獲取

```
情境：從多個來源獲取週報資料

User: "同時執行以下任務：
1. 從 GitHub 獲取本週 commits 和 PRs
2. 從 Database 查詢 API 使用統計
3. 從 Slack 讀取團隊討論摘要
4. 從 Notion 獲取會議記錄"

並行執行：
┌────────────────────────┐
│ GitHub MCP             │ → commits, PRs
├────────────────────────┤
│ Database MCP           │ → API 統計
├────────────────────────┤
│ Slack MCP              │ → 討論摘要
├────────────────────────┤
│ Notion MCP             │ → 會議記錄
└────────────────────────┘
        ↓ (全部完成)
    彙整資料
```

**時間節省**：
- 串行：4 × 30 秒 = 2 分鐘
- 並行：max(30, 30, 30, 30) = 30 秒
- **節省 75% 時間**

---

### 實戰案例 2：多環境部署

```
情境：同時部署到多個測試環境

User: "並行部署到以下環境：
- Dev 環境 (dev.example.com)
- QA 環境 (qa.example.com)
- UAT 環境 (uat.example.com)

每個環境獨立部署，互不影響"

並行執行：
┌────────────────────────┐
│ 部署到 Dev             │
├────────────────────────┤
│ 部署到 QA              │
├────────────────────────┤
│ 部署到 UAT             │
└────────────────────────┘
        ↓
    生成部署報告
```

**關鍵條件**：
- 各環境獨立，互不干擾
- 不共享資源或鎖定
- 失敗不影響其他環境

---

### 實戰案例 3：多通道通知

```
情境：重要事件需要多通道通知

User: "同時發送通知到：
- Slack #alerts 頻道
- Email 給技術主管
- Notion 事件日誌
- SMS 給值班人員

確保即使某個通道失敗，其他通道仍然執行"

並行執行（各自獨立）：
┌────────────────────────┐
│ Slack 通知             │ → 成功 ✅
├────────────────────────┤
│ Email 通知             │ → 成功 ✅
├────────────────────────┤
│ Notion 記錄            │ → 失敗 ❌（不影響其他）
├────────────────────────┤
│ SMS 發送               │ → 成功 ✅
└────────────────────────┘
        ↓
    彙總通知狀態
```

**錯誤隔離**：
- 單一通道失敗不影響其他通道
- 最終報告所有通道狀態
- 重試失敗的通道（見循環模式）

---

### 並行模式的陷阱

#### 陷阱 1：假並行（實際串行）

```
❌ 錯誤：看起來並行，實際串行

User: "同時執行 Task A 和 Task B"

實際執行：
Task A 開始 → Task A 完成 → Task B 開始 → Task B 完成
（Claude 逐個執行）
```

```
✅ 正確：明確要求並行

User: "請在同一時間並行執行以下兩個任務，
      不要等待一個完成再開始另一個：
      1. Task A
      2. Task B"
```

#### 陷阱 2：共享資源衝突

```
❌ 錯誤：並行操作同一資源

並行執行：
├─ 從資料庫讀取 counter = 100
└─ 從資料庫讀取 counter = 100
    ↓
├─ 增加 1，寫回 101
└─ 增加 1，寫回 101

問題：應該是 102，但結果是 101（丟失更新）
```

```
✅ 正確：識別共享資源

User: "並行執行以下任務（它們操作不同資料表）：
      1. 更新 users 資料表
      2. 更新 orders 資料表"

或使用串行：
User: "依序更新 counter（串行執行）"
```

#### 陷阱 3：並行開銷 > 收益

```
❌ 錯誤：極快任務並行

並行執行 10 個簡單查詢（每個 0.1 秒）
並行開銷：0.5 秒
總時間：0.6 秒

串行執行 10 個查詢
總時間：1.0 秒

收益：僅節省 0.4 秒，但增加複雜度
```

```
✅ 正確：評估收益

並行執行 4 個複雜任務（每個 30 秒）
串行：120 秒
並行：~30 秒

收益：節省 90 秒，值得並行
```

**經驗法則**：
- 單個任務 < 1 秒 → 不值得並行
- 單個任務 > 5 秒 → 值得並行
- 任務數量 < 3 → 考慮成本
- 任務數量 >= 4 → 推薦並行

---

## 模式 3：條件分支（Conditional）

### 定義

根據條件或結果，決定執行哪個分支。

```
      ┌─ 條件 A 成立 → Task A
Start ┼─ 條件 B 成立 → Task B
      └─ 其他         → Task C
```

### 適用場景

✅ **何時使用**：
- 需要根據結果做不同處理
- 不同情況需要不同策略
- 錯誤處理和降級方案

❌ **不適合**：
- 所有分支都要執行（應該用並行）
- 分支邏輯過於複雜（應該簡化）

### 實戰案例 1：智能部署策略

```
情境：根據時間和環境選擇部署策略

User: "根據以下條件選擇部署策略：
- 如果是 main 分支 → 部署到 Production
- 如果是 develop 分支 → 部署到 Staging
- 如果是 feature/* 分支 → 部署到 Dev

並且：
- 如果是工作時間 (9:00-18:00) → 使用 Blue-Green 部署
- 如果是非工作時間 → 使用 Rolling 部署"

執行流程：
檢查分支
├─ main → Production
│   └─ 檢查時間
│       ├─ 工作時間 → Blue-Green 部署
│       └─ 非工作時間 → Rolling 部署
│
├─ develop → Staging
│   └─ Rolling 部署（Staging 不需要 Blue-Green）
│
└─ feature/* → Dev
    └─ 直接部署（Dev 環境無需策略）
```

**關鍵決策點**：
1. 分支判斷 → 決定環境
2. 時間判斷 → 決定策略
3. 環境判斷 → 決定風險級別

---

### 實戰案例 2：錯誤處理與降級

```
情境：API 調用失敗時的降級方案

User: "調用外部 API 獲取匯率，
      如果失敗，使用降級方案：

      1. 嘗試調用主 API
      2. 如果失敗（超時或錯誤），嘗試備用 API
      3. 如果備用 API 也失敗，使用快取資料
      4. 如果沒有快取，使用預設匯率
      5. 記錄所有失敗到日誌"

執行流程：
調用主 API
├─ 成功 ✅ → 返回結果，結束
└─ 失敗 ❌ ↓

調用備用 API
├─ 成功 ✅ → 返回結果，記錄主 API 失敗
└─ 失敗 ❌ ↓

查詢快取
├─ 有快取 ✅ → 返回快取，記錄兩個 API 失敗
└─ 無快取 ❌ ↓

使用預設匯率
└─ 返回預設值，發送警報
```

**降級策略**：
- 每層失敗都有 Plan B
- 逐步降級，確保服務可用
- 記錄失敗原因供後續分析

---

### 實戰案例 3：資料驗證分支

```
情境：處理用戶輸入，根據驗證結果分支

User: "驗證用戶提交的表單：

      1. 檢查必填欄位
         - 缺少 → 返回錯誤，列出缺少的欄位

      2. 檢查資料格式
         - Email 格式錯誤 → 返回格式錯誤
         - 手機號碼格式錯誤 → 返回格式錯誤

      3. 檢查業務規則
         - Email 已存在 → 返回 '已註冊'
         - 年齡 < 18 → 返回 '未滿 18 歲'

      4. 所有檢查通過
         - 寫入資料庫
         - 發送歡迎郵件
         - 返回成功"

執行流程：
檢查必填欄位
├─ 有缺漏 → 返回 {"error": "缺少 email, name"}
└─ 完整 ↓

檢查資料格式
├─ 格式錯誤 → 返回 {"error": "email 格式不正確"}
└─ 格式正確 ↓

檢查業務規則
├─ Email 已存在 → 返回 {"error": "Email 已註冊"}
├─ 年齡 < 18 → 返回 {"error": "需年滿 18 歲"}
└─ 規則通過 ↓

處理註冊
├─ 寫入資料庫
├─ 發送郵件
└─ 返回 {"success": true}
```

**驗證策略**：
- 由簡單到複雜（避免無謂的複雜檢查）
- 快速失敗（第一個錯誤就返回）
- 提供明確的錯誤訊息

---

### 條件分支的陷阱

#### 陷阱 1：巢狀過深

```
❌ 錯誤：5 層巢狀條件

If A:
    If B:
        If C:
            If D:
                If E:
                    Do something

問題：難以理解和維護
```

```
✅ 正確：扁平化條件

# 策略 1：提前返回
If not A: return error
If not B: return error
If not C: return error
Do something

# 策略 2：查表
strategies = {
    ("main", "working_hours"): "blue_green",
    ("main", "off_hours"): "rolling",
    ("develop", "any"): "rolling",
}
strategy = strategies.get((branch, time), "default")
```

#### 陷阱 2：遺漏 else 分支

```
❌ 錯誤：沒有處理所有情況

If status == "success":
    Do A
If status == "failure":
    Do B

問題：如果 status == "pending" 呢？
```

```
✅ 正確：明確處理所有情況

If status == "success":
    Do A
Else if status == "failure":
    Do B
Else if status == "pending":
    Do C
Else:
    Log unknown status and alert
```

---

## 模式 4：循環編排（Loop）

### 定義

重複執行任務，直到達成某個條件。

```
Start → Task → 檢查條件
         ↑         |
         └─ 否 ────┘
              |
             是 ↓
            End
```

### 適用場景

✅ **何時使用**：
- 需要等待某個狀態改變
- 需要重試失敗的操作
- 需要輪詢檢查結果
- 需要處理不定數量的項目

❌ **不適合**：
- 明確知道執行次數（用固定次數迴圈）
- 可能無限循環（必須設定最大次數）

### 實戰案例 1：部署後健康檢查

```
情境：部署後持續檢查服務是否正常

User: "部署完成後，進行健康檢查：

      每 30 秒檢查一次，最多檢查 10 次（5 分鐘）

      檢查項目：
      1. HTTP 健康檢查端點回應 200
      2. 資料庫連線正常
      3. 關鍵 API 可以回應

      如果 3 次連續成功 → 部署成功
      如果任何檢查失敗 → 自動回滾"

執行流程：
Loop (最多 10 次):
    執行健康檢查
    ├─ HTTP 200? Database OK? API OK?
    │
    ├─ 全部成功
    │   └─ success_count += 1
    │       └─ If success_count >= 3:
    │           └─ 部署成功 ✅ (結束循環)
    │
    ├─ 任何失敗
    │   └─ 自動回滾 ❌ (結束循環)
    │
    └─ 等待 30 秒，繼續下一次檢查

If 超過 10 次仍未成功:
    └─ 部署超時，自動回滾
```

**關鍵要素**：
- 最大次數限制（10 次）
- 循環間隔（30 秒）
- 成功條件（3 次連續成功）
- 失敗處理（自動回滾）

---

### 實戰案例 2：重試機制

```
情境：調用不穩定的外部 API，失敗時重試

User: "調用第三方支付 API，如果失敗則重試：

      重試策略：
      - 最多重試 3 次
      - 每次重試間隔 2^n 秒（指數退避）
        - 第 1 次重試：2 秒後
        - 第 2 次重試：4 秒後
        - 第 3 次重試：8 秒後

      失敗類型處理：
      - 網路超時 → 重試
      - 500 錯誤 → 重試
      - 400 錯誤 → 不重試（參數錯誤）
      - 401 錯誤 → 不重試（認證失敗）"

執行流程：
retry_count = 0
Loop (最多 3 次):
    調用支付 API

    If 成功 (200):
        └─ 返回結果 ✅ (結束循環)

    If 4xx 錯誤（400, 401, 403, 404）:
        └─ 不重試，返回錯誤 ❌ (結束循環)

    If 5xx 錯誤或超時:
        └─ retry_count += 1
            └─ If retry_count >= 3:
                └─ 重試次數用盡 ❌ (結束循環)
            └─ Else:
                └─ 等待 2^retry_count 秒
                └─ 繼續循環

If 3 次都失敗:
    └─ 記錄失敗日誌
    └─ 發送警報到 Slack
    └─ 返回失敗
```

**指數退避策略**：
- 避免過度頻繁重試
- 給外部服務恢復時間
- 減少對方伺服器負擔

---

### 實戰案例 3：批次處理

```
情境：處理大量資料，逐批處理避免超時

User: "從資料庫獲取 10,000 筆用戶資料，
      發送郵件通知。

      批次處理策略：
      - 每批 100 筆
      - 每批處理完後等待 5 秒（避免郵件服務過載）
      - 記錄成功和失敗數量
      - 任何批次失敗不影響後續批次"

執行流程：
查詢資料庫：獲取 10,000 筆 user IDs
批次大小 = 100
total_batches = 100

success_count = 0
failure_count = 0

Loop for each batch (100 次):
    獲取當前批次的 100 筆資料

    For each user in batch:
        嘗試發送郵件
        ├─ 成功 → success_count += 1
        └─ 失敗 → failure_count += 1
                  └─ 記錄失敗的 user ID

    If 不是最後一批:
        └─ 等待 5 秒

    進度報告：
    └─ "已處理 {當前批次 × 100} / 10,000 筆"

完成後生成報告：
├─ 成功：{success_count} 筆
├─ 失敗：{failure_count} 筆
└─ 失敗 user IDs：[...]
```

**批次處理要點**：
- 避免一次處理太多（記憶體/超時）
- 批次間暫停（避免過載）
- 錯誤隔離（單筆失敗不影響其他）
- 進度報告（長時間任務需要可見性）

---

### 循環模式的陷阱

#### 陷阱 1：無限循環

```
❌ 錯誤：沒有退出條件

Loop:
    檢查服務狀態
    If 成功:
        繼續循環
    Else:
        繼續循環

問題：永遠不會結束
```

```
✅ 正確：明確退出條件

Loop (最多 10 次):
    檢查服務狀態
    If 成功:
        退出循環 ✅
    Else:
        繼續循環

If 10 次都失敗:
    返回失敗 ❌
```

#### 陷阱 2：沒有間隔的輪詢

```
❌ 錯誤：連續快速輪詢

Loop (最多 100 次):
    檢查狀態
    If not ready:
        立即檢查

問題：
- 100 次檢查在 1 秒內完成
- 浪費資源
- 可能觸發 rate limit
```

```
✅ 正確：合理間隔

Loop (最多 10 次):
    檢查狀態
    If not ready:
        等待 30 秒
        繼續檢查

時間跨度：最多 5 分鐘（10 × 30 秒）
```

#### 陷阱 3：不記錄循環狀態

```
❌ 錯誤：循環無進度提示

Loop 100 次處理資料
（用戶不知道進度，以為卡住了）
```

```
✅ 正確：提供進度回饋

Loop for batch in 100 batches:
    處理 batch

    每 10 批報告一次：
    "已處理 {current} / 100 批次"

最終報告：
"完成：成功 X 筆，失敗 Y 筆"
```

---

## 模式組合策略

### 組合 1：並行 + 串行

**情境**：週報生成系統

```
階段 1：並行資料獲取
┌────────────────────────┐
│ GitHub 資料            │
├────────────────────────┤
│ Database 資料          │ → 並行執行
├────────────────────────┤
│ Slack 資料             │
└────────────────────────┘
        ↓
階段 2：串行資料處理
data-analyst Agent 分析 → 生成圖表 → 撰寫摘要
        ↓
階段 3：並行分發
┌────────────────────────┐
│ 發布到 Notion          │
├────────────────────────┤ → 並行執行
│ 發送到 Slack           │
└────────────────────────┘
```

**為什麼這樣組合？**
- 階段 1：資料源獨立 → 並行加速
- 階段 2：需要完整資料 → 串行處理
- 階段 3：輸出獨立 → 並行加速

---

### 組合 2：條件分支 + 循環

**情境**：智能重試機制

```
Loop (最多 3 次):
    調用 API

    ↓ (條件分支)

    If 成功 (200):
        └─ 返回結果 ✅ (結束循環)

    Else if 客戶端錯誤 (4xx):
        └─ 不重試 ❌ (結束循環)

    Else if 伺服器錯誤 (5xx):
        └─ If retry_count < 3:
            └─ 等待後繼續循環
           Else:
            └─ 重試用盡 ❌ (結束循環)

    Else if 超時:
        └─ If retry_count < 3:
            └─ 增加超時時間，繼續循環
           Else:
            └─ 重試用盡 ❌ (結束循環)
```

**組合原因**：
- 循環：處理不穩定的外部服務
- 條件分支：不同錯誤不同處理策略

---

### 組合 3：串行 + 條件分支 + 循環

**情境**：完整 CI/CD 流程

```
階段 1：建置（串行）
拉取程式碼 → 安裝依賴 → 建置專案

階段 2：測試（串行）
執行測試 → 檢查覆蓋率

    ↓ (條件分支)

    If 測試失敗:
        └─ 通知開發者，中止流程 ❌

    If 測試成功:
        ↓

階段 3：部署（串行 + 條件分支）
    If 分支 == "main":
        └─ 部署到 Production
    Else if 分支 == "develop":
        └─ 部署到 Staging
    Else:
        └─ 跳過部署

階段 4：驗證（循環 + 條件分支）
    Loop (最多 10 次, 每 30 秒):
        健康檢查

        If 成功:
            └─ success_count += 1
                If success_count >= 3:
                    └─ 部署成功 ✅ (結束)

        If 失敗:
            └─ If failure_count >= 2:
                └─ 自動回滾 ❌ (結束)
```

**複雜組合的關鍵**：
- 清晰的階段劃分
- 明確的決策點
- 完善的錯誤處理
- 合理的超時和重試策略

---

## 選擇模式的決策樹

```
開始設計工作流程
    ↓
問題 1：任務之間有依賴嗎？
├─ 有 → 使用串行
└─ 無 ↓

問題 2：任務可以同時執行嗎？
├─ 可以 → 使用並行
└─ 不確定 ↓

問題 3：需要根據結果做不同處理嗎？
├─ 需要 → 使用條件分支
└─ 不需要 ↓

問題 4：需要重複執行直到達成條件嗎？
├─ 需要 → 使用循環
└─ 不需要 → 重新審視需求
```

---

## 效能優化建議

### 1. 能並行就並行

```
優化前（串行）：
Task A (10s) → Task B (10s) → Task C (10s)
總時間：30 秒

優化後（並行）：
Task A, B, C 同時執行
總時間：10 秒
```

### 2. 減少不必要的等待

```
優化前：
每次檢查間隔 60 秒，最多 10 次
最壞情況：10 分鐘

優化後：
動態間隔：5s → 10s → 20s → 40s
最壞情況：75 秒
```

### 3. 提前退出

```
優化前：
處理完所有資料才檢查是否有錯誤

優化後：
第一個錯誤就中止（快速失敗）
```

### 4. 批次處理

```
優化前：
逐筆處理 10,000 筆資料
每筆 API 調用開銷：10ms
總開銷：100 秒

優化後：
批次處理，每批 100 筆
總開銷：10 秒
```

---

## 總結：模式選擇口訣

```
有依賴 → 串行
無依賴 → 並行
看結果 → 條件
要重複 → 循環
組合用 → 看情況
```

**記住原則**：
> 簡單的問題用簡單的模式
> 複雜的問題才組合模式
> 不要為了用模式而用模式
> 效率和可維護性都重要

---

## 下一步

- **基礎練習** → 查看 `情境題庫/基礎級/` 的單模式練習
- **組合練習** → 查看 `情境題庫/組合級/` 的複雜工作流程
- **實戰應用** → 查看 `情境題庫/複雜級/` 的企業級專案
- **故障排除** → 如果工作流程沒有按預期執行，查看 `常見問題解決方案.md`
