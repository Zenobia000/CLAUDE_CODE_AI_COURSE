# 5.1 GitHub Actions 整合：AI 時代的自動化管線

## 📚 本章概述

**學習時長**：45 分鐘

**核心目標**：
- 理解 CI/CD 的核心價值
- 掌握 GitHub Actions 基本架構
- 學會用 AI 生成和優化 workflow
- 建立可運行的自動化測試管線

**Linux 類比**：
> GitHub Actions 就像 cron + systemd + shell script 的組合：
> - **cron**：定時或事件觸發
> - **systemd**：管理服務的生命週期
> - **shell script**：定義具體要執行的任務

---

## 1. CI/CD 基礎：為什麼我們需要自動化？

### 1.1 傳統開發流程的痛點

**場景：沒有 CI/CD 的日常**

```
週五下午 5:30 PM

開發者 A：「我的功能開發完了，準備合併到 main！」
[手動執行測試]
開發者 A：「測試都過了，push！」

週五下午 6:00 PM
[生產環境崩潰]

開發者 B：「誰 push 了？我的功能壞了！」
開發者 C：「資料庫連線失敗！」

調查結果：
- 開發者 A 只在本機測試，環境不同
- 忘記執行整合測試
- 沒有檢查安全漏洞
- 沒有 linting 檢查

週末泡湯，加班修復...
```

**問題總結**：
1. ❌ 依賴人工記憶執行測試
2. ❌ 環境不一致（"在我電腦上可以"）
3. ❌ 沒有標準化流程
4. ❌ 錯誤發現太晚（生產環境才發現）

### 1.2 CI/CD 的解決方案

**CI (Continuous Integration) - 持續整合**：
```
每次程式碼變更時，自動：
1. 執行所有測試
2. 檢查程式碼品質
3. 掃描安全漏洞
4. 建立可部署的產物

→ 快速發現問題，及早修復
```

**CD (Continuous Deployment/Delivery) - 持續部署**：
```
測試通過後，自動：
1. 部署到測試環境
2. 執行整合測試
3. 部署到生產環境（或等待人工批准）

→ 快速交付價值，降低部署風險
```

**有 CI/CD 的流程**：
```
週五下午 5:30 PM

開發者 A：提交 Pull Request
[GitHub Actions 自動執行]
  ✅ 單元測試通過
  ✅ 整合測試通過
  ✅ 程式碼品質檢查通過
  ❌ 安全掃描發現 SQL 注入漏洞

[PR 被自動阻止合併]
通知：「發現安全問題，請修復後再合併」

開發者 A：修復漏洞，重新提交
[所有檢查通過 ✅]

合併 → 自動部署 → 週末安心度過
```

### 1.3 在 AI 時代，CI/CD 更加重要

**核心事實**（來自課程資料）：
- **40%** 的 AI 生成代碼包含安全問題
- **Code Churn 翻倍**：AI 加速開發，但也增加返工
- **信任度悖論**：80% 使用 AI，只有 29% 信任

**CI/CD 是 AI 時代的安全網**：

```
沒有 CI/CD：
AI 生成代碼 → 直接合併 → 40% 機率有問題 → 生產事故

有 CI/CD：
AI 生成代碼 → 自動掃描 → 發現問題 → AI 輔助修復 → 重新驗證 → 安全合併
```

---

## 2. GitHub Actions 核心概念

### 2.1 基本架構：Workflow、Jobs、Steps

**概念結構**：

```yaml
# .github/workflows/test.yml

name: Test Pipeline                    # Workflow 名稱

on: [push, pull_request]              # 觸發條件（Trigger）

jobs:                                  # 工作清單
  test:                               # Job 1: 測試
    runs-on: ubuntu-latest            # 執行環境
    steps:                            # 步驟清單
      - uses: actions/checkout@v4     # Step 1: 檢出代碼
      - name: Run tests               # Step 2: 執行測試
        run: pytest

  lint:                               # Job 2: Linting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run linter
        run: flake8 .
```

**Linux 類比**：

```bash
# workflow ≈ 完整的自動化腳本
# job      ≈ 函式或子任務
# step     ≈ 單一指令

# 類似這樣的 shell script：
#!/bin/bash

# Job 1: test
test_job() {
    git clone repo
    pytest
}

# Job 2: lint
lint_job() {
    git clone repo
    flake8 .
}

# Trigger: on push
if [ "$EVENT" = "push" ]; then
    test_job &  # 並行執行
    lint_job &
    wait
fi
```

### 2.2 核心元素詳解

#### 2.2.1 Trigger（觸發器）

**常用觸發事件**：

```yaml
# 1. Push 事件
on:
  push:
    branches:
      - main              # 只在 main 分支
      - 'release/**'      # 所有 release 分支
    paths:
      - 'src/**'          # 只在 src 目錄變更時

# 2. Pull Request 事件
on:
  pull_request:
    types: [opened, synchronize, reopened]

# 3. 定時執行（cron）
on:
  schedule:
    - cron: '0 2 * * *'   # 每天凌晨 2 點

# 4. 手動觸發
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'

# 5. 多個觸發條件
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'
```

#### 2.2.2 Jobs（工作）

**Jobs 的特性**：
- 預設**並行執行**（加快速度）
- 可以設定**依賴關係**（需要順序時）
- 在**獨立的環境**中執行（互不影響）

```yaml
jobs:
  # Job 1: 建立
  build:
    runs-on: ubuntu-latest
    steps:
      - run: npm run build

  # Job 2: 測試（依賴 build）
  test:
    needs: build          # 等待 build 完成
    runs-on: ubuntu-latest
    steps:
      - run: npm test

  # Job 3: 部署（依賴 test）
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - run: npm run deploy
```

**執行流程**：
```
build (開始)
  ↓
build (完成) → test (開始)
                  ↓
              test (完成) → deploy (開始)
                               ↓
                           deploy (完成)
```

**並行 vs 順序執行**：

```yaml
# 並行執行（預設）
jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps: [...]

  test-frontend:
    runs-on: ubuntu-latest
    steps: [...]

  lint:
    runs-on: ubuntu-latest
    steps: [...]

# 這三個 jobs 會同時執行，節省時間
```

#### 2.2.3 Steps（步驟）

Steps 是 job 中的具體操作，有兩種形式：

**1. 使用現成的 Action（uses）**：

```yaml
steps:
  # 檢出代碼（必備）
  - uses: actions/checkout@v4

  # 設置 Python 環境
  - uses: actions/setup-python@v4
    with:
      python-version: '3.11'

  # 快取依賴
  - uses: actions/cache@v3
    with:
      path: ~/.cache/pip
      key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
```

**2. 執行命令（run）**：

```yaml
steps:
  - name: Install dependencies
    run: |
      pip install -r requirements.txt
      pip install pytest pytest-cov

  - name: Run tests
    run: pytest --cov=. --cov-report=xml

  - name: Check coverage
    run: |
      coverage report
      if [ $(coverage report | grep TOTAL | awk '{print $4}' | sed 's/%//') -lt 80 ]; then
        echo "Coverage below 80%"
        exit 1
      fi
```

### 2.3 執行環境（Runners）

**常用執行環境**：

```yaml
jobs:
  test:
    runs-on: ubuntu-latest      # Ubuntu Linux（最常用）
    # runs-on: macos-latest     # macOS
    # runs-on: windows-latest   # Windows
```

**自架 Runner（Self-hosted）**：

```yaml
jobs:
  deploy:
    runs-on: self-hosted        # 使用自己的伺服器
    steps: [...]
```

**使用時機**：
- ✅ **GitHub-hosted**：適合大多數情況，免費額度充足
- ✅ **Self-hosted**：需要特殊硬體、內部網路、或成本優化

---

## 3. 實戰：建立第一個 Workflow

### 3.1 情境：為 Python FastAPI 專案建立測試管線

**專案結構**：

```
my-fastapi-project/
├── app/
│   ├── __init__.py
│   ├── main.py
│   └── models.py
├── tests/
│   ├── __init__.py
│   └── test_main.py
├── requirements.txt
└── .github/
    └── workflows/
        └── test.yml
```

### 3.2 用 AI 生成 Workflow（推薦方式）

**提示詞範本**：

```
我有一個 Python FastAPI 專案，結構如下：
- 主程式：app/main.py
- 測試：tests/test_main.py
- 依賴：requirements.txt（包含 fastapi、pytest、pytest-cov）

請幫我建立一個 GitHub Actions workflow，要求：
1. 在每次 push 和 pull request 時觸發
2. 使用 Python 3.11
3. 安裝依賴
4. 執行 pytest 測試
5. 產生測試覆蓋率報告
6. 如果覆蓋率低於 80%，讓 workflow 失敗

請提供完整的 .github/workflows/test.yml 配置。
```

**Claude 生成的配置**（範例）：

```yaml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests with coverage
      run: |
        pytest --cov=app --cov-report=term --cov-report=xml

    - name: Check coverage threshold
      run: |
        coverage report --fail-under=80

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
```

### 3.3 理解生成的配置

**逐步解析**：

```yaml
# 1. Workflow 命名
name: Test                           # 在 GitHub UI 顯示的名稱

# 2. 觸發條件
on:
  push:
    branches: [main, develop]        # main 和 develop 分支的 push
  pull_request:
    branches: [main]                 # 對 main 的 PR

# 3. 定義 Job
jobs:
  test:                              # Job ID
    runs-on: ubuntu-latest           # Ubuntu 環境

    steps:
    # Step 1: 檢出代碼（必備步驟）
    - name: Checkout code
      uses: actions/checkout@v4      # 使用官方 checkout action

    # Step 2: 設置 Python 環境
    - name: Set up Python
      uses: actions/setup-python@v4  # 官方 Python setup action
      with:
        python-version: '3.11'       # 指定版本

    # Step 3: 快取依賴（加速後續執行）
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip           # 快取路徑
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        # key 包含 OS 和 requirements.txt 的 hash
        # 如果 requirements.txt 改變，key 會不同，快取失效

    # Step 4: 安裝依賴
    - name: Install dependencies
      run: |                         # 執行多行命令
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    # Step 5: 執行測試
    - name: Run tests with coverage
      run: |
        pytest --cov=app --cov-report=term --cov-report=xml

    # Step 6: 檢查覆蓋率
    - name: Check coverage threshold
      run: |
        coverage report --fail-under=80
        # 如果覆蓋率 < 80%，exit code 非 0，workflow 失敗

    # Step 7: 上傳覆蓋率報告（選用）
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
```

### 3.4 實際使用流程

**步驟 1：建立 workflow 檔案**

```bash
# 在專案根目錄
mkdir -p .github/workflows
cd .github/workflows

# 建立 test.yml（將 Claude 生成的內容貼上）
vim test.yml
```

**步驟 2：提交並推送**

```bash
git add .github/workflows/test.yml
git commit -m "ci: add automated testing workflow"
git push origin main
```

**步驟 3：查看執行結果**

前往 GitHub：
```
https://github.com/你的帳號/你的專案/actions
```

你會看到：
- ✅ 執行中的 workflow
- 每個 step 的執行日誌
- 成功或失敗的狀態

**步驟 4：在 PR 中看到自動檢查**

建立 Pull Request 時，會自動執行 workflow：

```
Pull Request #123: Add new feature

Checks:
✅ Test (3m 24s)
  ✅ Checkout code
  ✅ Set up Python
  ✅ Install dependencies
  ✅ Run tests with coverage
  ✅ Check coverage threshold
```

只有所有檢查通過，才能合併！

---

## 4. AI 輔助 CI/CD 開發

### 4.1 用 Claude 生成複雜 Workflow

**情境：前端 React 專案 + 後端 FastAPI**

**提示詞**：

```
我有一個 monorepo 專案，結構如下：
├── frontend/ (React + TypeScript)
│   ├── package.json
│   └── src/
└── backend/ (FastAPI)
    ├── requirements.txt
    └── app/

請幫我建立一個 GitHub Actions workflow：
1. 偵測哪個目錄有變更（frontend 或 backend）
2. 只測試有變更的部分（節省時間）
3. frontend 要執行：npm test, npm run lint, npm run build
4. backend 要執行：pytest, flake8, mypy
5. 兩者都變更時，並行執行測試

請提供完整配置。
```

**Claude 生成的智慧 Workflow**：

```yaml
name: Monorepo CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      backend: ${{ steps.filter.outputs.backend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend/**'

  test-frontend:
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
      - name: Lint
        run: cd frontend && npm run lint
      - name: Test
        run: cd frontend && npm test
      - name: Build
        run: cd frontend && npm run build

  test-backend:
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt
      - name: Lint
        run: |
          cd backend
          flake8 app
          mypy app
      - name: Test
        run: cd backend && pytest
```

**AI 幫你做的智慧決策**：
1. ✅ 使用 `dorny/paths-filter` 偵測變更
2. ✅ 用 `needs` 和 `if` 條件控制執行
3. ✅ 並行執行不同的測試
4. ✅ 節省時間和資源

### 4.2 用 AI 優化現有 Workflow

**情境：workflow 執行太慢**

**提示詞**：

```
我的 GitHub Actions workflow 執行太慢（15 分鐘），請幫我優化：

[貼上現有的 workflow 配置]

請提供優化建議，重點是：
1. 減少執行時間
2. 善用快取機制
3. 並行執行可並行的任務
```

**Claude 的優化建議範例**：

```yaml
# 原本的配置（慢）
jobs:
  test:
    steps:
      - run: npm install        # 每次都重新安裝
      - run: npm test
      - run: npm run lint
      - run: npm run build

# 優化後的配置（快）
jobs:
  test:
    steps:
      - uses: actions/checkout@v4

      # 優化 1: 快取 node_modules
      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}

      - run: npm ci             # 使用 ci 而非 install（更快）

  # 優化 2: 將 lint、test、build 拆成並行 jobs
  lint:
    steps:
      - uses: actions/checkout@v4
      - uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
      - run: npm ci
      - run: npm run lint

  build:
    steps:
      - uses: actions/checkout@v4
      - uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
      - run: npm ci
      - run: npm run build
```

**結果**：執行時間從 15 分鐘降到 5 分鐘！

### 4.3 用 AI 除錯 Workflow 錯誤

**情境：workflow 執行失敗**

**提示詞範本**：

```
我的 GitHub Actions workflow 失敗了，錯誤訊息如下：

[貼上錯誤日誌]

這是我的 workflow 配置：

[貼上 workflow YAML]

請幫我找出問題並提供修復方案。
```

**常見錯誤範例 1：權限問題**

```
Error: Error: HttpError: Resource not accessible by integration
```

**Claude 的診斷**：
```yaml
# 問題：缺少 GITHUB_TOKEN 權限

# 修復：加入 permissions
jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    steps: [...]
```

**常見錯誤範例 2：環境變數未設定**

```
Error: environment variable DATABASE_URL not found
```

**Claude 的修復**：
```yaml
steps:
  - name: Run tests
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    run: pytest
```

---

## 5. 環境變數與密鑰管理

### 5.1 使用 GitHub Secrets

**設定 Secret**：

1. 前往 GitHub 專案設定
2. `Settings` → `Secrets and variables` → `Actions`
3. 點選 `New repository secret`
4. 輸入名稱（如 `DATABASE_URL`）和值

**在 Workflow 中使用**：

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          API_KEY: ${{ secrets.API_KEY }}
        run: |
          echo "Deploying with DATABASE_URL: $DATABASE_URL"
          ./deploy.sh
```

**重要提醒**：
- ✅ Secrets 不會出現在日誌中（自動遮罩）
- ✅ 用於敏感資訊（密碼、API keys）
- ❌ 不要在程式碼中硬編碼密鑰

### 5.2 環境變數的優先順序

```yaml
# 1. Workflow 層級（所有 jobs 共享）
env:
  NODE_ENV: production

jobs:
  # 2. Job 層級（此 job 所有 steps 共享）
  deploy:
    env:
      DEPLOY_ENV: staging
    steps:
      # 3. Step 層級（只在此 step 有效）
      - name: Run script
        env:
          LOG_LEVEL: debug
        run: ./script.sh
```

**優先順序**：Step > Job > Workflow

---

## 6. 實戰情境：完整測試管線

### 6.1 情境描述

為一個 Python FastAPI 專案建立完整的測試管線，包含：
1. 單元測試
2. 整合測試
3. 程式碼品質檢查（linting）
4. 型別檢查（mypy）
5. 安全掃描（bandit）
6. 測試覆蓋率檢查

### 6.2 完整 Workflow 配置

```yaml
name: Complete Test Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # Job 1: Lint（快速檢查）
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}

      - name: Install linting tools
        run: |
          pip install flake8 black isort

      - name: Run flake8
        run: flake8 app tests --max-line-length=100

      - name: Check black formatting
        run: black --check app tests

      - name: Check import sorting
        run: isort --check-only app tests

  # Job 2: Type check
  type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install mypy
          pip install -r requirements.txt

      - name: Run mypy
        run: mypy app

  # Job 3: Security scan
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install bandit
        run: pip install bandit

      - name: Run security scan
        run: bandit -r app -f json -o bandit-report.json

      - name: Upload security report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: bandit-report.json

  # Job 4: Test（需要等 lint 和 type-check 通過）
  test:
    needs: [lint, type-check]
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio

      - name: Run unit tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: |
          pytest tests/unit --cov=app --cov-report=term --cov-report=xml

      - name: Run integration tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: |
          pytest tests/integration --cov=app --cov-append --cov-report=xml

      - name: Check coverage threshold
        run: |
          coverage report --fail-under=80

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: true

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: py-cov-action/python-coverage-comment-action@v3
        with:
          GITHUB_TOKEN: ${{ github.token }}

  # Job 5: Build（所有測試通過後才建立）
  build:
    needs: [lint, type-check, security, test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Save Docker image
        run: |
          docker save myapp:${{ github.sha }} | gzip > myapp.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: docker-image
          path: myapp.tar.gz
```

### 6.3 執行流程圖

```
Trigger (push/PR)
        │
        ├─────────┬─────────┬─────────┐
        ↓         ↓         ↓         ↓
      lint    type-check  security  (並行執行)
        │         │         │
        └────┬────┘         │
             ↓              │
           test ←───────────┘
             │
             ↓
           build
             │
             ↓
         完成 ✅
```

### 6.4 關鍵設計點

**1. 並行執行加速**：
- `lint`, `type-check`, `security` 並行執行
- 總時間 = 最慢的那個，而非總和

**2. 快速失敗（Fail Fast）**：
- lint 和 type-check 很快（< 1 分鐘）
- 如果失敗，不用等慢的測試執行

**3. 資料庫服務整合**：
```yaml
services:
  postgres:
    image: postgres:15
    # 提供真實的資料庫做整合測試
```

**4. 測試分層**：
- 單元測試先執行（快速）
- 整合測試後執行（較慢）
- 覆蓋率累積（`--cov-append`）

**5. PR 自動評論**：
- 測試覆蓋率直接顯示在 PR 中
- 不用手動查看報告

---

## 7. 最佳實踐與常見陷阱

### 7.1 最佳實踐

#### ✅ 1. 使用固定版本的 Actions

```yaml
# ❌ 不好：使用 latest
- uses: actions/checkout@latest

# ✅ 好：使用固定版本
- uses: actions/checkout@v4

# ✅ 更好：使用 commit SHA（最安全）
- uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab
```

#### ✅ 2. 善用快取

```yaml
# 快取 Python 依賴
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}

# 快取 Node.js 依賴
- uses: actions/cache@v3
  with:
    path: node_modules
    key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
```

#### ✅ 3. 設定超時時間

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 10      # 避免無限等待
    steps: [...]
```

#### ✅ 4. 使用 Matrix 測試多版本

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']
    steps:
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - run: pytest
```

#### ✅ 5. 分離關注點

```yaml
# 將複雜邏輯放在 script 中，不要寫在 workflow
- name: Complex deployment
  run: ./scripts/deploy.sh    # 而非直接寫在這裡
```

### 7.2 常見陷阱

#### ❌ 1. 忘記 checkout 代碼

```yaml
jobs:
  test:
    steps:
      # ❌ 少了這一步
      # - uses: actions/checkout@v4

      - run: pytest    # 找不到檔案！
```

#### ❌ 2. 快取 key 設定錯誤

```yaml
# ❌ 錯誤：key 永遠一樣，即使依賴改變
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: pip-cache

# ✅ 正確：包含依賴檔案的 hash
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
```

#### ❌ 3. Secret 外洩

```yaml
# ❌ 危險：Secret 會出現在日誌
- run: echo "API_KEY=${{ secrets.API_KEY }}"

# ✅ 安全：使用環境變數
- name: Use secret
  env:
    API_KEY: ${{ secrets.API_KEY }}
  run: |
    # Secret 不會出現在日誌
    ./script.sh
```

#### ❌ 4. 過度並行導致資源競爭

```yaml
# ❌ 問題：所有測試同時寫入同一個資料庫
jobs:
  test-1:
    steps:
      - run: pytest tests/test_users.py
  test-2:
    steps:
      - run: pytest tests/test_orders.py
  # 可能互相干擾

# ✅ 解決：使用不同的資料庫或序列執行
```

---

## 8. Linux 學習類比：理解 GitHub Actions

### 8.1 概念對應

| GitHub Actions | Linux 等價概念 | 說明 |
|----------------|---------------|------|
| Workflow | Shell script | 定義要執行的任務 |
| Trigger (on) | cron / inotify | 何時執行 |
| Job | Function | 獨立的任務單元 |
| Step | Command | 單一指令 |
| Action (uses) | Binary/Package | 可重用的工具 |
| Runner | Machine/Container | 執行環境 |
| Artifact | File output | 產出的檔案 |
| Cache | /tmp or ~/.cache | 暫存以加速 |
| Secret | Environment var | 敏感資訊 |

### 8.2 類比理解

**Workflow ≈ Cron Job + Shell Script**：

```bash
# crontab -e
0 2 * * * /path/to/backup.sh    # 每天 2 點執行備份

# backup.sh
#!/bin/bash
cd /app
git pull
npm test
npm run build
```

**對應的 GitHub Actions**：

```yaml
# .github/workflows/nightly.yml
on:
  schedule:
    - cron: '0 2 * * *'           # 每天 2 點

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4  # git pull
      - run: npm test               # npm test
      - run: npm run build          # npm run build
```

### 8.3 學習策略

**像學 Linux 一樣學 GitHub Actions**：

1. **不需要記住所有參數**
   - 重點是理解結構（workflow → jobs → steps）
   - 用時查文件或問 AI

2. **從簡單範例開始**
   - 先跑一個 "Hello World" workflow
   - 逐步加入功能

3. **學會讀錯誤日誌**
   - GitHub Actions 的日誌很詳細
   - 每個 step 都有展開的執行過程

4. **善用 AI 工具**
   - Claude 可以生成 80% 的配置
   - 你只需要理解和微調

---

## 9. 本章總結

### 9.1 核心概念回顧

1. **CI/CD 的價值**：
   - 自動化測試，快速發現問題
   - 標準化流程，減少人為錯誤
   - 在 AI 時代尤其重要（40% 代碼有問題）

2. **GitHub Actions 結構**：
   ```
   Workflow (on → jobs)
     ├─ Job 1 (runs-on → steps)
     ├─ Job 2 (runs-on → steps)
     └─ Job 3 (runs-on → steps)
   ```

3. **核心元素**：
   - **Trigger**：何時執行（push, PR, schedule）
   - **Job**：獨立任務，預設並行
   - **Step**：具體操作（uses 或 run）
   - **Runner**：執行環境（ubuntu, macos, windows）

4. **AI 的角色**：
   - 生成 workflow 配置（節省 80% 時間）
   - 優化現有配置（加速執行）
   - 除錯失敗原因（快速診斷）

### 9.2 學習檢查點

完成本章後，確認你能夠：

- [ ] 說明 CI/CD 解決了什麼問題
- [ ] 理解 workflow、job、step 的關係
- [ ] 用 Claude 生成基礎 workflow 配置
- [ ] 為專案建立自動化測試管線
- [ ] 使用 GitHub Secrets 管理敏感資訊
- [ ] 閱讀並理解 workflow 執行日誌
- [ ] 處理常見的 workflow 錯誤

### 9.3 實踐建議

1. **立即動手**：
   - 為你的一個專案建立測試 workflow
   - 觀察執行過程，理解每個 step

2. **用 AI 加速**：
   - 不要從零寫，讓 Claude 生成範本
   - 理解配置後再客製化

3. **迭代優化**：
   - 先建立簡單版本（只測試）
   - 逐步加入功能（linting、coverage）
   - 最後優化效能（快取、並行）

### 9.4 下一步

學完 GitHub Actions 基礎後，下一章將深入探討：

**5.2 安全掃描與自動修復**：
- CodeQL 靜態分析
- Snyk 依賴漏洞掃描
- Trivy 容器掃描
- AI 輔助漏洞修復

這是 AI 時代最關鍵的一環，因為 **40% 的 AI 代碼包含安全問題**。

---

**準備好了嗎？** 前往 `5.2_安全掃描與自動修復.md` →
