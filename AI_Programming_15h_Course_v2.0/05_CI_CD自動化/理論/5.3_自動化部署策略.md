# 5.3 自動化部署策略：安全高效的發布

## 📚 本章概述

**學習類型**：補充閱讀（選修）

**閱讀時長**：20-30 分鐘

**核心目標**：
- 理解不同部署策略的優缺點
- 掌握 Docker 容器化部署
- 學會用 AI 生成部署腳本
- 建立回退與災難恢復機制

**定位**：
> 本章是補充內容，涵蓋部署相關的進階主題。
> 核心課程（1.5h）專注於 測試 + 安全掃描。
> 部署策略可依需求深入學習。

---

## 1. 部署策略對比

### 1.1 五種常見部署策略

#### 策略 1：滾動部署（Rolling Deployment）

**原理**：
```
[V1] [V1] [V1] [V1]    原有 4 個實例
  ↓
[V2] [V1] [V1] [V1]    逐一更新
  ↓
[V2] [V2] [V1] [V1]
  ↓
[V2] [V2] [V2] [V1]
  ↓
[V2] [V2] [V2] [V2]    完成
```

**優點**：
- ✅ 無需額外資源
- ✅ 簡單易實作
- ✅ 零停機時間

**缺點**：
- ❌ V1 和 V2 同時存在（可能有相容性問題）
- ❌ 回退慢（需要逐一回復）

**適用場景**：
- 向後相容的更新
- 資源有限的小型應用

**Kubernetes 實作**：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 4
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # 最多多啟動 1 個新版本
      maxUnavailable: 1  # 最多停止 1 個舊版本
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v2
```

#### 策略 2：藍綠部署（Blue-Green Deployment）

**原理**：
```
藍色環境（V1）[正在服務流量]
  ↓
綠色環境（V2）[部署新版本，測試]
  ↓
[切換流量到綠色環境]
  ↓
綠色環境（V2）[正在服務流量]
藍色環境（V1）[保留一段時間，以備回退]
```

**優點**：
- ✅ 瞬間切換（秒級）
- ✅ 快速回退（切回藍色）
- ✅ 零停機時間
- ✅ 完整測試後再切換

**缺點**：
- ❌ 需要雙倍資源（同時運行兩套環境）
- ❌ 資料庫遷移複雜（兩邊要相容）

**適用場景**：
- 對停機時間零容忍
- 有充足資源
- 需要快速回退能力

**實作範例（用 AWS ALB）**：

```yaml
# GitHub Actions workflow
name: Blue-Green Deployment

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 建立新版本（綠色）
      - name: Build new version
        run: |
          docker build -t myapp:green .
          docker tag myapp:green $ECR_REGISTRY/myapp:green
          docker push $ECR_REGISTRY/myapp:green

      # 部署到綠色環境
      - name: Deploy to green environment
        run: |
          aws ecs update-service --cluster prod --service myapp-green --force-new-deployment

      # 等待綠色環境健康檢查
      - name: Wait for green environment
        run: |
          aws ecs wait services-stable --cluster prod --services myapp-green

      # 執行煙霧測試
      - name: Run smoke tests on green
        run: |
          ./scripts/smoke-test.sh https://green.myapp.com

      # 切換流量到綠色
      - name: Switch traffic to green
        run: |
          aws elbv2 modify-listener --listener-arn $LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$GREEN_TG_ARN

      # 保留藍色環境 30 分鐘（以備回退）
      - name: Keep blue environment
        run: |
          sleep 1800  # 30 minutes

      # 如果沒問題，移除藍色環境
      - name: Teardown blue environment
        if: success()
        run: |
          aws ecs update-service --cluster prod --service myapp-blue --desired-count 0
```

#### 策略 3：金絲雀部署（Canary Deployment）

**原理**：
```
[V1] [V1] [V1] [V1]    100% 流量到 V1
  ↓
[V2] [V1] [V1] [V1]    5% 流量到 V2（金絲雀）
  ↓ 監控指標
[V2] [V2] [V1] [V1]    20% 流量到 V2
  ↓ 監控指標
[V2] [V2] [V2] [V1]    50% 流量到 V2
  ↓ 監控指標
[V2] [V2] [V2] [V2]    100% 流量到 V2
```

**優點**：
- ✅ 風險最低（逐步驗證）
- ✅ 影響範圍小（問題只影響少數用戶）
- ✅ 可以監控實際用戶反應

**缺點**：
- ❌ 部署時間長
- ❌ 需要複雜的流量管理
- ❌ 監控和告警要求高

**適用場景**：
- 高風險更新
- 大規模用戶應用
- 需要驗證真實用戶反應

**實作範例（用 Istio）**：

```yaml
# 階段 1：5% 流量到 V2
apiVersion: networking.istio.io/v1
kind: VirtualService
metadata:
  name: myapp
spec:
  hosts:
  - myapp.com
  http:
  - match:
    - headers:
        user-agent:
          regex: ".*Mobile.*"
    route:
    - destination:
        host: myapp
        subset: v2
      weight: 5
    - destination:
        host: myapp
        subset: v1
      weight: 95
```

**自動化金絲雀（用 Flagger）**：

```yaml
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: myapp
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  progressDeadlineSeconds: 60
  service:
    port: 80
  analysis:
    interval: 1m
    threshold: 5
    maxWeight: 50
    stepWeight: 10
    metrics:
    - name: request-success-rate
      thresholdRange:
        min: 99
    - name: request-duration
      thresholdRange:
        max: 500
    webhooks:
    - name: load-test
      url: http://load-tester/
```

#### 策略 4：A/B 測試部署

**原理**：
```
用戶 A 群組 → V1（現有功能）
用戶 B 群組 → V2（新功能）

→ 比較轉換率、用戶體驗等指標
→ 決定採用哪個版本
```

**與金絲雀的差異**：
- **金絲雀**：驗證穩定性（錯誤率、效能）
- **A/B**：驗證業務效果（轉換率、留存率）

**適用場景**：
- 產品實驗
- 功能驗證
- 用戶體驗優化

#### 策略 5：重建部署（Recreate）

**原理**：
```
[V1] [V1] [V1] [V1]    停止所有 V1
  ↓ (停機時間)
[V2] [V2] [V2] [V2]    啟動所有 V2
```

**優點**：
- ✅ 實作最簡單
- ✅ 無版本共存問題

**缺點**：
- ❌ 有停機時間

**適用場景**：
- 內部工具（可接受短暫停機）
- 開發/測試環境
- 不相容的重大更新

### 1.2 部署策略選擇決策樹

```
需要零停機嗎？
├─ 否 → Recreate（最簡單）
└─ 是
    └─ 有充足資源嗎？
        ├─ 是 → Blue-Green（最快回退）
        └─ 否
            └─ 是高風險更新嗎？
                ├─ 是 → Canary（最安全）
                └─ 否 → Rolling（平衡）
```

---

## 2. Docker 容器化部署

### 2.1 為什麼容器化？

**問題：環境不一致**

```
開發環境：
  - Python 3.11
  - Ubuntu 22.04
  - PostgreSQL 15

生產環境：
  - Python 3.9
  - CentOS 7
  - PostgreSQL 13

→ "在我電腦上可以" 問題
```

**解決：容器化**

```
容器包含：
  - 應用程式
  - 所有依賴
  - 執行環境

→ 一致性：開發 = 測試 = 生產
```

### 2.2 Dockerfile 最佳實踐

**範例：FastAPI 應用**

```dockerfile
# ===== 階段 1：建立階段 =====
FROM python:3.11 AS builder

# 設定工作目錄
WORKDIR /app

# 安裝依賴（分層快取）
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# ===== 階段 2：執行階段 =====
FROM python:3.11-slim

# 建立非 root 使用者（安全）
RUN useradd -m -u 1000 appuser

# 設定工作目錄
WORKDIR /app

# 只複製必要的檔案
COPY --from=builder /root/.local /root/.local
COPY --chown=appuser:appuser . .

# 設定環境變數
ENV PATH=/root/.local/bin:$PATH \
    PYTHONUNBUFFERED=1

# 切換到非 root 使用者
USER appuser

# 暴露端口
EXPOSE 8000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# 啟動命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**關鍵最佳實踐**：

1. **多階段建立**：減少最終映像大小
2. **非 root 使用者**：提升安全性
3. **HEALTHCHECK**：容器健康檢查
4. **分層快取**：先複製 requirements.txt（不常變）

### 2.3 用 AI 生成 Dockerfile

**提示詞範本**：

```
我有一個 FastAPI 應用，使用以下技術：
- Python 3.11
- PostgreSQL 資料庫
- Redis 快取
- 依賴列在 requirements.txt

請幫我建立一個生產級別的 Dockerfile：
1. 使用多階段建立
2. 最小化映像大小
3. 加入健康檢查
4. 使用非 root 使用者
5. 優化快取層

也請提供 docker-compose.yml 用於本機開發。
```

### 2.4 部署 Workflow 範例

```yaml
name: Build and Deploy

on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      # 登入 GitHub Container Registry
      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 設定 Docker Buildx（多平台建立）
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # 生成標籤和 labels
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}

      # 建立並推送映像
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 部署到 Kubernetes
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v4
        with:
          manifests: |
            k8s/deployment.yml
            k8s/service.yml
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

---

## 3. 回退與災難恢復

### 3.1 快速回退策略

**藍綠部署回退**（最快）：

```bash
# 切回藍色環境（秒級）
aws elbv2 modify-listener --listener-arn $LISTENER_ARN \
  --default-actions Type=forward,TargetGroupArn=$BLUE_TG_ARN
```

**Kubernetes 回退**：

```bash
# 查看部署歷史
kubectl rollout history deployment/myapp

# 回退到上一個版本
kubectl rollout undo deployment/myapp

# 回退到特定版本
kubectl rollout undo deployment/myapp --to-revision=3
```

**Docker 回退**：

```bash
# 使用之前的映像標籤
docker pull myapp:previous-stable
docker stop myapp-current
docker run -d --name myapp-current myapp:previous-stable
```

### 3.2 自動化回退

**在 GitHub Actions 中實作自動回退**：

```yaml
name: Deploy with Auto-Rollback

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy new version
        id: deploy
        run: |
          kubectl set image deployment/myapp myapp=myapp:${{ github.sha }}
          kubectl rollout status deployment/myapp --timeout=5m
        continue-on-error: true

      # 健康檢查
      - name: Health check
        id: health
        if: steps.deploy.outcome == 'success'
        run: |
          sleep 30
          HEALTH=$(curl -s -o /dev/null -w "%{http_code}" https://myapp.com/health)
          if [ "$HEALTH" != "200" ]; then
            echo "Health check failed: $HEALTH"
            exit 1
          fi
        continue-on-error: true

      # 監控錯誤率
      - name: Check error rate
        id: errors
        if: steps.health.outcome == 'success'
        run: |
          # 查詢 Prometheus/CloudWatch 的錯誤率
          ERROR_RATE=$(./scripts/check-error-rate.sh)
          if (( $(echo "$ERROR_RATE > 5" | bc -l) )); then
            echo "Error rate too high: $ERROR_RATE%"
            exit 1
          fi
        continue-on-error: true

      # 自動回退
      - name: Auto rollback
        if: |
          steps.deploy.outcome == 'failure' ||
          steps.health.outcome == 'failure' ||
          steps.errors.outcome == 'failure'
        run: |
          echo "❌ Deployment failed, rolling back..."
          kubectl rollout undo deployment/myapp
          kubectl rollout status deployment/myapp --timeout=3m

      # 通知
      - name: Notify team
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            ❌ Deployment failed and rolled back
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### 3.3 災難恢復計畫

**RTO 和 RPO 定義**：

```
RTO (Recovery Time Objective): 最長可接受停機時間
RPO (Recovery Point Objective): 最多可接受的資料遺失

範例：
  RTO = 1 hour  → 1 小時內必須恢復服務
  RPO = 5 min   → 最多遺失 5 分鐘的資料
```

**災難恢復層級**：

```
Tier 1: 冷備份
  - RTO: 24+ hours
  - RPO: 24 hours
  - 成本：低
  - 方法：定期備份到 S3

Tier 2: 溫備份
  - RTO: 4-12 hours
  - RPO: 1 hour
  - 成本：中
  - 方法：備用環境（關閉狀態）

Tier 3: 熱備份
  - RTO: < 1 hour
  - RPO: < 5 minutes
  - 成本：高
  - 方法：主動-主動架構，跨區域部署

Tier 4: 即時容錯
  - RTO: 0 (無停機)
  - RPO: 0 (無資料遺失)
  - 成本：很高
  - 方法：同步複寫、自動容錯轉移
```

**自動化備份 Workflow**：

```yaml
name: Automated Backup

on:
  schedule:
    - cron: '0 2 * * *'  # 每天凌晨 2 點

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      # 備份資料庫
      - name: Backup database
        run: |
          pg_dump $DATABASE_URL | gzip > backup-$(date +%Y%m%d).sql.gz

      # 上傳到 S3
      - name: Upload to S3
        run: |
          aws s3 cp backup-$(date +%Y%m%d).sql.gz \
            s3://my-backups/postgres/$(date +%Y%m%d).sql.gz

      # 驗證備份
      - name: Verify backup
        run: |
          aws s3 ls s3://my-backups/postgres/$(date +%Y%m%d).sql.gz

      # 刪除舊備份（保留 30 天）
      - name: Cleanup old backups
        run: |
          aws s3 ls s3://my-backups/postgres/ | \
            awk '{print $4}' | \
            head -n -30 | \
            xargs -I {} aws s3 rm s3://my-backups/postgres/{}
```

---

## 4. 用 AI 生成部署腳本

### 4.1 複雜部署場景

**提示詞範本**：

```
我需要為一個微服務應用建立 Kubernetes 部署腳本：

應用架構：
- 前端（React）：3 個副本
- 後端 API（FastAPI）：5 個副本
- Worker（Celery）：2 個副本
- Redis：1 個副本（StatefulSet）
- PostgreSQL：使用外部 RDS

需求：
1. 前端和 API 使用滾動更新
2. Worker 使用重建策略
3. 加入健康檢查
4. 配置資源限制
5. 使用 ConfigMap 管理環境變數
6. 使用 Secret 管理敏感資訊

請提供完整的 Kubernetes manifests。
```

**Claude 會生成**：
- Deployment YAML（前端、API、Worker）
- StatefulSet YAML（Redis）
- Service YAML
- ConfigMap YAML
- Secret YAML（範本）
- Ingress YAML

### 4.2 部署腳本優化

**提示詞範本**：

```
我目前的部署腳本如下：

[貼上現有腳本]

請幫我優化：
1. 加入錯誤處理
2. 加入回退機制
3. 加入健康檢查
4. 優化執行速度
5. 加入日誌記錄
```

---

## 5. 本章總結

### 5.1 部署策略總結

| 策略 | 停機時間 | 資源需求 | 回退速度 | 風險 | 適用場景 |
|------|---------|---------|---------|------|---------|
| Recreate | 有 | 低 | 慢 | 高 | 內部工具 |
| Rolling | 無 | 低 | 慢 | 中 | 一般應用 |
| Blue-Green | 無 | 高 | 快 | 低 | 高可用性 |
| Canary | 無 | 中 | 中 | 低 | 高風險更新 |
| A/B | 無 | 中 | 中 | 低 | 產品實驗 |

### 5.2 關鍵要點

**容器化**：
- 使用多階段建立減少映像大小
- 使用非 root 使用者提升安全性
- 加入健康檢查確保可用性

**自動化回退**：
- 設定健康檢查閾值
- 監控關鍵指標（錯誤率、延遲）
- 自動觸發回退機制

**災難恢復**：
- 定義 RTO 和 RPO
- 自動化備份流程
- 定期測試恢復程序

### 5.3 實戰建議

**新手**：
- 從 Rolling Deployment 開始
- 使用 Docker Compose 本機開發
- 手動部署並觀察流程

**進階**：
- 實作 Blue-Green 或 Canary
- 整合監控和告警
- 建立自動回退機制

**專家**：
- 設計多區域容錯架構
- 實作混沌工程測試
- 建立完整的災難恢復計畫

---

**恭喜完成理論學習！** 繼續前往實戰練習 →
