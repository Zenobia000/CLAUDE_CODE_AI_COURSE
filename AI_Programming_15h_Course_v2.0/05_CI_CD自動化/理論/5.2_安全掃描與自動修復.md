# 5.2 安全掃描與自動修復：AI 時代的必要防護

## 📚 本章概述

**學習時長**：45 分鐘

**核心目標**：
- 理解為什麼安全掃描在 AI 時代更重要
- 掌握多層次安全掃描策略
- 學會配置 CodeQL、Snyk、Trivy
- 用 AI 輔助漏洞修復

**核心數據**：
> **40% 的 AI 生成代碼包含安全問題**
>
> 來源：課程設計文件（引用業界研究）

**本章重點**：
```
傳統開發：手動審查（容易遺漏）
AI 時代：  自動掃描 + AI 輔助修復（必要措施）
```

---

## 1. 為什麼安全掃描在 AI 時代更重要？

### 1.1 AI 代碼的安全風險

**問題 1：生成速度快，問題也快**

```python
# 你問 AI：「幫我寫一個用戶登入 API」
# AI 5 秒生成：

@app.post("/login")
def login(username: str, password: str):
    # ❌ 安全問題 1：SQL 注入風險
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    result = db.execute(query)

    # ❌ 安全問題 2：密碼明文比對
    if result:
        # ❌ 安全問題 3：沒有 rate limiting
        # ❌ 安全問題 4：沒有 HTTPS 強制
        return {"token": generate_token(username)}
    return {"error": "Invalid credentials"}
```

**看似正確，但有 4 個嚴重安全問題！**

**問題 2：信任度悖論**

```
開發者行為數據（課程引用）：
┌─────────────────────────┐
│ 80% 開發者使用 AI       │  ← 高使用率
│ 29% 開發者信任 AI 代碼  │  ← 低信任度
│ 40% AI 代碼含安全問題   │  ← 高風險
└─────────────────────────┘

結論：大家在用，但不信任，而且風險真的很高
```

**問題 3：Code Churn 翻倍**

```
AI 加速開發 → 代碼產出量翻倍 → 人工審查跟不上
          ↓
    安全漏洞累積
```

### 1.2 三層防禦策略

**安全掃描金字塔**：

```
           ┌───────────────┐
           │  人工審查      │  ← 最後防線（專家級）
           └───────────────┘
          ┌─────────────────┐
          │  安全測試        │  ← 動態測試（執行時）
          └─────────────────┘
         ┌───────────────────┐
         │  依賴掃描         │  ← 第三方套件
         └───────────────────┘
        ┌─────────────────────┐
        │  靜態分析            │  ← 代碼層面（最廣）
        └─────────────────────┘
```

**我們要建立的自動化防護**：

```
Layer 1: 靜態分析（CodeQL）
         → 掃描程式碼邏輯漏洞（SQL 注入、XSS、CSRF）

Layer 2: 依賴掃描（Snyk / Dependabot）
         → 檢查第三方套件的已知漏洞（CVE）

Layer 3: 容器掃描（Trivy）
         → 掃描 Docker 映像的漏洞

Layer 4: AI 輔助修復（Copilot Autofix）
         → 自動生成修復建議
```

---

## 2. Layer 1：靜態分析（CodeQL）

### 2.1 什麼是 CodeQL？

**定義**：
> CodeQL 是 GitHub 開發的語義代碼分析引擎，將程式碼視為「可查詢的資料庫」。

**核心概念**：
```
傳統 Linter（如 flake8）：
  → 檢查語法、風格問題
  → 模式匹配（pattern matching）

CodeQL：
  → 理解程式碼的語義（semantics）
  → 追蹤數據流（data flow）
  → 找出複雜的安全漏洞
```

**範例：為什麼 CodeQL 更強大**

```python
# 簡單的 SQL 注入（Linter 可以抓到）
def bad_query_1(user_input):
    query = f"SELECT * FROM users WHERE id = {user_input}"  # ❌ flake8 可能警告
    db.execute(query)

# 複雜的 SQL 注入（只有 CodeQL 能抓到）
def bad_query_2(user_input):
    temp = user_input          # 變數傳遞
    processed = process(temp)   # 經過處理
    query = build_query(processed)  # 動態建立
    db.execute(query)          # ❌ CodeQL 追蹤整個數據流，發現問題
```

### 2.2 設定 CodeQL 掃描

#### 2.2.1 方法 1：用 GitHub 介面（最簡單）

**步驟**：
1. 前往你的 GitHub 專案
2. `Settings` → `Security` → `Code security and analysis`
3. 啟用 **CodeQL analysis**
4. GitHub 自動建立 workflow

**自動生成的 workflow**：

```yaml
# .github/workflows/codeql-analysis.yml
name: "CodeQL"

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * 1'  # 每週一凌晨執行

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      matrix:
        language: ['python']
        # 支援：javascript, typescript, python, java, cpp, csharp, go, ruby

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # 初始化 CodeQL
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: ${{ matrix.language }}
        queries: security-and-quality  # 使用安全與品質查詢集

    # 對於編譯型語言（Java, C++），需要建立步驟
    # Python/JavaScript 不需要

    # 執行 CodeQL 分析
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
```

#### 2.2.2 方法 2：用 AI 生成（推薦）

**提示詞範本**：

```
我有一個 Python FastAPI 專案，想加入 CodeQL 安全掃描。

請幫我建立 GitHub Actions workflow：
1. 在 push 和 PR 時執行掃描
2. 使用 security-extended 查詢集（更嚴格）
3. 如果發現高危漏洞，讓 workflow 失敗
4. 自動上傳結果到 GitHub Security tab

請提供完整的 .github/workflows/codeql.yml 配置。
```

**Claude 生成的增強版配置**：

```yaml
name: CodeQL Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * 1'  # 每週一凌晨 2 點

jobs:
  analyze:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: python
        queries: security-extended  # 更嚴格的查詢集
        config-file: ./.github/codeql/codeql-config.yml

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
      with:
        category: "/language:python"

    # 下載掃描結果
    - name: Download CodeQL results
      if: always()
      uses: actions/download-artifact@v3

    # 檢查是否有高危漏洞
    - name: Check for critical vulnerabilities
      if: always()
      run: |
        # 這裡可以加入自訂邏輯，檢查 SARIF 結果
        # 如果有 critical 級別的問題，exit 1
        echo "Checking for critical vulnerabilities..."
```

**客製化查詢配置**（`.github/codeql/codeql-config.yml`）：

```yaml
name: "Custom CodeQL Config"

queries:
  - uses: security-extended
  - uses: security-and-quality

# 排除不需要掃描的路徑
paths-ignore:
  - 'tests/**'
  - 'docs/**'
  - '**/*.test.py'

# 自訂查詢（進階）
query-filters:
  - exclude:
      id: py/unused-import  # 忽略未使用的 import（不是安全問題）
```

### 2.3 理解 CodeQL 結果

**範例：SQL 注入檢測**

假設 CodeQL 發現這個問題：

```python
# app/api/users.py
@app.get("/users/{user_id}")
def get_user(user_id: str):
    # ❌ CodeQL 警告：SQL injection
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    result = db.execute(query)
    return result
```

**在 GitHub Security tab 看到**：

```
┌────────────────────────────────────────────────┐
│ 🔴 High: SQL injection                         │
├────────────────────────────────────────────────┤
│ File: app/api/users.py, Line 45               │
│                                                │
│ User-controlled data flows into SQL query      │
│ without sanitization.                          │
│                                                │
│ Data flow:                                     │
│   user_id (line 43) → query (line 45)         │
│                                                │
│ 💡 Recommendation:                             │
│   Use parameterized queries                    │
└────────────────────────────────────────────────┘
```

**用 AI 修復**（下一節詳述）

---

## 3. Layer 2：依賴掃描（Snyk / Dependabot）

### 3.1 為什麼需要依賴掃描？

**現代應用的依賴現實**：

```
你的應用
  ├── FastAPI (直接依賴)
  │   ├── Starlette
  │   │   ├── anyio
  │   │   └── ...
  │   └── Pydantic
  │       ├── typing-extensions
  │       └── ...
  ├── SQLAlchemy (直接依賴)
  │   ├── greenlet
  │   └── ...
  └── ... (數十個間接依賴)

總計：可能有 50-100 個依賴套件
```

**問題**：任何一個依賴有漏洞，你的應用就有漏洞！

**真實案例**：

```
2021 年：Log4Shell (CVE-2021-44228)
  → Java 的 log4j 套件漏洞
  → 影響全球數百萬個應用
  → 遠端代碼執行（最高危）

如果你的依賴樹中有 log4j，你就中招了
即使你沒有直接使用它！
```

### 3.2 使用 GitHub Dependabot（免費）

**啟用 Dependabot**：

1. `Settings` → `Security` → `Code security and analysis`
2. 啟用 **Dependabot alerts**
3. 啟用 **Dependabot security updates**

**配置 Dependabot**（`.github/dependabot.yml`）：

```yaml
version: 2
updates:
  # Python 依賴
  - package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"      # 每週檢查一次
    open-pull-requests-limit: 10

    # 自動合併補丁版本
    automerge:
      - match:
          dependency-type: "all"
          update-type: "security:patch"

  # GitHub Actions 依賴
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "monthly"

  # Docker 依賴
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
```

**Dependabot 的工作流程**：

```
每週執行
  ↓
掃描 requirements.txt / package.json
  ↓
檢查 CVE 資料庫
  ↓
發現漏洞？
  ├─ 是 → 自動建立 PR 更新套件
  └─ 否 → 繼續監控

你收到 PR 通知
  ↓
審查 → 測試通過 → 合併
```

### 3.3 使用 Snyk（更強大）

**Snyk vs Dependabot**：

| 功能 | Dependabot | Snyk |
|------|-----------|------|
| 掃描依賴漏洞 | ✅ | ✅ |
| 自動 PR 更新 | ✅ | ✅ |
| 代碼級別掃描 | ❌ | ✅ |
| 容器掃描 | ❌ | ✅ |
| 修復建議 | 基本 | 詳細 |
| 免費額度 | 無限 | 200 次/月 |

**設定 Snyk 掃描**：

```yaml
# .github/workflows/snyk.yml
name: Snyk Security Scan

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  snyk:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/python-3.10@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high  # 只報告高危漏洞
          command: test

      - name: Upload result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: snyk.sarif
```

**設定 Snyk Token**：

1. 註冊 [snyk.io](https://snyk.io)
2. 取得 API Token
3. 在 GitHub 專案設定 Secret：`SNYK_TOKEN`

### 3.4 理解依賴掃描結果

**範例：Dependabot 通知**

```
🔔 Dependabot Alert

Package: requests
Current: 2.27.0
Fixed in: 2.31.0

Vulnerability: CVE-2023-32681
Severity: High
Description: Requests library can leak proxy credentials when redirected

Impact:
  If your application uses proxies with authentication,
  credentials may be exposed in redirect URLs.

Recommended action:
  Update to requests 2.31.0 or later

[View details] [Create automated PR]
```

**決策流程**：

```
收到 Dependabot/Snyk 通知
  ↓
檢查嚴重性
  ├─ Critical/High → 立即處理
  ├─ Medium       → 本週處理
  └─ Low          → 排程處理
  ↓
檢查修復版本
  ├─ 補丁版本（2.27.0 → 2.27.1） → 安全，直接更新
  ├─ 次版本（2.27.0 → 2.28.0）   → 測試後更新
  └─ 主版本（2.x → 3.x）         → 謹慎評估，可能有破壞性
  ↓
執行測試
  ├─ 通過 → 合併 PR
  └─ 失敗 → 手動修復相容性問題
```

---

## 4. Layer 3：容器掃描（Trivy）

### 4.1 為什麼需要容器掃描？

**Docker 映像的隱藏風險**：

```dockerfile
# 你的 Dockerfile
FROM python:3.11-slim    # ← 這個基礎映像包含什麼？

COPY requirements.txt .
RUN pip install -r requirements.txt  # ← 這些套件有漏洞嗎？

COPY . .
CMD ["uvicorn", "app.main:app"]
```

**基礎映像可能包含**：
- 作業系統套件（apt packages）
- 系統函式庫（libc, openssl）
- 預裝工具（curl, wget）

**任何一個都可能有漏洞！**

### 4.2 使用 Trivy 掃描

**Trivy 特點**：
- ✅ 開源免費
- ✅ 掃描速度快
- ✅ 支援多種格式（Docker, Kubernetes, Terraform）
- ✅ 整合簡單

**設定 Trivy 掃描 Workflow**：

```yaml
# .github/workflows/docker-security.yml
name: Docker Security Scan

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 建立 Docker 映像
      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      # 用 Trivy 掃描
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      # 上傳結果到 GitHub Security
      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      # 如果有高危漏洞，讓 workflow 失敗
      - name: Check for critical vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          exit-code: '1'              # 發現漏洞時退出碼為 1
          severity: 'CRITICAL'
```

### 4.3 理解 Trivy 結果

**範例輸出**：

```
┌────────────────────────────────────────────────────┐
│ Target: myapp:abc123                               │
│ Type: Docker Image                                 │
├────────────────────────────────────────────────────┤
│ Vulnerabilities found:                             │
│                                                    │
│ 🔴 CRITICAL: 2                                     │
│ 🟠 HIGH:     5                                     │
│ 🟡 MEDIUM:   12                                    │
│ 🟢 LOW:      23                                    │
├────────────────────────────────────────────────────┤
│ Details:                                           │
│                                                    │
│ 1. CVE-2023-12345 (CRITICAL)                       │
│    Package: openssl                                │
│    Version: 1.1.1k                                 │
│    Fixed:   1.1.1w                                 │
│    Description: Buffer overflow in SSL handshake   │
│                                                    │
│ 2. CVE-2023-54321 (HIGH)                           │
│    Package: curl                                   │
│    Version: 7.68.0                                 │
│    Fixed:   7.88.0                                 │
│    Description: MITM vulnerability in proxy        │
└────────────────────────────────────────────────────┘
```

### 4.4 修復容器漏洞

**策略 1：更新基礎映像**

```dockerfile
# ❌ 舊的映像可能有漏洞
FROM python:3.11-slim

# ✅ 使用最新的穩定版
FROM python:3.11.6-slim-bookworm

# ✅ 更好：使用 digest（確保可重現）
FROM python:3.11.6-slim-bookworm@sha256:abc123...
```

**策略 2：最小化映像**

```dockerfile
# ❌ 包含不必要的套件
FROM python:3.11

# ✅ 使用 slim 版本
FROM python:3.11-slim

# ✅ 更好：使用 alpine（最小）
FROM python:3.11-alpine

# ✅ 最好：使用 distroless（無 shell）
FROM gcr.io/distroless/python3-debian11
```

**策略 3：多階段建立**

```dockerfile
# 階段 1：建立（包含建立工具）
FROM python:3.11 AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

# 階段 2：執行（最小化）
FROM python:3.11-slim
WORKDIR /app

# 只複製需要的檔案
COPY --from=builder /root/.local /root/.local
COPY . .

ENV PATH=/root/.local/bin:$PATH
CMD ["uvicorn", "app.main:app"]
```

**掃描結果對比**：

```
完整映像（python:3.11）：
  Size: 1.2 GB
  Vulnerabilities: 47 (5 Critical, 12 High)

Slim 映像（python:3.11-slim）：
  Size: 450 MB
  Vulnerabilities: 23 (2 Critical, 5 High)

Distroless：
  Size: 180 MB
  Vulnerabilities: 8 (0 Critical, 1 High)
```

---

## 5. AI 輔助漏洞修復

### 5.1 GitHub Copilot Autofix

**什麼是 Copilot Autofix？**

> GitHub Copilot 的自動修復功能，能分析 CodeQL 發現的漏洞，並自動生成修復建議。

**啟用方式**（需要 GitHub Enterprise 或 Copilot Business）：

1. CodeQL 掃描發現漏洞
2. 在 Security tab 查看詳情
3. 點選 **"Generate fix with Copilot"**
4. Copilot 分析問題並提供修復 PR

**範例：自動修復 SQL 注入**

**原始代碼（有漏洞）**：

```python
@app.get("/users/{user_id}")
def get_user(user_id: str):
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    result = db.execute(query)
    return result
```

**Copilot Autofix 生成的修復**：

```python
@app.get("/users/{user_id}")
def get_user(user_id: str):
    # ✅ 使用參數化查詢
    query = "SELECT * FROM users WHERE id = :user_id"
    result = db.execute(query, {"user_id": user_id})
    return result
```

**附帶說明**：
```
🤖 Copilot Autofix

Issue: SQL injection vulnerability
Fix: Use parameterized query to prevent SQL injection

Changes:
- Replaced string formatting with parameterized query
- Added parameter binding for user_id

Security impact:
✅ Prevents SQL injection attacks
✅ Properly escapes user input
✅ Maintains functionality
```

### 5.2 用 Claude 修復漏洞（手動但更靈活）

**情境：Snyk 發現 XSS 漏洞**

**提示詞範本**：

```
Snyk 在我的 FastAPI 應用中發現一個 XSS（跨站腳本）漏洞：

[貼上 Snyk 報告]

Location: app/api/posts.py, Line 34

Code:
@app.post("/posts")
def create_post(content: str):
    return HTMLResponse(f"<div>{content}</div>")

請幫我：
1. 解釋這個漏洞的原理
2. 提供安全的修復方案
3. 給出完整的修復後代碼
```

**Claude 的回應範例**：

````markdown
## 漏洞分析

這是一個典型的 **Reflected XSS（反射型跨站腳本）** 漏洞。

**攻擊原理**：
用戶輸入 `content = "<script>alert('XSS')</script>"`
→ 直接嵌入 HTML 中
→ 瀏覽器執行惡意腳本

**風險**：
- 竊取 Cookie（session hijacking）
- 竊取用戶資料
- 執行惡意操作

## 修復方案

有三種方法，推薦第 1 種：

### 方法 1：使用模板引擎的自動轉義（推薦）

```python
from fastapi import FastAPI
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse

app = FastAPI()
templates = Jinja2Templates(directory="templates")

@app.post("/posts")
def create_post(content: str, request: Request):
    # Jinja2 預設會自動轉義 HTML
    return templates.TemplateResponse(
        "post.html",
        {"request": request, "content": content}
    )
```

`templates/post.html`:
```html
<!-- content 會被自動轉義 -->
<div>{{ content }}</div>
```

### 方法 2：手動轉義 HTML

```python
from html import escape
from fastapi.responses import HTMLResponse

@app.post("/posts")
def create_post(content: str):
    # 手動轉義特殊字元
    safe_content = escape(content)
    return HTMLResponse(f"<div>{safe_content}</div>")
```

### 方法 3：使用 Content Security Policy（CSP）

```python
from fastapi.responses import HTMLResponse

@app.post("/posts")
def create_post(content: str):
    safe_content = escape(content)
    response = HTMLResponse(f"<div>{safe_content}</div>")

    # 加入 CSP header
    response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'none'"
    return response
```

## 驗證修復

測試用例：
```python
def test_xss_prevention():
    malicious_input = "<script>alert('XSS')</script>"
    response = client.post("/posts", json={"content": malicious_input})

    # 應該看到轉義後的文字，而非執行腳本
    assert "&lt;script&gt;" in response.text
    assert "<script>" not in response.text
```
````

### 5.3 完整的修復工作流程

**標準流程**：

```
1. 自動掃描發現漏洞
   ↓
2. 評估嚴重性
   ├─ Critical → 立即修復（4 小時內）
   ├─ High     → 當天修復
   ├─ Medium   → 本週修復
   └─ Low      → 排程修復
   ↓
3. 理解漏洞原理
   - 閱讀 CVE 詳情
   - 了解攻擊場景
   ↓
4. 嘗試 AI 自動修復
   - 使用 Copilot Autofix（如果有）
   - 或用 Claude 生成修復方案
   ↓
5. 人工審查修復方案
   - 確保修復正確
   - 檢查是否有副作用
   ↓
6. 撰寫測試驗證
   - 驗證漏洞已修復
   - 確保功能正常
   ↓
7. 部署到測試環境
   - 執行完整測試套件
   - 進行安全測試
   ↓
8. 部署到生產環境
   ↓
9. 記錄學習
   - 更新安全檢查清單
   - 分享給團隊
```

---

## 6. 實戰：建立完整安全掃描管線

### 6.1 情境描述

為一個 Python FastAPI 專案建立完整的安全掃描管線：
1. CodeQL 靜態分析
2. Snyk 依賴掃描
3. Trivy 容器掃描
4. 自動阻止有漏洞的 PR

### 6.2 完整 Workflow 配置

```yaml
# .github/workflows/security-scan.yml
name: Security Scan Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * 1'  # 每週一凌晨 2 點

jobs:
  # Job 1: CodeQL 靜態分析
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python
          queries: security-extended

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2

  # Job 2: Snyk 依賴掃描
  snyk:
    name: Snyk Dependency Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run Snyk test
        uses: snyk/actions/python-3.10@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
          command: test

      - name: Run Snyk monitor
        if: github.event_name == 'push'
        uses: snyk/actions/python-3.10@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: monitor

  # Job 3: 建立 Docker 映像
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Save image
        run: |
          docker save myapp:${{ github.sha }} > myapp.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v3
        with:
          name: docker-image
          path: myapp.tar

  # Job 4: Trivy 容器掃描
  trivy:
    name: Trivy Container Scan
    needs: build-docker
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v3
        with:
          name: docker-image

      - name: Load image
        run: |
          docker load < myapp.tar

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Fail on critical vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          exit-code: '1'
          severity: 'CRITICAL'

  # Job 5: 安全報告總結
  security-summary:
    name: Security Summary
    needs: [codeql, snyk, trivy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate security summary
        run: |
          echo "## Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Scanner | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| CodeQL  | ${{ needs.codeql.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Snyk    | ${{ needs.snyk.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trivy   | ${{ needs.trivy.result }} |" >> $GITHUB_STEP_SUMMARY

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## 🔒 Security Scan Results

              - CodeQL: ${{ needs.codeql.result }}
              - Snyk: ${{ needs.snyk.result }}
              - Trivy: ${{ needs.trivy.result }}

              Please review the security findings before merging.`
            })
```

### 6.3 執行流程圖

```
Trigger (push/PR)
        │
        ├───────────┬───────────┬─────────────┐
        ↓           ↓           ↓             ↓
     CodeQL       Snyk     build-docker   (並行)
     (5 min)     (3 min)     (2 min)
        │           │           │
        │           │           ↓
        │           │        Trivy
        │           │        (2 min)
        │           │           │
        └───────────┴───────────┘
                    ↓
           security-summary
                    ↓
              生成報告
                    ↓
           PR 自動評論
```

### 6.4 PR 保護規則設定

**設定 Branch Protection**：

1. `Settings` → `Branches` → `Branch protection rules`
2. 選擇 `main` 分支
3. 啟用以下設定：

```
✅ Require status checks to pass before merging
   ✅ CodeQL Analysis
   ✅ Snyk Dependency Scan
   ✅ Trivy Container Scan

✅ Require branches to be up to date before merging

✅ Require approvals (1)

✅ Dismiss stale pull request approvals
```

**結果**：只有通過所有安全掃描的 PR 才能合併！

---

## 7. 安全治理策略

### 7.1 建立安全政策

**建立 SECURITY.md**：

```markdown
# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| 1.x     | :white_check_mark: |
| < 1.0   | :x:                |

## Vulnerability Severity

We follow this classification:

- **CRITICAL**: Remote code execution, data breach
  - Fix within: 24 hours
  - Required: Immediate patch release

- **HIGH**: Authentication bypass, privilege escalation
  - Fix within: 1 week
  - Required: Next patch release

- **MEDIUM**: XSS, CSRF, information disclosure
  - Fix within: 1 month
  - Required: Next minor release

- **LOW**: Minor issues with low impact
  - Fix within: Next major release

## Reporting a Vulnerability

Please report vulnerabilities to security@example.com

Do NOT open public GitHub issues for security vulnerabilities.

We will respond within 48 hours.
```

### 7.2 定期安全審查

**每週安全檢查清單**：

```markdown
## Weekly Security Checklist

- [ ] 檢查 Dependabot alerts
- [ ] 檢查 CodeQL findings
- [ ] 檢查 Snyk dashboard
- [ ] 更新高危漏洞的套件
- [ ] 審查新的 CVE 公告
```

**每月安全審查**：

```markdown
## Monthly Security Review

- [ ] 檢閱所有開放的安全問題
- [ ] 更新基礎 Docker 映像
- [ ] 審查權限設定
- [ ] 檢查 Secrets 使用情況
- [ ] 更新安全文件
```

### 7.3 安全儀表板

**建立安全指標追蹤**：

```
┌─────────────────────────────────────────┐
│ Security Dashboard (2024-10-30)         │
├─────────────────────────────────────────┤
│ 🔴 Critical Vulnerabilities:  0         │
│ 🟠 High Vulnerabilities:      2         │
│ 🟡 Medium Vulnerabilities:    8         │
│ 🟢 Low Vulnerabilities:      15         │
├─────────────────────────────────────────┤
│ Mean Time to Fix (MTTF):                │
│   Critical: 8 hours                     │
│   High:     2 days                      │
│   Medium:   1 week                      │
├─────────────────────────────────────────┤
│ Recent Fixes:                           │
│   ✅ CVE-2024-1234 (High) - Fixed       │
│   ✅ CVE-2024-5678 (Medium) - Fixed     │
│   ⏳ CVE-2024-9012 (High) - In progress │
└─────────────────────────────────────────┘
```

---

## 8. 最佳實踐與常見陷阱

### 8.1 最佳實踐

#### ✅ 1. 多層防禦

```
不要只依賴一種掃描工具！

CodeQL：   程式碼邏輯漏洞
Snyk:      依賴漏洞
Trivy:     容器漏洞
人工審查：  業務邏輯漏洞

層層把關，互補不足
```

#### ✅ 2. 盡早掃描，盡快修復

```yaml
# ❌ 不好：只在發布時掃描
on:
  release:
    types: [published]

# ✅ 好：每次提交都掃描
on:
  push:
  pull_request:
```

#### ✅ 3. 自動化修復流程

```
1. Dependabot 自動建立更新 PR
2. 測試自動執行
3. 通過後自動合併（補丁版本）
4. 自動部署到測試環境
5. 人工審查後部署到生產環境
```

#### ✅ 4. 設定明確的 SLA

```
Critical: 24 小時內修復
High:     1 週內修復
Medium:   1 月內修復
Low:      下次大版本修復
```

#### ✅ 5. 建立安全文化

```
- 定期安全培訓
- 分享安全事件學習
- 獎勵發現安全問題
- 無責怪文化（鼓勵報告）
```

### 8.2 常見陷阱

#### ❌ 1. 忽略低危漏洞

```
錯誤想法：「Low severity 不用管」

現實：多個 Low 漏洞組合可能變成 Critical

正確做法：定期清理，不要累積
```

#### ❌ 2. 過度依賴自動化

```
自動掃描找不到：
- 業務邏輯漏洞
- 權限設計問題
- 複雜的時序攻擊

需要人工安全審查！
```

#### ❌ 3. 修復後不驗證

```yaml
# ❌ 錯誤：修復後沒有測試
- fix vulnerability
- merge PR
# 可能引入新問題！

# ✅ 正確：加入驗證測試
- fix vulnerability
- add security test
- verify fix
- merge PR
```

#### ❌ 4. Secret 管理不當

```yaml
# ❌ 危險
- run: echo "API_KEY=abc123" >> .env

# ✅ 安全
- run: echo "API_KEY=${{ secrets.API_KEY }}" >> .env
```

---

## 9. 本章總結

### 9.1 核心概念回顧

**為什麼安全掃描重要？**
- 40% AI 代碼含安全問題
- Code Churn 翻倍
- 攻擊面增加

**三層防禦**：
1. **CodeQL**：靜態分析（程式碼邏輯）
2. **Snyk/Dependabot**：依賴掃描（第三方套件）
3. **Trivy**：容器掃描（Docker 映像）

**AI 輔助修復**：
- GitHub Copilot Autofix（自動）
- Claude 分析修復（靈活）

### 9.2 學習檢查點

完成本章後，確認你能夠：

- [ ] 說明 AI 時代安全掃描的重要性（40% 問題率）
- [ ] 配置 CodeQL 靜態分析
- [ ] 設定 Snyk 或 Dependabot 依賴掃描
- [ ] 使用 Trivy 掃描 Docker 映像
- [ ] 理解不同工具的適用場景
- [ ] 用 AI 輔助漏洞修復
- [ ] 建立完整的安全掃描管線
- [ ] 設定 PR 保護規則

### 9.3 實戰建議

**立即行動**：
1. 為你的專案啟用 CodeQL
2. 設定 Dependabot alerts
3. 如果使用 Docker，加入 Trivy 掃描

**進階學習**：
- 深入學習常見漏洞類型（OWASP Top 10）
- 練習用 AI 修復漏洞
- 建立團隊安全規範

### 9.4 下一步

完成安全掃描後，下一章將探討：

**5.3 自動化部署策略（補充閱讀）**：
- 藍綠部署 vs 金絲雀部署
- Docker 容器化部署
- 回退與災難恢復

---

**安全永遠是第一要務！** 繼續前往 `5.3_自動化部署策略.md` →
