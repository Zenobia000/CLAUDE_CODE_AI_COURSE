# C01：安全掃描管線建立 ⭐

## 📋 情境資訊

**難度等級**：⭐⭐ 組合級
**預估時間**：1.5-2 小時
**核心技能**：多層安全掃描、SARIF 整合、安全策略制定
**前置知識**：基礎級 B01-B06 全部完成

---

## 🎯 情境背景

你剛加入一家金融科技公司，負責建立企業級的安全掃描管線。這不是普通的 startup，而是處理金融資料的公司，安全要求極其嚴格。

**公司現況**：
- 40+ 個微服務專案
- 每天 200+ 次程式碼提交
- 處理敏感金融資料（PCI DSS 合規要求）
- 過去 6 個月發生 3 次安全事件

**上週的嚴重事故**：
```bash
# 生產環境洩露事件
日期：2024-10-25
影響：8,000 用戶個資外洩
原因：開發者在程式碼中硬編碼 API 密鑰
損失：罰金 50 萬美元 + 聲譽損失

# 事故分析
Root Cause：
1. 沒有自動化安全掃描
2. Code Review 沒有發現硬編碼密鑰
3. 靜態分析工具覆蓋度不足
4. 第三方依賴有未修復的 CVE
```

**CISO（資安長）的要求**：
> 「我們需要建立業界最強的自動化安全掃描管線。每一行程式碼、每一個依賴、每一個容器映像都必須經過嚴格的安全檢查才能進入生產環境。」

**具體要求**：
- **Zero Trust**：假設所有程式碼都有問題
- **多層防禦**：至少 5 種不同的安全掃描工具
- **即時阻擋**：發現高危漏洞立即停止 pipeline
- **合規報告**：產生符合 SOC 2、PCI DSS 的安全報告
- **開發者友善**：提供明確的修復指導

**你的任務**：
設計並實作企業級的多層安全掃描管線，涵蓋靜態分析、依賴掃描、容器安全、密鑰偵測等多個面向。

---

## 📦 專案結構

這是一個複雜的 FinTech 專案：

```
fintech-payment-service/
├── backend/                           # 後端服務
│   ├── src/
│   │   ├── auth/                     # 認證模組
│   │   ├── payments/                 # 支付處理
│   │   ├── encryption/               # 加密模組
│   │   └── database/                 # 資料庫操作
│   ├── requirements.txt
│   └── Dockerfile
│
├── frontend/                          # 前端應用
│   ├── src/
│   │   ├── components/
│   │   ├── services/
│   │   └── utils/
│   ├── package.json
│   └── Dockerfile
│
├── infrastructure/                    # 基礎設施代碼
│   ├── terraform/
│   ├── kubernetes/
│   └── helm/
│
├── scripts/                          # 自動化腳本
│   ├── security/
│   └── deployment/
│
├── .github/
│   ├── workflows/
│   │   ├── security-scan.yml        # 主要安全掃描 workflow
│   │   ├── dependency-check.yml     # 依賴安全檢查
│   │   └── container-scan.yml       # 容器安全掃描
│   │
│   └── security/                     # 安全配置
│       ├── codeql-config.yml
│       ├── semgrep-rules.yml
│       └── security-policy.md
│
├── security/                         # 安全相關檔案
│   ├── policies/                     # 安全政策
│   ├── reports/                      # 掃描報告模板
│   └── exceptions/                   # 例外清單
│
└── docs/
    ├── security-guidelines.md
    └── incident-response.md
```

**有安全問題的範例程式碼**：

```python
# backend/src/payments/processor.py
import hashlib
import requests
from cryptography.fernet import Fernet

class PaymentProcessor:
    def __init__(self):
        # ❌ 硬編碼密鑰（Critical 漏洞）
        self.encryption_key = "gAAAAABhZ6J_secretkey12345"
        self.api_key = "sk_live_51234567890abcdef"

        # ❌ 弱雜湊算法（High 漏洞）
        self.hash_algo = hashlib.md5

        # ❌ 不安全的隨機數生成（Medium 漏洞）
        import random
        self.session_id = random.randint(1000, 9999)

    def process_payment(self, card_number, amount):
        # ❌ SQL 注入風險（Critical 漏洞）
        query = f"SELECT * FROM payments WHERE card='{card_number}'"

        # ❌ 不安全的 HTTP 請求（High 漏洞）
        response = requests.get(
            f"http://payment-api.com/charge",
            params={"amount": amount, "card": card_number},
            verify=False  # ❌ 忽略 SSL 驗證
        )

        return response.json()

    def log_transaction(self, data):
        # ❌ 敏感資料記錄（High 漏洞）
        print(f"Processing payment: {data}")  # 可能包含卡號
```

```javascript
// frontend/src/services/api.js
// ❌ 前端硬編碼 API 密鑰（Critical 漏洞）
const API_KEY = 'pk_live_abcdef123456789';

// ❌ 不安全的 localStorage 使用（Medium 漏洞）
const AuthService = {
    login: (credentials) => {
        // ❌ 密碼明文傳輸（High 漏洞）
        fetch('http://api.example.com/login', {
            method: 'POST',
            body: JSON.stringify(credentials), // 沒有加密
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': API_KEY
            }
        }).then(response => {
            // ❌ 不安全的本地儲存（Medium 漏洞）
            localStorage.setItem('authToken', response.data.token);
            localStorage.setItem('userPassword', credentials.password);
        });
    }
};

// ❌ XSS 風險（High 漏洞）
function displayMessage(message) {
    document.getElementById('output').innerHTML = message;
}
```

---

## 🎯 任務目標

### 必達目標（核心要求）
1. ✅ 建立 **5 層安全掃描**：
   - Layer 1: 靜態程式碼分析（CodeQL + Semgrep）
   - Layer 2: 依賴漏洞掃描（Snyk + OWASP Dependency Check）
   - Layer 3: 密鑰和敏感資料偵測（GitLeaks + TruffleHog）
   - Layer 4: 容器映像掃描（Trivy + Grype）
   - Layer 5: 基礎設施即程式碼掃描（Checkov + Terrascan）

2. ✅ 實作 **漏洞等級管控**：
   - Critical: 立即阻止 pipeline
   - High: 阻止但允許例外核准
   - Medium: 警告但允許繼續
   - Low: 記錄但不阻止

3. ✅ 建立 **SARIF 報告整合**：
   - 統一報告格式
   - GitHub Security tab 整合
   - 可視化安全儀表板

4. ✅ 設計 **安全政策引擎**：
   - 可配置的安全規則
   - 例外管理機制
   - 合規報告生成

### 加分項目（進階要求）
- 🌟 整合 **AI 輔助漏洞修復**（GitHub Copilot Autofix）
- 🌟 建立 **安全指標追蹤**（安全債務、修復時間）
- 🌟 實作 **即時安全監控**（Webhook 通知）
- 🌟 設計 **安全培訓整合**（自動分派學習資源）

---

## 📚 學習檢查點

完成此情境題時，請確認你能回答：

### Checkpoint 1：企業安全策略
- [ ] 什麼是 Zero Trust 安全模型？如何在 CI/CD 中實作？
- [ ] PCI DSS 和 SOC 2 對程式碼安全有什麼要求？
- [ ] 如何設計多層安全防禦策略？
- [ ] 什麼是安全左移（Shift Security Left）？

### Checkpoint 2：安全掃描工具生態
- [ ] CodeQL vs Semgrep vs SonarQube 的差異和適用場景？
- [ ] SAST、DAST、IAST、SCA 分別是什麼？
- [ ] SARIF 格式的優勢和用途？
- [ ] 如何選擇和組合不同的安全工具？

### Checkpoint 3：企業級實作挑戰
- [ ] 如何處理大量誤報（False Positive）？
- [ ] 如何平衡安全性和開發效率？
- [ ] 如何管理安全例外和風險接受？
- [ ] 如何建立安全指標和 KPI？

---

## 🚀 實作步驟

### 步驟 1：安全掃描架構設計

首先設計完整的安全掃描架構：

```yaml
# .github/workflows/security-comprehensive.yml
name: Comprehensive Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'  # 每日深度掃描
  workflow_dispatch:
    inputs:
      scan_level:
        description: 'Security scan level'
        required: true
        default: 'standard'
        type: choice
        options:
          - quick
          - standard
          - comprehensive

env:
  SECURITY_SCAN_LEVEL: ${{ github.event.inputs.scan_level || 'standard' }}

jobs:
  # 安全掃描協調器
  security-orchestrator:
    name: Security Scan Orchestrator
    runs-on: ubuntu-latest
    outputs:
      scan-matrix: ${{ steps.matrix.outputs.matrix }}
      should-run-comprehensive: ${{ steps.decide.outputs.comprehensive }}

    steps:
    - name: Determine scan strategy
      id: decide
      run: |
        case "$SECURITY_SCAN_LEVEL" in
          "quick")
            echo "comprehensive=false" >> $GITHUB_OUTPUT
            ;;
          "comprehensive")
            echo "comprehensive=true" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "comprehensive=${{ github.event_name == 'schedule' }}" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Generate scan matrix
      id: matrix
      run: |
        if [ "${{ steps.decide.outputs.comprehensive }}" = "true" ]; then
          MATRIX='[
            {"tool": "codeql", "languages": ["python", "javascript"], "queries": "security-extended"},
            {"tool": "semgrep", "config": "auto", "rules": "security,secrets"},
            {"tool": "snyk", "type": "code,deps,docker", "severity": "medium"},
            {"tool": "gitleaks", "config": "extended", "rules": "all"},
            {"tool": "trivy", "scanners": "vuln,secret,config", "severity": "medium"},
            {"tool": "checkov", "frameworks": "terraform,kubernetes", "check": "CKV_*"}
          ]'
        else
          MATRIX='[
            {"tool": "codeql", "languages": ["python", "javascript"], "queries": "security-only"},
            {"tool": "semgrep", "config": "auto", "rules": "security"},
            {"tool": "snyk", "type": "deps", "severity": "high"}
          ]'
        fi

        echo "matrix=$(echo $MATRIX | jq -c .)" >> $GITHUB_OUTPUT

  # Layer 1: 靜態程式碼分析
  static-analysis:
    name: Layer 1 - Static Code Analysis
    needs: security-orchestrator
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read

    strategy:
      matrix:
        include: ${{ fromJson(needs.security-orchestrator.outputs.scan-matrix) }}
      fail-fast: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 完整歷史記錄（某些工具需要）

    # CodeQL 掃描
    - name: Initialize CodeQL
      if: matrix.tool == 'codeql'
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ join(matrix.languages, ',') }}
        queries: ${{ matrix.queries }}
        config-file: ./.github/security/codeql-config.yml

    - name: Autobuild
      if: matrix.tool == 'codeql'
      uses: github/codeql-action/autobuild@v3

    - name: Perform CodeQL Analysis
      if: matrix.tool == 'codeql'
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{ matrix.languages[0] }}"

    # Semgrep 掃描
    - name: Run Semgrep
      if: matrix.tool == 'semgrep'
      uses: semgrep/semgrep-action@v1
      with:
        config: ${{ matrix.config }}
        generateSarif: "1"
      env:
        SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

    # Snyk 程式碼掃描
    - name: Run Snyk Code
      if: matrix.tool == 'snyk' && contains(matrix.type, 'code')
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --sarif-file-output=snyk-code.sarif --severity-threshold=${{ matrix.severity }}
        command: code test

    # 上傳 SARIF 結果
    - name: Upload SARIF results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: "*.sarif"
        category: "${{ matrix.tool }}"

  # Layer 2: 依賴安全掃描
  dependency-security:
    name: Layer 2 - Dependency Security
    needs: security-orchestrator
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    # Python 依賴掃描
    - name: Python dependency scan
      run: |
        pip install safety pip-audit

        echo "🔍 Running safety check..."
        safety check --json --output safety-report.json || true

        echo "🔍 Running pip-audit..."
        pip-audit --format=json --output=pip-audit-report.json || true

    # Node.js 依賴掃描
    - name: Node.js dependency scan
      if: hashFiles('**/package.json') != ''
      run: |
        cd frontend
        npm audit --audit-level moderate --json > npm-audit-report.json || true

    # OWASP Dependency Check
    - name: OWASP Dependency Check
      if: needs.security-orchestrator.outputs.should-run-comprehensive == 'true'
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'fintech-payment-service'
        path: '.'
        format: 'ALL'
        args: >
          --enableRetired
          --enableExperimental
          --nvdApiKey ${{ secrets.NVD_API_KEY }}

    # Snyk 依賴掃描
    - name: Snyk dependency scan
      uses: snyk/actions/python-3.10@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=medium --json-file-output=snyk-deps.json
        command: test

    # 分析依賴掃描結果
    - name: Analyze dependency scan results
      run: |
        python3 << 'EOF'
        import json
        import os

        reports = {
            'safety': 'safety-report.json',
            'pip-audit': 'pip-audit-report.json',
            'npm-audit': 'frontend/npm-audit-report.json',
            'snyk': 'snyk-deps.json'
        }

        total_vulns = 0
        critical_vulns = 0
        high_vulns = 0

        for tool, report_file in reports.items():
            if os.path.exists(report_file):
                try:
                    with open(report_file, 'r') as f:
                        data = json.load(f)

                    # 根據不同工具解析漏洞數量
                    tool_vulns = 0
                    if tool == 'safety' and isinstance(data, list):
                        tool_vulns = len(data)
                        critical_vulns += len([v for v in data if v.get('severity') == 'critical'])
                        high_vulns += len([v for v in data if v.get('severity') == 'high'])
                    elif tool == 'snyk' and 'vulnerabilities' in data:
                        tool_vulns = len(data['vulnerabilities'])
                        critical_vulns += len([v for v in data['vulnerabilities'] if v.get('severity') == 'critical'])
                        high_vulns += len([v for v in data['vulnerabilities'] if v.get('severity') == 'high'])

                    total_vulns += tool_vulns
                    print(f"{tool}: {tool_vulns} vulnerabilities")

                except Exception as e:
                    print(f"Error parsing {tool} report: {e}")

        print(f"\nTotal vulnerabilities: {total_vulns}")
        print(f"Critical: {critical_vulns}")
        print(f"High: {high_vulns}")

        # 設定環境變數供後續步驟使用
        with open(os.environ['GITHUB_ENV'], 'a') as f:
            f.write(f"TOTAL_VULNS={total_vulns}\n")
            f.write(f"CRITICAL_VULNS={critical_vulns}\n")
            f.write(f"HIGH_VULNS={high_vulns}\n")

        # 根據企業安全政策決定是否失敗
        if critical_vulns > 0:
            print("❌ CRITICAL vulnerabilities found - blocking pipeline")
            exit(1)
        elif high_vulns > 5:  # 可配置的閾值
            print("⚠️ Too many HIGH vulnerabilities - requires security team approval")
            exit(1)
        EOF

    # 上傳依賴掃描報告
    - name: Upload dependency reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: dependency-security-reports
        path: |
          *-report.json
          reports/

  # Layer 3: 密鑰和敏感資料偵測
  secrets-detection:
    name: Layer 3 - Secrets Detection
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # GitLeaks 掃描
    - name: Run GitLeaks
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

    # TruffleHog 掃描
    - name: TruffleHog OSS
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: main
        head: HEAD
        extra_args: --debug --only-verified

    # 自訂密鑰模式掃描
    - name: Custom secrets scan
      run: |
        echo "🔍 Running custom secrets patterns..."

        # 定義金融行業特有的敏感模式
        python3 << 'EOF'
        import re
        import os
        import json

        # 金融業常見的敏感模式
        patterns = {
            'credit_card': r'\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})\b',
            'bank_account': r'\b[0-9]{8,17}\b',
            'ssn': r'\b(?!000)(?!666)(?:[0-6]\d{2}|7[0-6]\d|77[0-2])(?!00)\d{2}(?!0000)\d{4}\b',
            'api_key_stripe': r'sk_live_[0-9a-zA-Z]{24}',
            'api_key_generic': r'[a-zA-Z0-9]{32,}',
            'jwt_token': r'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*',
            'private_key': r'-----BEGIN [A-Z]+ PRIVATE KEY-----',
        }

        findings = []

        for root, dirs, files in os.walk('.'):
            # 跳過 .git 和 node_modules
            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__']]

            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.jsx', '.tsx', '.json', '.yml', '.yaml')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()

                        for pattern_name, pattern in patterns.items():
                            matches = re.finditer(pattern, content, re.IGNORECASE)
                            for match in matches:
                                line_num = content[:match.start()].count('\n') + 1
                                findings.append({
                                    'file': file_path,
                                    'line': line_num,
                                    'pattern': pattern_name,
                                    'match': match.group()[:20] + '...' if len(match.group()) > 20 else match.group()
                                })
                    except Exception as e:
                        continue

        if findings:
            print(f"❌ Found {len(findings)} potential secrets:")
            for finding in findings:
                print(f"  {finding['file']}:{finding['line']} - {finding['pattern']}: {finding['match']}")

            # 儲存結果
            with open('custom-secrets-report.json', 'w') as f:
                json.dump(findings, f, indent=2)

            # 根據企業政策決定是否阻止
            critical_patterns = ['credit_card', 'bank_account', 'ssn', 'private_key']
            critical_findings = [f for f in findings if f['pattern'] in critical_patterns]

            if critical_findings:
                print("❌ Critical secrets found - blocking pipeline")
                exit(1)
        else:
            print("✅ No secrets detected")
        EOF

  # Layer 4: 容器安全掃描
  container-security:
    name: Layer 4 - Container Security
    runs-on: ubuntu-latest
    if: hashFiles('**/Dockerfile') != ''

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # 建構映像用於掃描
    - name: Build images for scanning
      run: |
        docker build -t backend-scan:latest ./backend
        docker build -t frontend-scan:latest ./frontend

    # Trivy 容器掃描
    - name: Run Trivy scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'backend-scan:latest'
        format: 'sarif'
        output: 'trivy-backend.sarif'

    - name: Run Trivy scan (Frontend)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'frontend-scan:latest'
        format: 'sarif'
        output: 'trivy-frontend.sarif'

    # Grype 容器掃描（額外層級）
    - name: Run Grype scan
      if: needs.security-orchestrator.outputs.should-run-comprehensive == 'true'
      uses: anchore/scan-action@v3
      with:
        image: "backend-scan:latest"
        fail-build: false
        acs-report-enable: true

    # Docker Bench 安全檢查
    - name: Docker Bench Security
      if: needs.security-orchestrator.outputs.should-run-comprehensive == 'true'
      run: |
        docker run --rm --net host --pid host --userns host --cap-add audit_control \
          -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
          -v /etc:/etc:ro \
          -v /usr/bin/docker-containerd:/usr/bin/docker-containerd:ro \
          -v /usr/bin/docker-runc:/usr/bin/docker-runc:ro \
          -v /usr/lib/systemd:/usr/lib/systemd:ro \
          -v /var/lib:/var/lib:ro \
          -v /var/run/docker.sock:/var/run/docker.sock:ro \
          --label docker_bench_security \
          docker/docker-bench-security

    # 上傳容器掃描結果
    - name: Upload container scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: trivy-*.sarif

  # Layer 5: 基礎設施即程式碼掃描
  infrastructure-security:
    name: Layer 5 - Infrastructure Security
    runs-on: ubuntu-latest
    if: hashFiles('infrastructure/**') != ''

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Checkov 掃描
    - name: Run Checkov
      uses: bridgecrewio/checkov-action@master
      with:
        directory: infrastructure/
        framework: terraform,kubernetes,dockerfile
        output_format: sarif
        output_file_path: checkov-report.sarif

    # Terrascan 掃描
    - name: Run Terrascan
      uses: tenable/terrascan-action@main
      with:
        iac_type: 'terraform'
        iac_dir: 'infrastructure/terraform'
        policy_type: 'all'
        only_warn: true
        sarif_upload: true

    # Kubesec 掃描 Kubernetes 配置
    - name: Run Kubesec
      if: hashFiles('infrastructure/kubernetes/**') != ''
      run: |
        docker run --rm -v $PWD:/app kubesec/kubesec:latest scan /app/infrastructure/kubernetes/*.yaml > kubesec-report.json

  # 安全報告彙總
  security-summary:
    name: Security Summary & Policy Enforcement
    needs: [static-analysis, dependency-security, secrets-detection, container-security, infrastructure-security]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v3

    - name: Generate comprehensive security report
      run: |
        echo "# 🛡️ Comprehensive Security Scan Report" > security-summary.md
        echo "" >> security-summary.md
        echo "**Scan Date:** $(date -u)" >> security-summary.md
        echo "**Commit:** ${{ github.sha }}" >> security-summary.md
        echo "**Branch:** ${{ github.ref_name }}" >> security-summary.md
        echo "" >> security-summary.md

        # 彙總各層級的結果
        echo "## 📊 Security Layers Summary" >> security-summary.md
        echo "" >> security-summary.md
        echo "| Layer | Tool | Status | Critical | High | Medium | Low |" >> security-summary.md
        echo "|-------|------|--------|----------|------|--------|-----|" >> security-summary.md

        # 處理各種報告格式並彙總
        python3 << 'EOF'
        import json
        import os
        import glob

        # 彙總邏輯會根據實際報告格式實作
        print("Processing security reports...")

        # 檢查是否有阻斷性問題
        total_critical = int(os.getenv('CRITICAL_VULNS', 0))
        total_high = int(os.getenv('HIGH_VULNS', 0))

        if total_critical > 0:
            print(f"❌ Found {total_critical} CRITICAL vulnerabilities - Pipeline BLOCKED")
            exit(1)
        elif total_high > 10:  # 企業政策：超過 10 個高危漏洞需要安全團隊核准
            print(f"⚠️ Found {total_high} HIGH vulnerabilities - Requires security approval")
            # 在實際環境中，這裡會觸發安全團隊審核流程
        else:
            print("✅ Security scan passed enterprise policy")
        EOF

    - name: Generate step summary
      if: always()
      run: |
        if [ -f security-summary.md ]; then
          cat security-summary.md >> $GITHUB_STEP_SUMMARY
        fi

    # 發送給安全團隊的詳細報告
    - name: Send security report to team
      if: env.CRITICAL_VULNS > 0 || env.HIGH_VULNS > 5
      uses: actions/github-script@v6
      with:
        script: |
          // 在實際環境中，這裡會發送到 Slack/Teams/Email
          console.log('Security alert sent to security team');

```

由於這是一個非常複雜的企業級安全掃描管線，我建議在實際實作時：

1. **分階段實施**：先從基礎的 2-3 種工具開始，逐步增加
2. **調整閾值**：根據專案的實際情況調整漏洞容忍度
3. **工具整合**：確保各種工具的版本相容性和 SARIF 格式支援
4. **效能優化**：使用平行化和快取來減少掃描時間
5. **誤報處理**：建立白名單機制處理已知的誤報

---

## ✅ 參考解答重點

### 企業級安全掃描的關鍵設計原則

1. **多層防禦**：不依賴單一工具，每層解決不同類型的安全問題
2. **智能調度**：根據變更範圍和風險等級選擇掃描深度
3. **政策驱動**：安全規則可配置，支援不同專案和合規要求
4. **開發者友善**：提供清楚的修復指導，不只是問題清單

### 成功標準

完成此情境題後，你應該能夠：
- ✅ 設計企業級的多層安全掃描架構
- ✅ 整合至少 5 種不同類型的安全工具
- ✅ 建立基於風險的安全政策引擎
- ✅ 生成符合合規要求的安全報告
- ✅ 實作自動化的安全例外管理

---

**恭喜完成 C01！** 這是組合級情境中最複雜的一個，如果你能完成這個挑戰，就已經具備了企業級 DevSecOps 工程師的核心技能。

**下一步**：繼續挑戰其他組合級情境，或者根據你的實際需求選擇相關的進階主題。