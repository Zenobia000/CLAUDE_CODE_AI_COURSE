# C02：多環境部署策略

## 📋 情境資訊

**難度等級**：⭐⭐ 組合級
**預估時間**：2 小時
**核心技能**：多環境管理、部署策略、環境配置、回退機制
**前置知識**：基礎級 B01-B06，建議先完成 C01

---

## 🎯 情境背景

你剛加入一家快速成長的 SaaS 公司，負責改善他們混亂的部署流程。目前公司有 3 個環境，但部署方式各不相同，經常出問題。

**公司現況**：
- **開發環境（Dev）**：開發者本機 + 共用 staging server
- **測試環境（Staging）**：手動部署，經常和生產環境不一致
- **生產環境（Production）**：只有 CTO 有權限，每週五下午部署（高風險）

**上個月的部署災難**：
```bash
# 2024-10-15 週五晚上 8:00 PM
事件：生產環境部署失敗導致服務中斷 6 小時

時間軸：
17:30 - 開發完成新功能，staging 測試正常
18:00 - CTO 開始手動部署到生產環境
18:15 - 部署過程中發現環境變數配置不同
18:30 - 嘗試修復，但搞壞了資料庫連線
19:00 - 緊急回退，但沒有自動回退機制
21:00 - 加班工程師找到問題：production 用 PostgreSQL 14，staging 用 13
00:30 - 最終修復，客戶投訴不斷

損失：
- 服務中斷 6 小時
- 影響 50,000+ 用戶
- 客戶退款 $30,000
- 團隊週末加班
```

**CTO 的痛苦反思**：
> 「我們不能再這樣下去了！每次部署都像在賭博。我們需要專業的多環境部署策略，確保每個環境都一致，部署過程可預測且可回退。」

**具體要求**：
1. **環境一致性**：Dev、Staging、Production 環境盡可能一致
2. **自動化部署**：不同環境用不同策略（安全性 vs 速度）
3. **配置管理**：敏感資訊安全管理，環境差異明確控制
4. **品質門控**：每個環境都有對應的驗證標準
5. **快速回退**：任何環境出問題都能快速回退

**你的任務**：
設計並實作企業級的多環境部署策略，涵蓋環境管理、部署流程、配置管理和監控告警。

---

## 📦 專案結構

這是一個典型的 SaaS 應用：

```
saas-platform/
├── application/                       # 主應用
│   ├── backend/                      # FastAPI 後端
│   │   ├── src/
│   │   ├── requirements.txt
│   │   ├── Dockerfile
│   │   └── alembic/                  # 資料庫遷移
│   │
│   ├── frontend/                     # React 前端
│   │   ├── src/
│   │   ├── package.json
│   │   ├── Dockerfile
│   │   └── public/
│   │
│   └── worker/                       # Celery 背景任務
│       ├── src/
│       ├── requirements.txt
│       └── Dockerfile
│
├── infrastructure/                    # 基礎設施
│   ├── environments/
│   │   ├── dev/
│   │   │   ├── terraform/
│   │   │   ├── kubernetes/
│   │   │   └── config/
│   │   ├── staging/
│   │   │   ├── terraform/
│   │   │   ├── kubernetes/
│   │   │   └── config/
│   │   └── production/
│   │       ├── terraform/
│   │       ├── kubernetes/
│   │       └── config/
│   │
│   └── shared/                       # 共用基礎設施
│       ├── monitoring/
│       ├── logging/
│       └── security/
│
├── deployment/                       # 部署腳本和配置
│   ├── scripts/
│   │   ├── deploy.sh
│   │   ├── rollback.sh
│   │   ├── health-check.sh
│   │   └── database-migrate.sh
│   │
│   ├── configs/
│   │   ├── dev.env
│   │   ├── staging.env
│   │   └── production.env.template
│   │
│   └── helm-charts/
│       ├── backend/
│       ├── frontend/
│       └── worker/
│
├── .github/
│   ├── workflows/
│   │   ├── deploy-dev.yml           # 開發環境部署
│   │   ├── deploy-staging.yml       # 測試環境部署
│   │   ├── deploy-production.yml    # 生產環境部署
│   │   └── environment-sync.yml     # 環境同步檢查
│   │
│   └── environments/                # GitHub 環境配置
│       ├── development.yml
│       ├── staging.yml
│       └── production.yml
│
├── monitoring/                       # 監控配置
│   ├── prometheus/
│   ├── grafana/
│   └── alerts/
│
└── docs/
    ├── deployment-guide.md
    └── environment-setup.md
```

**環境配置範例**：

```yaml
# deployment/configs/dev.env
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG

# 資料庫配置
DATABASE_URL=postgresql://dev_user:dev_pass@localhost:5432/saas_dev
REDIS_URL=redis://localhost:6379/0

# 外部服務（使用測試版本）
STRIPE_PUBLISHABLE_KEY=pk_test_xxxxx
STRIPE_SECRET_KEY=sk_test_xxxxx
SENDGRID_API_KEY=SG.test.xxxxx

# 功能開關
FEATURE_NEW_DASHBOARD=true
FEATURE_ADVANCED_ANALYTICS=true
```

```yaml
# deployment/configs/staging.env
ENVIRONMENT=staging
DEBUG=false
LOG_LEVEL=INFO

# 資料庫配置（接近生產環境）
DATABASE_URL=postgresql://staging_user:staging_pass@staging-db:5432/saas_staging
REDIS_URL=redis://staging-redis:6379/0

# 外部服務（使用測試版本，但真實資料量）
STRIPE_PUBLISHABLE_KEY=pk_test_xxxxx
STRIPE_SECRET_KEY=sk_test_xxxxx
SENDGRID_API_KEY=SG.staging.xxxxx

# 功能開關（保守測試）
FEATURE_NEW_DASHBOARD=true
FEATURE_ADVANCED_ANALYTICS=false

# 效能設定
GUNICORN_WORKERS=2
CELERY_WORKERS=2
```

```yaml
# deployment/configs/production.env.template
ENVIRONMENT=production
DEBUG=false
LOG_LEVEL=WARNING

# 資料庫配置（從 Secrets 注入）
DATABASE_URL=${DATABASE_URL}
REDIS_URL=${REDIS_URL}

# 外部服務（生產密鑰）
STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
SENDGRID_API_KEY=${SENDGRID_API_KEY}

# 功能開關（保守設定）
FEATURE_NEW_DASHBOARD=false
FEATURE_ADVANCED_ANALYTICS=false

# 效能設定
GUNICORN_WORKERS=4
CELERY_WORKERS=8
```

---

## 🎯 任務目標

### 必達目標
1. ✅ 建立 **三環境部署管線**：
   - Dev：每次 push 自動部署
   - Staging：PR 合併後自動部署
   - Production：手動觸發 + 審批流程

2. ✅ 實作 **環境一致性保證**：
   - 相同的 Docker 映像在所有環境運行
   - 基礎設施即程式碼（Terraform/Helm）
   - 自動化環境配置驗證

3. ✅ 設計 **安全的配置管理**：
   - 敏感資料用 GitHub Secrets
   - 環境特定配置用 ConfigMap
   - 配置變更追蹤和審核

4. ✅ 建立 **品質門控機制**：
   - Dev：基本健康檢查
   - Staging：完整測試套件 + 效能測試
   - Production：藍綠部署 + 金絲雀測試

5. ✅ 實作 **自動回退機制**：
   - 健康檢查失敗自動回退
   - 一鍵手動回退
   - 資料庫遷移回退策略

### 加分項目
- 🌟 實作 **環境升級流水線**（Dev → Staging → Production）
- 🌟 建立 **配置漂移檢測**（環境配置變更告警）
- 🌟 整合 **功能開關系統**（Feature Flags）
- 🌟 設計 **災難恢復演練**自動化

---

## 🚀 實作步驟

### 步驟 1：多環境部署 Workflow 設計

```yaml
# .github/workflows/deploy-multi-environment.yml
name: Multi-Environment Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
    types: [closed]
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue_green
          - canary
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 環境路由決策
  environment-router:
    name: Environment Routing
    runs-on: ubuntu-latest
    outputs:
      target-env: ${{ steps.decide.outputs.environment }}
      deploy-strategy: ${{ steps.decide.outputs.strategy }}
      should-deploy: ${{ steps.decide.outputs.should_deploy }}

    steps:
    - name: Determine deployment environment
      id: decide
      run: |
        # 根據觸發條件決定目標環境
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENV="${{ github.event.inputs.target_environment }}"
          STRATEGY="${{ github.event.inputs.deployment_strategy }}"
        elif [ "${{ github.event_name }}" = "push" ]; then
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="staging"
            STRATEGY="rolling"
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            ENV="development"
            STRATEGY="rolling"
          else
            ENV="none"
            STRATEGY="none"
          fi
        elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.action }}" = "closed" ] && [ "${{ github.event.pull_request.merged }}" = "true" ]; then
          ENV="staging"
          STRATEGY="rolling"
        else
          ENV="none"
          STRATEGY="none"
        fi

        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        echo "should_deploy=$([ "$ENV" != "none" ] && echo true || echo false)" >> $GITHUB_OUTPUT

        echo "🎯 Target Environment: $ENV"
        echo "📋 Deployment Strategy: $STRATEGY"

  # 預部署檢查
  pre-deployment-checks:
    name: Pre-deployment Checks
    needs: environment-router
    if: needs.environment-router.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # 環境配置驗證
    - name: Validate environment configuration
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"

        echo "🔍 Validating $TARGET_ENV environment configuration..."

        # 檢查必要的配置檔案
        if [ ! -f "deployment/configs/${TARGET_ENV}.env" ] && [ ! -f "deployment/configs/${TARGET_ENV}.env.template" ]; then
          echo "❌ Environment configuration not found for $TARGET_ENV"
          exit 1
        fi

        # 檢查基礎設施配置
        if [ ! -d "infrastructure/environments/${TARGET_ENV}" ]; then
          echo "❌ Infrastructure configuration not found for $TARGET_ENV"
          exit 1
        fi

        # 檢查 Helm charts
        if [ ! -d "deployment/helm-charts" ]; then
          echo "❌ Helm charts not found"
          exit 1
        fi

        echo "✅ Environment configuration validation passed"

    # 映像版本檢查
    - name: Verify Docker image exists
      run: |
        IMAGE_TAG="${{ github.sha }}"

        for component in backend frontend worker; do
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${component}:${IMAGE_TAG}"
          echo "Checking image: $IMAGE"

          if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
            echo "✅ $component image exists"
          else
            echo "❌ $component image not found"
            exit 1
          fi
        done

    # 相依服務健康檢查
    - name: Check dependent services
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"

        echo "🔍 Checking dependent services for $TARGET_ENV..."

        # 在實際環境中，這裡會檢查：
        # - 資料庫可用性
        # - Redis 可用性
        # - 外部 API 服務狀態
        # - 監控系統狀態

        case "$TARGET_ENV" in
          "development")
            echo "✅ Development services ready"
            ;;
          "staging")
            echo "✅ Staging services ready"
            ;;
          "production")
            echo "✅ Production services ready"
            ;;
        esac

  # 部署執行
  deploy-application:
    name: Deploy to ${{ needs.environment-router.outputs.target-env }}
    needs: [environment-router, pre-deployment-checks]
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.environment-router.outputs.target-env }}
      url: ${{ steps.get-url.outputs.url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get environment URL
      id: get-url
      run: |
        case "${{ needs.environment-router.outputs.target-env }}" in
          "development")
            echo "url=https://dev.saas-platform.com" >> $GITHUB_OUTPUT
            ;;
          "staging")
            echo "url=https://staging.saas-platform.com" >> $GITHUB_OUTPUT
            ;;
          "production")
            echo "url=https://saas-platform.com" >> $GITHUB_OUTPUT
            ;;
        esac

    # 設定 Kubernetes 配置
    - name: Setup Kubernetes config
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"

        # 在實際環境中，這裡會設定對應環境的 kubectl 配置
        echo "🔧 Setting up kubectl for $TARGET_ENV..."

        # kubectl config use-context $TARGET_ENV
        # 或者設定特定的 kubeconfig

    # 執行資料庫遷移（如果需要）
    - name: Database migration
      if: needs.environment-router.outputs.target-env != 'development'
      run: |
        echo "🗄️ Running database migrations..."

        # 在實際環境中，這裡會執行 Alembic 遷移
        # kubectl run migration-job --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }} --restart=Never --command -- alembic upgrade head

        echo "✅ Database migration completed"

    # 執行部署策略
    - name: Execute deployment strategy
      run: |
        STRATEGY="${{ needs.environment-router.outputs.deploy-strategy }}"
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"
        IMAGE_TAG="${{ github.sha }}"

        echo "🚀 Executing $STRATEGY deployment to $TARGET_ENV..."

        case "$STRATEGY" in
          "rolling")
            echo "📱 Rolling deployment..."
            # helm upgrade --install saas-platform ./deployment/helm-charts \
            #   --namespace $TARGET_ENV \
            #   --set image.tag=$IMAGE_TAG \
            #   --set environment=$TARGET_ENV \
            #   --wait --timeout=10m
            ;;

          "blue_green")
            echo "🔵🟢 Blue-Green deployment..."
            # 1. 部署到綠色環境
            # 2. 健康檢查
            # 3. 切換流量
            # 4. 保留藍色環境一段時間
            ;;

          "canary")
            echo "🐤 Canary deployment..."
            # 1. 部署 10% 流量版本
            # 2. 監控指標
            # 3. 逐步增加流量
            # 4. 全量部署
            ;;
        esac

        sleep 10  # 模擬部署時間
        echo "✅ Deployment completed"

    # 部署後健康檢查
    - name: Post-deployment health check
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"
        BASE_URL="${{ steps.get-url.outputs.url }}"

        echo "🔍 Running comprehensive health check..."

        # 基本健康檢查
        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          if curl -f -s "$BASE_URL/health" > /dev/null; then
            echo "✅ Basic health check passed"
            break
          fi
          sleep 10
        done

        # 應用特定檢查
        case "$TARGET_ENV" in
          "development")
            echo "✅ Development environment health check passed"
            ;;
          "staging")
            echo "🧪 Running staging-specific tests..."
            # pytest tests/integration/
            echo "✅ Staging environment health check passed"
            ;;
          "production")
            echo "🏥 Running production health checks..."
            # 檢查關鍵業務功能
            # 檢查資料庫連線
            # 檢查外部服務整合
            echo "✅ Production environment health check passed"
            ;;
        esac

    # 效能測試（Staging 和 Production）
    - name: Performance testing
      if: contains(fromJson('["staging", "production"]'), needs.environment-router.outputs.target-env)
      run: |
        echo "⚡ Running performance tests..."

        # 使用 Apache Bench 進行簡單效能測試
        BASE_URL="${{ steps.get-url.outputs.url }}"

        # 輕量級效能測試
        ab -n 100 -c 10 "$BASE_URL/health" || echo "Performance test warning"

        echo "✅ Performance test completed"

    # 回退機制設置
    - name: Setup rollback capability
      run: |
        echo "🔄 Setting up rollback capability..."

        # 記錄當前部署版本
        echo "PREVIOUS_VERSION=${{ github.sha }}" >> deployment-info.txt
        echo "DEPLOYMENT_TIME=$(date -u)" >> deployment-info.txt
        echo "TARGET_ENV=${{ needs.environment-router.outputs.target-env }}" >> deployment-info.txt

        # 在實際環境中，這裡會：
        # 1. 備份當前配置
        # 2. 記錄回退所需的資訊
        # 3. 設定自動回退觸發器

  # 部署後驗證
  post-deployment-validation:
    name: Post-deployment Validation
    needs: [environment-router, deploy-application]
    runs-on: ubuntu-latest
    if: always() && needs.deploy-application.result == 'success'

    steps:
    - name: Comprehensive system validation
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"

        echo "🔬 Running comprehensive validation for $TARGET_ENV..."

        case "$TARGET_ENV" in
          "development")
            echo "✅ Development validation: Basic functionality"
            ;;
          "staging")
            echo "🧪 Staging validation: Full test suite"
            # 執行完整的集成測試
            # 執行 API 測試
            # 執行前端 E2E 測試
            ;;
          "production")
            echo "🏥 Production validation: Business-critical checks"
            # 檢查關鍵業務指標
            # 檢查用戶登入流程
            # 檢查支付流程
            # 檢查通知系統
            ;;
        esac

    # 監控設置
    - name: Setup monitoring and alerts
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"

        echo "📊 Setting up monitoring for $TARGET_ENV deployment..."

        # 在實際環境中，這裡會：
        # 1. 更新 Grafana 儀表板
        # 2. 設定部署特定的告警
        # 3. 通知監控團隊

  # 通知和報告
  deployment-notification:
    name: Deployment Notification
    needs: [environment-router, deploy-application, post-deployment-validation]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Generate deployment report
      run: |
        TARGET_ENV="${{ needs.environment-router.outputs.target-env }}"
        DEPLOY_STATUS="${{ needs.deploy-application.result }}"
        VALIDATION_STATUS="${{ needs.post-deployment-validation.result }}"

        echo "📋 Generating deployment report..."

        cat > deployment-report.md << EOF
        # 🚀 Deployment Report

        **Environment:** $TARGET_ENV
        **Strategy:** ${{ needs.environment-router.outputs.deploy-strategy }}
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        **Actor:** ${{ github.actor }}
        **Timestamp:** $(date -u)

        ## 📊 Deployment Status

        | Phase | Status |
        |-------|--------|
        | Deployment | $DEPLOY_STATUS |
        | Validation | $VALIDATION_STATUS |

        ## 🔗 Links

        - **Environment URL:** [Open Application](${{ steps.get-url.outputs.url }})
        - **Monitoring:** [Grafana Dashboard](https://grafana.company.com/d/env-$TARGET_ENV)
        - **Logs:** [CloudWatch](https://console.aws.amazon.com/cloudwatch/home#logsV2:log-groups/log-group/$TARGET_ENV)

        EOF

        cat deployment-report.md

    # Slack 通知
    - name: Send Slack notification
      if: vars.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: |
          🚀 Deployment to ${{ needs.environment-router.outputs.target-env }} completed

          Status: ${{ needs.deploy-application.result }}
          Commit: ${{ github.sha }}
          Actor: ${{ github.actor }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

```

### 步驟 2：環境配置管理系統

```bash
#!/bin/bash
# deployment/scripts/environment-manager.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# 環境配置管理
manage_environment_config() {
    local env_name="$1"
    local action="$2"

    case "$action" in
        "validate")
            validate_environment_config "$env_name"
            ;;
        "deploy")
            deploy_environment_config "$env_name"
            ;;
        "diff")
            compare_environment_config "$env_name"
            ;;
        "sync")
            sync_environment_config "$env_name"
            ;;
        *)
            echo "Usage: $0 <env> <validate|deploy|diff|sync>"
            exit 1
            ;;
    esac
}

# 驗證環境配置
validate_environment_config() {
    local env_name="$1"

    echo "🔍 Validating $env_name environment configuration..."

    # 檢查必要檔案
    local config_file="$PROJECT_ROOT/deployment/configs/${env_name}.env"
    local infra_dir="$PROJECT_ROOT/infrastructure/environments/${env_name}"

    if [ ! -f "$config_file" ] && [ ! -f "${config_file}.template" ]; then
        echo "❌ Configuration file not found: $config_file"
        return 1
    fi

    if [ ! -d "$infra_dir" ]; then
        echo "❌ Infrastructure directory not found: $infra_dir"
        return 1
    fi

    # 驗證必要的環境變數
    local required_vars=(
        "ENVIRONMENT"
        "DATABASE_URL"
        "REDIS_URL"
    )

    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$config_file" 2>/dev/null; then
            echo "❌ Required variable missing: $var"
            return 1
        fi
    done

    # 驗證 Terraform 配置
    if [ -d "$infra_dir/terraform" ]; then
        echo "🔧 Validating Terraform configuration..."
        cd "$infra_dir/terraform"
        terraform validate
        cd - > /dev/null
    fi

    # 驗證 Kubernetes 配置
    if [ -d "$infra_dir/kubernetes" ]; then
        echo "☸️ Validating Kubernetes manifests..."
        for file in "$infra_dir/kubernetes"/*.yaml; do
            if [ -f "$file" ]; then
                kubectl --dry-run=client apply -f "$file" > /dev/null
            fi
        done
    fi

    echo "✅ Environment configuration validation passed"
}

# 部署環境配置
deploy_environment_config() {
    local env_name="$1"

    echo "🚀 Deploying $env_name environment configuration..."

    # 部署基礎設施
    local infra_dir="$PROJECT_ROOT/infrastructure/environments/${env_name}"

    if [ -d "$infra_dir/terraform" ]; then
        echo "🏗️ Deploying infrastructure with Terraform..."
        cd "$infra_dir/terraform"
        terraform init
        terraform plan -out=tfplan
        terraform apply tfplan
        cd - > /dev/null
    fi

    # 部署 Kubernetes 配置
    if [ -d "$infra_dir/kubernetes" ]; then
        echo "☸️ Applying Kubernetes configurations..."
        kubectl apply -f "$infra_dir/kubernetes/"
    fi

    echo "✅ Environment configuration deployed"
}

# 比較環境配置
compare_environment_config() {
    local env_name="$1"
    local reference_env="${2:-production}"

    echo "🔍 Comparing $env_name with $reference_env..."

    # 比較環境變數配置
    local config_file="$PROJECT_ROOT/deployment/configs/${env_name}.env"
    local ref_config_file="$PROJECT_ROOT/deployment/configs/${reference_env}.env"

    if [ -f "$config_file" ] && [ -f "$ref_config_file" ]; then
        echo "📋 Configuration differences:"
        diff -u "$ref_config_file" "$config_file" || true
    fi

    # 比較基礎設施配置
    local infra_dir="$PROJECT_ROOT/infrastructure/environments/${env_name}"
    local ref_infra_dir="$PROJECT_ROOT/infrastructure/environments/${reference_env}"

    if [ -d "$infra_dir" ] && [ -d "$ref_infra_dir" ]; then
        echo "🏗️ Infrastructure differences:"
        diff -ru "$ref_infra_dir" "$infra_dir" || true
    fi
}

# 同步環境配置
sync_environment_config() {
    local env_name="$1"

    echo "🔄 Syncing $env_name environment configuration..."

    # 檢查配置漂移
    echo "🔍 Checking for configuration drift..."

    # 在實際環境中，這裡會：
    # 1. 比較實際運行配置與預期配置
    # 2. 檢測未授權的配置變更
    # 3. 生成配置漂移報告
    # 4. 可選擇自動修復或告警

    echo "✅ Configuration sync completed"
}

# 主函數
main() {
    if [ $# -lt 2 ]; then
        echo "Usage: $0 <environment> <action>"
        echo "Environments: development, staging, production"
        echo "Actions: validate, deploy, diff, sync"
        exit 1
    fi

    manage_environment_config "$1" "$2"
}

# 只在直接執行時運行主函數
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

### 步驟 3：自動回退機制

```yaml
# .github/workflows/auto-rollback.yml
name: Auto Rollback System

on:
  workflow_run:
    workflows: ["Multi-Environment Deployment"]
    types: [completed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      reason:
        description: 'Rollback reason'
        required: true
        type: string

jobs:
  detect-deployment-issues:
    name: Detect Deployment Issues
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    outputs:
      should-rollback: ${{ steps.health-check.outputs.should_rollback }}
      environment: ${{ steps.detect-env.outputs.environment }}

    steps:
    - name: Detect deployment environment
      id: detect-env
      run: |
        # 從觸發的 workflow 中解析環境資訊
        # 這裡簡化處理，實際上會解析 workflow 輸出
        echo "environment=staging" >> $GITHUB_OUTPUT

    - name: Advanced health check
      id: health-check
      run: |
        ENV="${{ steps.detect-env.outputs.environment }}"

        case "$ENV" in
          "development")
            BASE_URL="https://dev.saas-platform.com"
            ;;
          "staging")
            BASE_URL="https://staging.saas-platform.com"
            ;;
          "production")
            BASE_URL="https://saas-platform.com"
            ;;
        esac

        echo "🔍 Running advanced health check for $ENV..."

        # 等待應用完全啟動
        sleep 30

        # 健康檢查指標
        HEALTH_PASSED=true

        # 1. 基本 HTTP 健康檢查
        if ! curl -f -s "$BASE_URL/health" > /dev/null; then
          echo "❌ Basic health check failed"
          HEALTH_PASSED=false
        fi

        # 2. 資料庫連線檢查
        if ! curl -f -s "$BASE_URL/health/database" > /dev/null; then
          echo "❌ Database health check failed"
          HEALTH_PASSED=false
        fi

        # 3. 關鍵 API 端點檢查
        if ! curl -f -s "$BASE_URL/api/status" > /dev/null; then
          echo "❌ API health check failed"
          HEALTH_PASSED=false
        fi

        # 4. 效能檢查（響應時間）
        RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" "$BASE_URL/health")
        if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
          echo "❌ Response time too slow: ${RESPONSE_TIME}s"
          HEALTH_PASSED=false
        fi

        # 5. 錯誤率檢查（如果有監控系統）
        # ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=rate(http_requests_total{status=~'5..'}[5m])" | jq '.data.result[0].value[1]')
        # if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
        #   echo "❌ Error rate too high: $ERROR_RATE"
        #   HEALTH_PASSED=false
        # fi

        if [ "$HEALTH_PASSED" = "true" ]; then
          echo "✅ All health checks passed"
          echo "should_rollback=false" >> $GITHUB_OUTPUT
        else
          echo "❌ Health checks failed - triggering rollback"
          echo "should_rollback=true" >> $GITHUB_OUTPUT
        fi

  execute-rollback:
    name: Execute Rollback
    needs: detect-deployment-issues
    if: |
      always() && (
        needs.detect-deployment-issues.outputs.should-rollback == 'true' ||
        github.event_name == 'workflow_dispatch'
      )
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get rollback target
      id: rollback-target
      run: |
        ENV="${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}"

        echo "🔍 Finding rollback target for $ENV..."

        # 在實際環境中，這裡會查詢：
        # 1. 最後一次成功的部署版本
        # 2. Git 歷史中的穩定版本
        # 3. 備份的配置資訊

        # 模擬取得上一個穩定版本
        PREVIOUS_SHA=$(git log --format="%H" -n 2 | tail -1)
        echo "rollback_sha=$PREVIOUS_SHA" >> $GITHUB_OUTPUT
        echo "🔄 Rolling back to: $PREVIOUS_SHA"

    - name: Pre-rollback backup
      run: |
        ENV="${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}"

        echo "💾 Creating pre-rollback backup..."

        # 備份當前狀態
        mkdir -p rollback-backup

        # 備份配置
        kubectl get configmap -n "$ENV" -o yaml > rollback-backup/configmaps.yaml
        kubectl get secret -n "$ENV" -o yaml > rollback-backup/secrets.yaml

        # 備份資料庫（如果需要）
        # pg_dump ... > rollback-backup/database.sql

        echo "✅ Backup completed"

    - name: Execute rollback deployment
      run: |
        ENV="${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}"
        ROLLBACK_SHA="${{ steps.rollback-target.outputs.rollback_sha }}"

        echo "🔄 Executing rollback deployment..."
        echo "Environment: $ENV"
        echo "Target SHA: $ROLLBACK_SHA"

        # 回退到穩定版本
        case "$ENV" in
          "development"|"staging")
            # 快速回退策略
            echo "⚡ Fast rollback strategy for $ENV"
            # kubectl set image deployment/app app=$REGISTRY/$IMAGE_NAME:$ROLLBACK_SHA
            ;;
          "production")
            # 謹慎回退策略
            echo "🛡️ Safe rollback strategy for production"
            # 1. 先部署到金絲雀環境
            # 2. 健康檢查
            # 3. 逐步切換流量
            ;;
        esac

        sleep 10  # 模擬回退時間
        echo "✅ Rollback deployment completed"

    - name: Post-rollback verification
      run: |
        ENV="${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}"

        echo "🔍 Verifying rollback success..."

        case "$ENV" in
          "development")
            BASE_URL="https://dev.saas-platform.com"
            ;;
          "staging")
            BASE_URL="https://staging.saas-platform.com"
            ;;
          "production")
            BASE_URL="https://saas-platform.com"
            ;;
        esac

        # 等待服務穩定
        sleep 30

        # 驗證回退後的健康狀態
        for i in {1..5}; do
          if curl -f -s "$BASE_URL/health" > /dev/null; then
            echo "✅ Rollback verification successful (attempt $i)"
            break
          fi
          sleep 10
        done

    - name: Rollback notification
      run: |
        ENV="${{ needs.detect-deployment-issues.outputs.environment || github.event.inputs.environment }}"
        REASON="${{ github.event.inputs.reason || 'Automatic rollback due to health check failure' }}"

        echo "📢 Sending rollback notification..."

        # 在實際環境中，這裡會發送通知到：
        # 1. Slack/Teams 頻道
        # 2. 事件管理系統（PagerDuty）
        # 3. 監控系統（更新狀態）
        # 4. 事故管理系統

        cat > rollback-report.md << EOF
        # 🔄 Rollback Executed

        **Environment:** $ENV
        **Reason:** $REASON
        **Executed by:** ${{ github.actor }}
        **Timestamp:** $(date -u)
        **Rollback target:** ${{ steps.rollback-target.outputs.rollback_sha }}

        ## Next Steps
        1. Investigate root cause
        2. Fix issues in develop branch
        3. Re-deploy after validation

        EOF

        cat rollback-report.md
```

---

## ✅ 完整解決方案重點

### 1. 環境一致性保證
- **相同映像**：所有環境使用相同的 Docker 映像，只改變配置
- **基礎設施即程式碼**：Terraform + Kubernetes 確保環境配置一致
- **自動化驗證**：部署前檢查環境配置和依賴服務

### 2. 安全的配置管理
- **分層配置**：基礎配置 + 環境特定配置 + 敏感資料分離
- **版本控制**：所有配置變更都有追蹤記錄
- **權限控制**：不同環境有不同的存取權限

### 3. 品質門控機制
- **Dev**：快速部署，基本健康檢查
- **Staging**：完整測試，效能驗證
- **Production**：審批流程，藍綠/金絲雀部署

### 4. 可靠的回退機制
- **自動回退**：健康檢查失敗自動觸發
- **手動回退**：一鍵式緊急回退
- **備份恢復**：配置和資料的完整備份

---

## 📖 學習成果驗證

完成此情境題後，你應該能夠：

### ✅ 企業級多環境管理
- 設計並實作 3+ 環境的部署策略
- 管理環境間的配置差異和一致性
- 建立環境升級流水線

### ✅ 高級部署策略
- 實作滾動、藍綠、金絲雀部署
- 根據環境選擇合適的部署策略
- 設計自動化的品質門控

### ✅ 配置和密鑰管理
- 分離敏感配置和一般配置
- 實作配置版本控制和審核
- 建立配置漂移檢測機制

### ✅ 監控和回退機制
- 設計多層次的健康檢查
- 實作自動和手動回退機制
- 建立部署監控和告警系統

---

**恭喜完成 C02！** 🎉

你已經掌握了企業級多環境部署的核心技能，這是 DevOps 工程師必備的進階能力。

**下一步**：
- 挑戰其他組合級情境 (C03-C10)
- 或進入複雜級情境 (E01-E02)
- 或將這些技能應用到實際專案中