# B06：建立簡易部署流程

## 📋 情境資訊

**難度等級**：⭐ 基礎級
**預估時間**：40 分鐘
**核心技能**：自動化部署、GitHub Pages、簡單 CD
**前置知識**：B05（配置依賴掃描）

---

## 🎯 情境背景

你的團隊現在有了完整的 CI 管線（測試、品質檢查、安全掃描、依賴監控），但每次部署還是手動進行：

**手動部署的痛苦**：
```bash
# 每次發布的手動流程
1. 本機測試：pytest
2. 構建 Docker 映像：docker build -t app:latest .
3. 推送到 registry：docker push registry.com/app:latest
4. SSH 到伺服器：ssh user@server
5. 拉取新映像：docker pull registry.com/app:latest
6. 停止舊容器：docker stop app-container
7. 啟動新容器：docker run -d app:latest
8. 檢查服務：curl http://server/health
9. 更新 nginx 配置（如果需要）
10. 通知團隊：「部署完成」
```

**昨天的部署事故**：
- 小華忘記執行步驟 2，直接推送了舊映像
- 小明在步驟 6 忘記備份資料庫
- 結果：服務中斷 1 小時，資料遺失 30 分鐘

**團隊的挫折**：
> 「我們有自動化測試，為什麼部署還要手動？每次都提心吊膽！」

**DevOps 團隊的建議**：
> 「先從簡單的自動化部署開始，比如靜態網站部署，再逐步擴展到應用部署。」

**團隊決定**：
> 「建立基礎的自動化部署流程，先部署文件和靜態網站，然後擴展到應用部署。」

**你的任務**：
建立簡易但完整的自動化部署流程，包含靜態網站部署和基礎的應用部署。

---

## 📦 專案結構

延續 B05 的專案，並加入部署相關檔案：

```
my-fastapi-project/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── models.py
│   ├── utils.py
│   └── security.py
│
├── tests/
│   ├── __init__.py
│   ├── test_main.py
│   └── test_security.py
│
├── docs/                     # 新增：專案文件
│   ├── index.html           # 專案主頁
│   ├── api-docs.html        # API 文件
│   └── deployment-guide.md  # 部署指南
│
├── scripts/                 # 新增：部署腳本
│   ├── deploy.sh           # 部署腳本
│   ├── health-check.sh     # 健康檢查
│   └── rollback.sh         # 回退腳本
│
├── requirements.txt
├── requirements-dev.txt
├── pyproject.toml
├── .bandit
├── Dockerfile
├── .dockerignore
├── docker-compose.yml
├── .github/
│   ├── dependabot.yml
│   └── workflows/
│       ├── test.yml         # 現有的完整 CI workflow
│       ├── deploy-docs.yml  # 新增：文件部署
│       └── deploy-app.yml   # 新增：應用部署
│
├── .gitignore
└── README.md
```

**簡單的文件網站（docs/index.html）**：
```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My FastAPI Project</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { background-color: #d4edda; border: 1px solid #c3e6cb; }
        .info { background-color: #d1ecf1; border: 1px solid #bee5eb; }
    </style>
</head>
<body>
    <h1>🚀 My FastAPI Project</h1>

    <div class="status success">
        <strong>✅ 部署狀態：</strong> 已成功部署
        <br><strong>🕒 最後更新：</strong> <span id="build-time">載入中...</span>
        <br><strong>📦 版本：</strong> <span id="version">1.0.0</span>
    </div>

    <h2>📚 專案資訊</h2>
    <ul>
        <li><strong>技術棧：</strong> FastAPI + Python 3.11</li>
        <li><strong>CI/CD：</strong> GitHub Actions</li>
        <li><strong>容器化：</strong> Docker</li>
        <li><strong>安全掃描：</strong> CodeQL + bandit + Snyk</li>
    </ul>

    <h2>🔗 相關連結</h2>
    <ul>
        <li><a href="api-docs.html">📖 API 文件</a></li>
        <li><a href="https://api.example.com/docs">🚀 線上 API (Swagger)</a></li>
        <li><a href="https://github.com/username/repo">💻 GitHub 專案</a></li>
        <li><a href="https://github.com/username/repo/actions">⚡ CI/CD 狀態</a></li>
    </ul>

    <h2>📊 建置資訊</h2>
    <div class="status info">
        <strong>🏗️ 建置號：</strong> <span id="build-number">{{BUILD_NUMBER}}</span>
        <br><strong>🌿 分支：</strong> <span id="branch">{{BRANCH}}</span>
        <br><strong>📝 提交：</strong> <span id="commit">{{COMMIT_SHA}}</span>
    </div>

    <script>
        // 設定建置時間
        document.getElementById('build-time').textContent = new Date().toLocaleString('zh-TW');

        // 模擬載入其他資訊（在實際專案中會從 API 獲取）
        setTimeout(() => {
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.get('build')) {
                // 如果沒有查詢參數，顯示預設值
                document.getElementById('build-number').textContent = '{{BUILD_NUMBER}}' || 'dev-local';
                document.getElementById('branch').textContent = '{{BRANCH}}' || 'main';
                document.getElementById('commit').textContent = '{{COMMIT_SHA}}' || 'latest';
            }
        }, 100);
    </script>
</body>
</html>
```

**部署腳本（scripts/deploy.sh）**：
```bash
#!/bin/bash
set -e

# 設定變數
APP_NAME="my-fastapi-app"
REGISTRY="ghcr.io"
IMAGE_TAG="${GITHUB_SHA:-latest}"
CONTAINER_NAME="${APP_NAME}-container"

echo "🚀 Starting deployment..."
echo "App: $APP_NAME"
echo "Image: $REGISTRY/$GITHUB_REPOSITORY:$IMAGE_TAG"

# 1. 拉取最新映像
echo "📦 Pulling latest image..."
docker pull "$REGISTRY/$GITHUB_REPOSITORY:$IMAGE_TAG"

# 2. 停止舊容器（如果存在）
echo "🛑 Stopping old container..."
docker stop "$CONTAINER_NAME" 2>/dev/null || true
docker rm "$CONTAINER_NAME" 2>/dev/null || true

# 3. 啟動新容器
echo "🆕 Starting new container..."
docker run -d \
    --name "$CONTAINER_NAME" \
    --restart unless-stopped \
    -p 8000:8000 \
    -e ENVIRONMENT=production \
    "$REGISTRY/$GITHUB_REPOSITORY:$IMAGE_TAG"

# 4. 等待容器啟動
echo "⏳ Waiting for container to start..."
sleep 10

# 5. 健康檢查
echo "🔍 Running health check..."
./scripts/health-check.sh

echo "✅ Deployment completed successfully!"
```

---

## 🎯 任務目標

### 必達目標
1. ✅ 建立 **靜態網站自動部署**（GitHub Pages）
2. ✅ 建立 **Docker 映像自動發布** 流程
3. ✅ 設定 **部署觸發條件**（main 分支推送）
4. ✅ 加入 **部署後健康檢查**
5. ✅ 建立基礎的 **回退機制**

### 加分項目
- 🌟 實作 **多環境部署**（staging + production）
- 🌟 加入 **部署通知**（Slack/Discord）
- 🌟 建立 **部署審批** 流程
- 🌟 設定 **自動回退** 條件

---

## 📚 學習檢查點

完成此情境題時，請確認你能回答：

### Checkpoint 1：部署基礎
- [ ] CI 和 CD 的差別是什麼？
- [ ] 什麼是持續部署 vs 持續交付？
- [ ] 為什麼需要自動化部署？
- [ ] 部署和發布的差別？

### Checkpoint 2：部署策略
- [ ] 如何確保部署的安全性？
- [ ] 什麼時候應該觸發部署？
- [ ] 如何處理部署失敗？
- [ ] 健康檢查的重要性？

### Checkpoint 3：GitHub Actions 部署
- [ ] 如何在 workflow 中設定部署權限？
- [ ] 如何安全地管理部署密鑰？
- [ ] 如何實作條件式部署？

---

## 🚀 實作步驟

### 方法 1：用 Claude 生成（推薦）

#### 步驟 1：準備提示詞

```
我需要為 FastAPI 專案建立完整的自動化部署流程。

當前狀況：
- 已有完整的 CI 管線（測試、品質檢查、安全掃描）
- 已有 Docker 映像構建流程
- 專案結構包含 app/ 和 docs/ 目錄

需求：
1. 靜態網站部署（docs/ 目錄到 GitHub Pages）
2. Docker 映像發布到 GitHub Container Registry
3. 基礎的應用部署流程（可以是模擬的）
4. 部署後健康檢查
5. 簡單的回退機制

部署策略：
- 只在 main 分支觸發部署
- 需要所有 CI 檢查通過
- 先部署 staging，測試通過後部署 production

請提供：
1. 完整的部署 workflow
2. 部署腳本
3. 健康檢查腳本
4. 回退腳本
5. 最佳實踐建議

請加上詳細註解說明部署流程。
```

#### 步驟 2：建立部署腳本

根據 Claude 的建議，建立所需的部署腳本：

```bash
mkdir -p scripts
touch scripts/deploy.sh
touch scripts/health-check.sh
touch scripts/rollback.sh
chmod +x scripts/*.sh
```

#### 步驟 3：建立部署 Workflow

```bash
touch .github/workflows/deploy-docs.yml
touch .github/workflows/deploy-app.yml
```

#### 步驟 4：建立文件網站

```bash
mkdir -p docs
# 建立基本的 HTML 檔案
```

### 方法 2：手動建立（學習用）

#### 步驟 1：建立文件部署 Workflow

`.github/workflows/deploy-docs.yml`：

```yaml
name: Deploy Documentation

on:
  push:
    branches: [main]
    paths:
      - 'docs/**'
      - '.github/workflows/deploy-docs.yml'
  workflow_dispatch:

# 設定 GitHub Pages 需要的權限
permissions:
  contents: read
  pages: write
  id-token: write

# 確保同時只有一個部署運行
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build-docs:
    name: Build Documentation
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Pages
      uses: actions/configure-pages@v3

    # 處理模板變數替換
    - name: Process documentation templates
      run: |
        # 替換 HTML 中的變數
        find docs -name "*.html" -type f -exec sed -i \
          -e "s/{{BUILD_NUMBER}}/${{ github.run_number }}/g" \
          -e "s/{{BRANCH}}/${{ github.ref_name }}/g" \
          -e "s/{{COMMIT_SHA}}/${{ github.sha }}/g" \
          {} \;

        # 生成建置資訊 JSON
        cat > docs/build-info.json << EOF
        {
          "buildNumber": "${{ github.run_number }}",
          "branch": "${{ github.ref_name }}",
          "commit": "${{ github.sha }}",
          "buildTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "workflow": "${{ github.workflow }}",
          "actor": "${{ github.actor }}"
        }
        EOF

    - name: Upload Pages artifact
      uses: actions/upload-pages-artifact@v2
      with:
        path: ./docs

  deploy-docs:
    name: Deploy to GitHub Pages
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build-docs

    steps:
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v2

    - name: Generate deployment summary
      run: |
        echo "## 📚 Documentation Deployed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**🌐 URL:** ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
        echo "**📦 Build:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
        echo "**🌿 Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**📝 Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
```

#### 步驟 2：建立應用部署 Workflow

`.github/workflows/deploy-app.yml`：

```yaml
name: Deploy Application

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 確保所有 CI 檢查通過
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    outputs:
      can-deploy: ${{ steps.check.outputs.can-deploy }}

    steps:
    - name: Check required CI jobs
      id: check
      uses: actions/github-script@v6
      with:
        script: |
          const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head_sha: context.sha,
            status: 'completed'
          });

          const requiredWorkflows = ['Complete CI/CD Pipeline with Docker'];
          const passedWorkflows = workflows.workflow_runs
            .filter(run => run.conclusion === 'success')
            .map(run => run.name);

          const allPassed = requiredWorkflows.every(required =>
            passedWorkflows.includes(required)
          );

          console.log('Required workflows:', requiredWorkflows);
          console.log('Passed workflows:', passedWorkflows);
          console.log('All required workflows passed:', allPassed);

          core.setOutput('can-deploy', allPassed);

          if (!allPassed) {
            core.setFailed('Not all required CI workflows have passed');
          }

  # 部署到 Staging 環境
  deploy-staging:
    name: Deploy to Staging
    needs: check-ci
    if: needs.check-ci.outputs.can-deploy == 'true'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # 模擬部署到 staging 環境
    - name: Deploy to staging
      run: |
        echo "🚀 Deploying to staging environment..."
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"

        # 在真實環境中，這裡會執行實際的部署命令
        # 例如：kubectl apply、docker-compose up、或 SSH 到伺服器

        # 模擬部署過程
        sleep 5
        echo "✅ Deployment to staging completed"

    - name: Run health check
      run: |
        echo "🔍 Running health check on staging..."
        # 在真實環境中，這裡會執行實際的健康檢查
        # curl -f https://staging.example.com/health

        sleep 3
        echo "✅ Health check passed"

    - name: Run smoke tests
      run: |
        echo "🧪 Running smoke tests..."
        # 在真實環境中，執行輕量級的端到端測試

        sleep 5
        echo "✅ Smoke tests passed"

  # 部署到 Production 環境
  deploy-production:
    name: Deploy to Production
    needs: [check-ci, deploy-staging]
    if: |
      needs.check-ci.outputs.can-deploy == 'true' &&
      (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production')
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://api.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # 部署前確認
    - name: Pre-deployment confirmation
      run: |
        echo "⚠️ Deploying to PRODUCTION environment"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Actor: ${{ github.actor }}"

    # 備份當前版本（用於回退）
    - name: Backup current deployment
      run: |
        echo "💾 Backing up current deployment..."
        # 在真實環境中，備份當前運行的容器或記錄版本
        echo "PREVIOUS_VERSION=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:previous" >> $GITHUB_ENV

    # 執行部署
    - name: Deploy to production
      id: deploy
      run: |
        echo "🚀 Deploying to production environment..."

        # 在真實環境中的部署命令範例：
        # docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        # docker stop my-app || true
        # docker rm my-app || true
        # docker run -d --name my-app -p 80:8000 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

        sleep 10
        echo "deployment_success=true" >> $GITHUB_OUTPUT

    # 部署後健康檢查
    - name: Post-deployment health check
      if: steps.deploy.outputs.deployment_success == 'true'
      run: |
        echo "🔍 Running comprehensive health check..."

        # 健康檢查腳本
        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          # curl -f https://api.example.com/health
          sleep 2
        done

        echo "✅ Health check passed"

    # 自動回退（如果部署失敗）
    - name: Auto-rollback on failure
      if: failure() && steps.deploy.outputs.deployment_success == 'true'
      run: |
        echo "❌ Deployment failed, initiating rollback..."

        # 回退到上一個版本
        # docker stop my-app || true
        # docker rm my-app || true
        # docker run -d --name my-app -p 80:8000 $PREVIOUS_VERSION

        echo "🔄 Rollback completed"

    # 部署成功通知
    - name: Deployment summary
      if: success()
      run: |
        echo "## 🚀 Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**🌐 Environment:** Production" >> $GITHUB_STEP_SUMMARY
        echo "**📦 Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**🌿 Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**👤 Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "**🕒 Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY
```

#### 步驟 3：建立部署腳本

**健康檢查腳本（scripts/health-check.sh）**：

```bash
#!/bin/bash
set -e

# 配置
HEALTH_URL="${HEALTH_URL:-http://localhost:8000/health}"
MAX_ATTEMPTS="${MAX_ATTEMPTS:-5}"
WAIT_TIME="${WAIT_TIME:-10}"

echo "🔍 Starting health check..."
echo "URL: $HEALTH_URL"
echo "Max attempts: $MAX_ATTEMPTS"

for i in $(seq 1 $MAX_ATTEMPTS); do
    echo "Health check attempt $i/$MAX_ATTEMPTS..."

    if curl -f -s "$HEALTH_URL" > /dev/null; then
        echo "✅ Health check passed!"

        # 取得健康狀態詳情
        HEALTH_RESPONSE=$(curl -s "$HEALTH_URL")
        echo "Response: $HEALTH_RESPONSE"

        exit 0
    else
        echo "❌ Health check failed (attempt $i)"

        if [ $i -lt $MAX_ATTEMPTS ]; then
            echo "Waiting ${WAIT_TIME}s before next attempt..."
            sleep $WAIT_TIME
        fi
    fi
done

echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
exit 1
```

**回退腳本（scripts/rollback.sh）**：

```bash
#!/bin/bash
set -e

# 配置
APP_NAME="${APP_NAME:-my-fastapi-app}"
CONTAINER_NAME="${CONTAINER_NAME:-${APP_NAME}-container}"
BACKUP_TAG="${BACKUP_TAG:-previous}"

echo "🔄 Starting rollback process..."

# 檢查是否有備份映像
if ! docker images | grep -q "$APP_NAME.*$BACKUP_TAG"; then
    echo "❌ No backup image found: $APP_NAME:$BACKUP_TAG"
    echo "Available images:"
    docker images | grep "$APP_NAME" || echo "No images found"
    exit 1
fi

echo "📦 Found backup image: $APP_NAME:$BACKUP_TAG"

# 停止當前容器
echo "🛑 Stopping current container..."
docker stop "$CONTAINER_NAME" 2>/dev/null || true
docker rm "$CONTAINER_NAME" 2>/dev/null || true

# 啟動備份版本
echo "🆕 Starting backup version..."
docker run -d \
    --name "$CONTAINER_NAME" \
    --restart unless-stopped \
    -p 8000:8000 \
    -e ENVIRONMENT=production \
    "$APP_NAME:$BACKUP_TAG"

# 等待啟動
echo "⏳ Waiting for container to start..."
sleep 10

# 執行健康檢查
echo "🔍 Running health check..."
if ./scripts/health-check.sh; then
    echo "✅ Rollback completed successfully!"
else
    echo "❌ Rollback failed - service is not healthy"
    exit 1
fi
```

---

## ✅ 參考解答

### 完整應用部署 Workflow

```yaml
name: Deploy Application

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '*.md'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip CI tests'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 預檢查
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      can-deploy: ${{ steps.check-ci.outputs.can-deploy }}
      image-tag: ${{ steps.determine-tag.outputs.tag }}

    steps:
    - name: Determine environment
      id: determine-env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "release" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi

    - name: Determine image tag
      id: determine-tag
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Check CI status
      id: check-ci
      if: github.event.inputs.skip_tests != 'true'
      uses: actions/github-script@v6
      with:
        script: |
          const { data: checkRuns } = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha
          });

          const failedChecks = checkRuns.check_runs.filter(
            check => check.conclusion === 'failure'
          );

          if (failedChecks.length > 0) {
            console.log('Failed checks:', failedChecks.map(c => c.name));
            core.setFailed('Some CI checks have failed');
            core.setOutput('can-deploy', false);
          } else {
            console.log('All checks passed');
            core.setOutput('can-deploy', true);
          }

  # 部署到目標環境
  deploy:
    name: Deploy to ${{ needs.pre-deployment.outputs.environment }}
    needs: pre-deployment
    if: needs.pre-deployment.outputs.can-deploy == 'true' || github.event.inputs.skip_tests == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.pre-deployment.outputs.environment }}
      url: ${{ steps.get-url.outputs.url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get environment URL
      id: get-url
      run: |
        case "${{ needs.pre-deployment.outputs.environment }}" in
          "production")
            echo "url=https://api.example.com" >> $GITHUB_OUTPUT
            ;;
          "staging")
            echo "url=https://staging.example.com" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "url=https://dev.example.com" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # 確保映像存在
    - name: Verify image exists
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image-tag }}"
        echo "Checking image: $IMAGE"

        if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
          echo "✅ Image exists and is accessible"
        else
          echo "❌ Image not found or not accessible"
          exit 1
        fi

    # 部署前準備
    - name: Pre-deployment setup
      run: |
        echo "🚀 Preparing deployment..."
        echo "Environment: ${{ needs.pre-deployment.outputs.environment }}"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image-tag }}"

        # 建立部署目錄
        mkdir -p deployment-logs
        echo "$(date): Starting deployment" > deployment-logs/deploy.log

    # 執行部署
    - name: Execute deployment
      id: deploy
      run: |
        echo "🚀 Executing deployment..."

        # 設定環境變數
        export IMAGE_TAG="${{ needs.pre-deployment.outputs.image-tag }}"
        export ENVIRONMENT="${{ needs.pre-deployment.outputs.environment }}"

        # 執行部署腳本
        if [ -f "scripts/deploy.sh" ]; then
          chmod +x scripts/deploy.sh
          ./scripts/deploy.sh
        else
          echo "No deployment script found, running default deployment..."

          # 預設部署邏輯（模擬）
          echo "Pulling image..."
          # docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG

          echo "Updating service..."
          # kubectl set image deployment/myapp myapp=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG
          # 或
          # docker-compose pull && docker-compose up -d

          sleep 5
        fi

        echo "deployment_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
        echo "deployment_success=true" >> $GITHUB_OUTPUT

    # 部署後驗證
    - name: Post-deployment verification
      if: steps.deploy.outputs.deployment_success == 'true'
      run: |
        echo "🔍 Running post-deployment verification..."

        # 健康檢查
        if [ -f "scripts/health-check.sh" ]; then
          chmod +x scripts/health-check.sh
          export HEALTH_URL="${{ steps.get-url.outputs.url }}/health"
          ./scripts/health-check.sh
        fi

        # 煙霧測試
        echo "Running smoke tests..."
        # 在這裡加入關鍵功能的快速測試

    # 回退（失敗時）
    - name: Rollback on failure
      if: failure() && steps.deploy.outputs.deployment_success == 'true'
      run: |
        echo "❌ Deployment failed, initiating rollback..."

        if [ -f "scripts/rollback.sh" ]; then
          chmod +x scripts/rollback.sh
          ./scripts/rollback.sh
        else
          echo "No rollback script found"
          # 執行預設回退邏輯
        fi

    # 清理
    - name: Cleanup
      if: always()
      run: |
        echo "🧹 Cleaning up..."
        # 清理暫存檔案
        rm -rf deployment-logs

    # 上傳部署報告
    - name: Upload deployment artifacts
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report-${{ needs.pre-deployment.outputs.environment }}
        path: |
          deployment-logs/
        retention-days: 30

  # 部署通知
  notify:
    name: Send Deployment Notification
    needs: [pre-deployment, deploy]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Determine notification message
      id: message
      run: |
        ENV="${{ needs.pre-deployment.outputs.environment }}"
        TAG="${{ needs.pre-deployment.outputs.image-tag }}"

        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ Successfully deployed to $ENV (tag: $TAG)" >> $GITHUB_OUTPUT
          echo "color=good" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ Failed to deploy to $ENV (tag: $TAG)" >> $GITHUB_OUTPUT
          echo "color=danger" >> $GITHUB_OUTPUT
        fi

    # Slack 通知（如果有設定）
    - name: Send Slack notification
      if: vars.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.message.outputs.status }}
        color: ${{ steps.message.outputs.color }}
        text: |
          ${{ steps.message.outputs.message }}

          Repository: ${{ github.repository }}
          Branch: ${{ github.ref_name }}
          Actor: ${{ github.actor }}
          Workflow: ${{ github.workflow }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    # GitHub 部署狀態
    - name: Update deployment status
      uses: actions/github-script@v6
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: context.payload.deployment?.id || 0,
            state: '${{ steps.message.outputs.status }}' === 'success' ? 'success' : 'failure',
            environment: '${{ needs.pre-deployment.outputs.environment }}',
            description: '${{ steps.message.outputs.message }}'
          });
```

---

## 🔍 驗證與除錯

### 測試部署流程

**1. 測試文件部署**：
```bash
# 修改文件
echo "<h1>Test Update</h1>" >> docs/index.html

# 提交觸發部署
git add docs/
git commit -m "docs: test automatic deployment"
git push origin main

# 檢查 GitHub Pages 是否更新
```

**2. 測試應用部署**：
```bash
# 觸發 workflow
gh workflow run "Deploy Application" --field environment=staging

# 監控執行狀態
gh run list --workflow="Deploy Application"

# 查看詳細日誌
gh run view <run-id> --log
```

**3. 本機測試部署腳本**：
```bash
# 設定環境變數
export GITHUB_REPOSITORY="username/repo"
export GITHUB_SHA="abc123"

# 測試健康檢查
./scripts/health-check.sh

# 測試部署邏輯（修改腳本為測試模式）
./scripts/deploy.sh
```

### 常見問題與解決

**問題 1：GitHub Pages 部署失敗**
```
Error: No such file or directory
```

**解決方案**：
```yaml
# 確保 docs 目錄存在且有內容
- name: Check docs directory
  run: |
    if [ ! -d "docs" ] || [ -z "$(ls -A docs)" ]; then
      echo "docs directory is empty"
      mkdir -p docs
      echo "<h1>Default Page</h1>" > docs/index.html
    fi
```

**問題 2：環境權限不足**
```
Error: Resource not accessible by integration
```

**解決方案**：
```yaml
# 確保有正確的權限設定
permissions:
  contents: read
  pages: write
  id-token: write
  deployments: write
```

**問題 3：健康檢查失敗**
```
Health check failed after 5 attempts
```

**檢查清單**：
- [ ] 服務是否真的啟動完成？
- [ ] 健康檢查 URL 是否正確？
- [ ] 防火牆是否允許連線？
- [ ] 容器是否有暴露正確的端口？

---

## 🌟 延伸挑戰

### 挑戰 1：藍綠部署

實作零停機的藍綠部署：

```yaml
- name: Blue-Green Deployment
  run: |
    # 部署到綠色環境
    docker run -d --name app-green -p 8001:8000 $NEW_IMAGE

    # 健康檢查
    curl -f http://localhost:8001/health

    # 切換流量（更新 nginx 配置）
    nginx -s reload

    # 停止藍色環境
    docker stop app-blue
```

### 挑戰 2：金絲雀部署

實作漸進式的金絲雀部署：

```yaml
- name: Canary Deployment
  run: |
    # 部署 10% 流量到新版本
    kubectl patch deployment myapp -p '{"spec":{"replicas":10}}'
    kubectl set image deployment/myapp-canary myapp=$NEW_IMAGE
    kubectl scale deployment myapp-canary --replicas=1

    # 監控指標 5 分鐘
    sleep 300

    # 如果指標正常，擴展到 100%
    kubectl scale deployment myapp-canary --replicas=10
    kubectl scale deployment myapp --replicas=0
```

### 挑戰 3：自動回退觸發器

基於指標自動觸發回退：

```yaml
- name: Monitor and auto-rollback
  run: |
    # 監控錯誤率
    ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=rate(http_requests_total{status=~'5..'}[5m])" | jq '.data.result[0].value[1]')

    if (( $(echo "$ERROR_RATE > 0.05" | bc -l) )); then
      echo "Error rate too high: $ERROR_RATE"
      ./scripts/rollback.sh
      exit 1
    fi
```

---

## 📖 知識回顧

完成這個情境題後，你應該學會：

### 核心概念
- ✅ CI vs CD 的差別和價值
- ✅ 部署策略的選擇考量
- ✅ 健康檢查和回退機制的重要性
- ✅ 多環境部署的管理

### 實戰技能
- ✅ 建立自動化部署 workflow
- ✅ 配置 GitHub Pages 部署
- ✅ 設計部署腳本和健康檢查
- ✅ 實作基礎的回退機制

### 最佳實踐
- ✅ 部署前的 CI 檢查
- ✅ 部署後的驗證流程
- ✅ 失敗時的自動回退
- ✅ 部署通知和狀態追蹤

### 進階概念
- ✅ 多環境部署策略
- ✅ 條件式部署觸發
- ✅ 部署審批流程
- ✅ 部署指標監控

---

## 📝 學習筆記範本

```markdown
## B06 學習筆記

### 完成時間
[填寫]

### 部署概念理解
- **CI vs CD**：[你的理解]
- **持續部署 vs 持續交付**：[差別和選擇]
- **部署策略**：[不同策略的適用場景]

### 部署流程設計
1. **部署觸發條件**：[何時觸發部署]
2. **預檢查機制**：[部署前的驗證]
3. **部署執行**：[實際部署步驟]
4. **部署後驗證**：[健康檢查和測試]
5. **失敗處理**：[回退機制]

### 遇到的問題
1. [問題描述]
   - 解決方案：[...]
2. [問題描述]
   - 解決方案：[...]

### 環境管理策略
- **開發環境**：[管理方式]
- **測試環境**：[用途和配置]
- **生產環境**：[安全性考量]

### 關鍵學習點
1. 自動化部署的價值：[...]
2. 健康檢查的重要性：[...]
3. 回退機制的設計：[...]

### 實際應用計畫
- [ ] 為現有專案建立部署流程
- [ ] 設定多環境部署策略
- [ ] 建立監控和告警機制

### 下一步
- [ ] 完成挑戰 1（藍綠部署）
- [ ] 進入組合級情境題
```

---

**恭喜完成 B06！** 🎉

你已經完成了所有基礎級別的 CI/CD 情境題，掌握了：
- ✅ **B01**：基礎測試管線
- ✅ **B02**：程式碼品質檢查
- ✅ **B03**：靜態安全分析
- ✅ **B04**：Docker 容器化
- ✅ **B05**：依賴安全掃描
- ✅ **B06**：自動化部署流程

**下一階段**：前往 `組合級/C01_安全掃描管線建立.md`，挑戰更複雜的企業級 CI/CD 工作流程整合！